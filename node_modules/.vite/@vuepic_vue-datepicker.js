import {
  addDays,
  requiredArgs,
  toDate,
  toInteger
} from "./chunk-HHPMS3FR.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentScope,
  guardReactiveProps,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUpdate,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  toRef,
  unref,
  useSlots,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-YKE26KAB.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-GKLGRTFA.js";

// node_modules/date-fns/esm/addMonths/index.js
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}

// node_modules/date-fns/esm/add/index.js
function add(dirtyDate, duration) {
  requiredArgs(2, arguments);
  if (!duration || typeof duration !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var date = toDate(dirtyDate);
  var dateWithMonths = months || years ? addMonths(date, months + years * 12) : date;
  var dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  var minutesToAdd = minutes + hours * 60;
  var secondsToAdd = seconds + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1e3;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

// node_modules/date-fns/esm/_lib/defaultOptions/index.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/esm/startOfWeek/index.js
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/startOfISOWeek/index.js
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}

// node_modules/date-fns/esm/getISOWeekYear/index.js
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/startOfISOWeekYear/index.js
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

// node_modules/date-fns/esm/startOfDay/index.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/differenceInCalendarDays/index.js
var MILLISECONDS_IN_DAY = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}

// node_modules/date-fns/esm/addYears/index.js
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

// node_modules/date-fns/esm/constants/index.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var minTime = -maxTime;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/esm/isDate/index.js
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/esm/isValid/index.js
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

// node_modules/date-fns/esm/eachDayOfInterval/index.js
function eachDayOfInterval(dirtyInterval, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}

// node_modules/date-fns/esm/endOfWeek/index.js
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
var MILLISECONDS_IN_DAY2 = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY2) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters = {
  y: function(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function(date, token) {
    var numberOfDigits = token.length;
    var milliseconds2 = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds2 * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters_default = formatters;

// node_modules/date-fns/esm/_lib/format/formatters/index.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters2 = {
  G: function(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters_default.y(date, token);
  },
  Y: function(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters_default.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters_default.d(date, token);
  },
  D: function(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters_default.h(date, token);
  },
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters_default.H(date, token);
  },
  K: function(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters_default.m(date, token);
  },
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters_default.s(date, token);
  },
  S: function(date, token) {
    return lightFormatters_default.S(date, token);
  },
  X: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters_default = formatters2;

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
var dateLongFormatter = function(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters_default = longFormatters;

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance_default = formatDistance;

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong_default = formatLong;

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var formatRelative_default = formatRelative;

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize_default = localize;

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match_default = match;

// node_modules/date-fns/esm/locale/en-US/index.js
var locale = {
  code: "en-US",
  formatDistance: formatDistance_default,
  formatLong: formatLong_default,
  formatRelative: formatRelative_default,
  localize: localize_default,
  match: match_default,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var en_US_default = locale;

// node_modules/date-fns/esm/_lib/defaultLocale/index.js
var defaultLocale_default = en_US_default;

// node_modules/date-fns/esm/format/index.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/esm/_lib/assign/index.js
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      ;
      target[property] = object[property];
    }
  }
  return target;
}

// node_modules/date-fns/esm/formatDistanceStrict/index.js
var MILLISECONDS_IN_MINUTE = 1e3 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;

// node_modules/date-fns/esm/getDay/index.js
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}

// node_modules/date-fns/esm/getDaysInMonth/index.js
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth2 = new Date(0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}

// node_modules/date-fns/esm/getHours/index.js
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}

// node_modules/date-fns/esm/getISOWeek/index.js
var MILLISECONDS_IN_WEEK3 = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK3) + 1;
}

// node_modules/date-fns/esm/getMinutes/index.js
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}

// node_modules/date-fns/esm/getMonth/index.js
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}

// node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js
var MILLISECONDS_IN_DAY3 = 24 * 60 * 60 * 1e3;

// node_modules/date-fns/esm/getSeconds/index.js
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}

// node_modules/date-fns/esm/getYear/index.js
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}

// node_modules/date-fns/esm/isAfter/index.js
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}

// node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}

// node_modules/date-fns/esm/isEqual/index.js
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}

// node_modules/date-fns/esm/parse/_lib/Setter.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = class {
  constructor() {
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(utcDate, options) {
    return this.validateValue(utcDate, this.value, options);
  }
  set(utcDate, flags, options) {
    return this.setValue(utcDate, flags, this.value, options);
  }
};
var DateToSystemTimezoneSetter = class extends Setter {
  constructor() {
    super(...arguments);
    _defineProperty(this, "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(this, "subPriority", -1);
  }
  set(date, flags) {
    if (flags.timestampIsSet) {
      return date;
    }
    var convertedDate = new Date(0);
    convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    return convertedDate;
  }
};

// node_modules/date-fns/esm/parse/_lib/Parser.js
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Parser = class {
  constructor() {
    _defineProperty2(this, "incompatibleTokens", void 0);
    _defineProperty2(this, "priority", void 0);
    _defineProperty2(this, "subPriority", void 0);
  }
  run(dateString, token, match2, options) {
    var result = this.parse(dateString, token, match2, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EraParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty3(this, "priority", 140);
    _defineProperty3(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, {
          width: "abbreviated"
        }) || match2.era(dateString, {
          width: "narrow"
        });
      case "GGGGG":
        return match2.era(dateString, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return match2.era(dateString, {
          width: "wide"
        }) || match2.era(dateString, {
          width: "abbreviated"
        }) || match2.era(dateString, {
          width: "narrow"
        });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setUTCFullYear(value, 0, 1);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/constants.js
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/esm/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var YearParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty4(this, "priority", 130);
    _defineProperty4(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    var valueCallback = function(year) {
      return {
        year,
        isTwoDigitYear: token === "yy"
      };
    };
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(match2.ordinalNumber(dateString, {
          unit: "year"
        }), valueCallback);
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    var currentYear = date.getUTCFullYear();
    if (value.isTwoDigitYear) {
      var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
      date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
    var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setUTCFullYear(year, 0, 1);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js
function _defineProperty5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty5(this, "priority", 130);
    _defineProperty5(this, "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
  }
  parse(dateString, token, match2) {
    var valueCallback = function(year) {
      return {
        year,
        isTwoDigitYear: token === "YY"
      };
    };
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(match2.ordinalNumber(dateString, {
          unit: "year"
        }), valueCallback);
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options) {
    var currentYear = getUTCWeekYear(date, options);
    if (value.isTwoDigitYear) {
      var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
      date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
    var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
    date.setUTCHours(0, 0, 0, 0);
    return startOfUTCWeek(date, options);
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js
function _defineProperty6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty6(this, "priority", 130);
    _defineProperty6(this, "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(_date, _flags, value) {
    var firstWeekOfYear = new Date(0);
    firstWeekOfYear.setUTCFullYear(value, 0, 4);
    firstWeekOfYear.setUTCHours(0, 0, 0, 0);
    return startOfUTCISOWeek(firstWeekOfYear);
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js
function _defineProperty7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ExtendedYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty7(this, "priority", 130);
    _defineProperty7(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setUTCFullYear(value, 0, 1);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js
function _defineProperty8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var QuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty8(this, "priority", 120);
    _defineProperty8(this, "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      case "Qo":
        return match2.ordinalNumber(dateString, {
          unit: "quarter"
        });
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setUTCMonth((value - 1) * 3, 1);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js
function _defineProperty9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneQuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty9(this, "priority", 120);
    _defineProperty9(this, "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      case "qo":
        return match2.ordinalNumber(dateString, {
          unit: "quarter"
        });
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setUTCMonth((value - 1) * 3, 1);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js
function _defineProperty10(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty10(this, "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty10(this, "priority", 110);
  }
  parse(dateString, token, match2) {
    var valueCallback = function(value) {
      return value - 1;
    };
    switch (token) {
      case "M":
        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(match2.ordinalNumber(dateString, {
          unit: "month"
        }), valueCallback);
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return match2.month(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setUTCMonth(value, 1);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js
function _defineProperty11(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneMonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty11(this, "priority", 110);
    _defineProperty11(this, "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    var valueCallback = function(value) {
      return value - 1;
    };
    switch (token) {
      case "L":
        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(match2.ordinalNumber(dateString, {
          unit: "month"
        }), valueCallback);
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return match2.month(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setUTCMonth(value, 1);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/_lib/setUTCWeek/index.js
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js
function _defineProperty12(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty12(this, "priority", 100);
    _defineProperty12(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, {
          unit: "week"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options) {
    return startOfUTCWeek(setUTCWeek(date, value, options), options);
  }
};

// node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js
function _defineProperty13(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty13(this, "priority", 100);
    _defineProperty13(this, "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, {
          unit: "week"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfUTCISOWeek(setUTCISOWeek(date, value));
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js
function _defineProperty14(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty14(this, "priority", 90);
    _defineProperty14(this, "subPriority", 1);
    _defineProperty14(this, "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, {
          unit: "date"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    var year = date.getUTCFullYear();
    var isLeapYear2 = isLeapYearIndex(year);
    var month = date.getUTCMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setUTCDate(value);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js
function _defineProperty15(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayOfYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty15(this, "priority", 90);
    _defineProperty15(this, "subpriority", 1);
    _defineProperty15(this, "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, {
          unit: "date"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    var year = date.getUTCFullYear();
    var isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setUTCMonth(0, value);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/_lib/setUTCDay/index.js
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js
function _defineProperty16(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty16(this, "priority", 90);
    _defineProperty16(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEE":
      default:
        return match2.day(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setUTCDay(date, value, options);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js
function _defineProperty17(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty17(this, "priority", 90);
    _defineProperty17(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
  }
  parse(dateString, token, match2, options) {
    var valueCallback = function(value) {
      var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "eo":
        return mapValue(match2.ordinalNumber(dateString, {
          unit: "day"
        }), valueCallback);
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeee":
      default:
        return match2.day(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setUTCDay(date, value, options);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js
function _defineProperty18(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneLocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty18(this, "priority", 90);
    _defineProperty18(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
  }
  parse(dateString, token, match2, options) {
    var valueCallback = function(value) {
      var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "co":
        return mapValue(match2.ordinalNumber(dateString, {
          unit: "day"
        }), valueCallback);
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, {
          width: "short",
          context: "standalone"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return match2.day(dateString, {
          width: "short",
          context: "standalone"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccc":
      default:
        return match2.day(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, {
          width: "short",
          context: "standalone"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setUTCDay(date, value, options);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/_lib/setUTCISODay/index.js
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js
function _defineProperty19(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISODayParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty19(this, "priority", 90);
    _defineProperty19(this, "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    var valueCallback = function(value) {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      case "io":
        return match2.ordinalNumber(dateString, {
          unit: "day"
        });
      case "iii":
        return mapValue(match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        }), valueCallback);
      case "iiiii":
        return mapValue(match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        }), valueCallback);
      case "iiiiii":
        return mapValue(match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        }), valueCallback);
      case "iiii":
      default:
        return mapValue(match2.day(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "short",
          context: "formatting"
        }) || match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        }), valueCallback);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setUTCISODay(date, value);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js
function _defineProperty20(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty20(this, "priority", 80);
    _defineProperty20(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js
function _defineProperty21(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMMidnightParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty21(this, "priority", 80);
    _defineProperty21(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js
function _defineProperty22(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayPeriodParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty22(this, "priority", 80);
    _defineProperty22(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js
function _defineProperty23(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1to12Parser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty23(this, "priority", 70);
    _defineProperty23(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, {
          unit: "hour"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    var isPM = date.getUTCHours() >= 12;
    if (isPM && value < 12) {
      date.setUTCHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setUTCHours(0, 0, 0, 0);
    } else {
      date.setUTCHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js
function _defineProperty24(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0to23Parser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty24(this, "priority", 70);
    _defineProperty24(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, {
          unit: "hour"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setUTCHours(value, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js
function _defineProperty25(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0To11Parser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty25(this, "priority", 70);
    _defineProperty25(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, {
          unit: "hour"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    var isPM = date.getUTCHours() >= 12;
    if (isPM && value < 12) {
      date.setUTCHours(value + 12, 0, 0, 0);
    } else {
      date.setUTCHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js
function _defineProperty26(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1To24Parser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty26(this, "priority", 70);
    _defineProperty26(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, {
          unit: "hour"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    var hours = value <= 24 ? value % 24 : value;
    date.setUTCHours(hours, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js
function _defineProperty27(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MinuteParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty27(this, "priority", 60);
    _defineProperty27(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, {
          unit: "minute"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setUTCMinutes(value, 0, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js
function _defineProperty28(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty28(this, "priority", 50);
    _defineProperty28(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, {
          unit: "second"
        });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setUTCSeconds(value, 0);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js
function _defineProperty29(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var FractionOfSecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty29(this, "priority", 30);
    _defineProperty29(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    var valueCallback = function(value) {
      return Math.floor(value * Math.pow(10, -token.length + 3));
    };
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setUTCMilliseconds(value);
    return date;
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js
function _defineProperty30(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneWithZParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty30(this, "priority", 10);
    _defineProperty30(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
      case "XXXXX":
        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) {
      return date;
    }
    return new Date(date.getTime() - value);
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js
function _defineProperty31(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty31(this, "priority", 10);
    _defineProperty31(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
      case "xxxxx":
        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) {
      return date;
    }
    return new Date(date.getTime() - value);
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js
function _defineProperty32(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampSecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty32(this, "priority", 40);
    _defineProperty32(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(_date, _flags, value) {
    return [new Date(value * 1e3), {
      timestampIsSet: true
    }];
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js
function _defineProperty33(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampMillisecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    _defineProperty33(this, "priority", 20);
    _defineProperty33(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(_date, _flags, value) {
    return [new Date(value), {
      timestampIsSet: true
    }];
  }
};

// node_modules/date-fns/esm/parse/_lib/parsers/index.js
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/date-fns/esm/parse/index.js
var formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp2 = /^'([^]*?)'?$/;
var doubleQuoteRegExp2 = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp2).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters_default) {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp2);
  var usedTokens = [];
  var _loop = function(_token) {
    if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(_token)) {
      throwProtectedError(_token, formatString, dirtyDateString);
    }
    if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(_token)) {
      throwProtectedError(_token, formatString, dirtyDateString);
    }
    var firstCharacter = _token[0];
    var parser = parsers[firstCharacter];
    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;
      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = usedTokens.find(function(usedToken) {
          return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
        });
        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(_token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError("The format string mustn't contain `".concat(_token, "` and any other token at the same time"));
      }
      usedTokens.push({
        token: firstCharacter,
        fullToken: _token
      });
      var parseResult = parser.run(dateString, _token, locale2.match, subFnOptions);
      if (!parseResult) {
        token = _token;
        return {
          v: new Date(NaN)
        };
      }
      setters.push(parseResult.setter);
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      if (_token === "''") {
        _token = "'";
      } else if (firstCharacter === "'") {
        _token = cleanEscapedString2(_token);
      }
      if (dateString.indexOf(_token) === 0) {
        dateString = dateString.slice(_token.length);
      } else {
        token = _token;
        return {
          v: new Date(NaN)
        };
      }
    }
    token = _token;
  };
  for (var token of tokens) {
    var _ret = _loop(token);
    if (typeof _ret === "object")
      return _ret.v;
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a, b) {
    return b - a;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  for (var setter of uniquePrioritySetters) {
    if (!setter.validate(utcDate, subFnOptions)) {
      return new Date(NaN);
    }
    var result = setter.set(utcDate, flags, subFnOptions);
    if (Array.isArray(result)) {
      utcDate = result[0];
      assign(flags, result[1]);
    } else {
      utcDate = result;
    }
  }
  return utcDate;
}
function cleanEscapedString2(input) {
  return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
}

// node_modules/date-fns/esm/subDays/index.js
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}

// node_modules/date-fns/esm/parseISO/index.js
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex2(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex2(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex2(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

// node_modules/date-fns/esm/setMonth/index.js
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}

// node_modules/date-fns/esm/set/index.js
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (typeof values !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate(dirtyDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = setMonth(date, values.month);
  }
  if (values.date != null) {
    date.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds(toInteger(values.milliseconds));
  }
  return date;
}

// node_modules/date-fns/esm/setHours/index.js
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}

// node_modules/date-fns/esm/setMilliseconds/index.js
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var milliseconds2 = toInteger(dirtyMilliseconds);
  date.setMilliseconds(milliseconds2);
  return date;
}

// node_modules/date-fns/esm/setMinutes/index.js
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}

// node_modules/date-fns/esm/setSeconds/index.js
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}

// node_modules/date-fns/esm/setYear/index.js
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}

// node_modules/date-fns/esm/subMonths/index.js
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}

// node_modules/date-fns/esm/sub/index.js
function sub(date, duration) {
  requiredArgs(2, arguments);
  if (!duration || typeof duration !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var dateWithoutMonths = subMonths(date, months + years * 12);
  var dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7);
  var minutestoSub = minutes + hours * 60;
  var secondstoSub = seconds + minutestoSub * 60;
  var mstoSub = secondstoSub * 1e3;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}

// node_modules/date-fns/esm/subYears/index.js
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}

// node_modules/@vuepic/vue-datepicker/dist/vue-datepicker.js
var st = (e, a) => {
  const n = e.__vccOpts || e;
  for (const [t, c] of a)
    n[t] = c;
  return n;
};
var Ia = {};
var Ya = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var Ea = createBaseVNode("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1);
var Fa = createBaseVNode("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var Ka = createBaseVNode("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var Ha = createBaseVNode("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1);
var Wa = [
  Ea,
  Fa,
  Ka,
  Ha
];
function Ua(e, a) {
  return openBlock(), createElementBlock("svg", Ya, Wa);
}
var Ht = st(Ia, [["render", Ua]]);
var La = {};
var Ga = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var ja = createBaseVNode("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1);
var za = createBaseVNode("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var Xa = [
  ja,
  za
];
function qa(e, a) {
  return openBlock(), createElementBlock("svg", Ga, Xa);
}
var Ja = st(La, [["render", qa]]);
var Za = {};
var Qa = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var xa = createBaseVNode("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var el = [
  xa
];
function tl(e, a) {
  return openBlock(), createElementBlock("svg", Qa, el);
}
var Mn = st(Za, [["render", tl]]);
var nl = {};
var al = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var ll = createBaseVNode("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1);
var rl = [
  ll
];
function sl(e, a) {
  return openBlock(), createElementBlock("svg", al, rl);
}
var Sn = st(nl, [["render", sl]]);
var ol = {};
var ul = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var il = createBaseVNode("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1);
var dl = createBaseVNode("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1);
var cl = [
  il,
  dl
];
function fl(e, a) {
  return openBlock(), createElementBlock("svg", ul, cl);
}
var Wn = st(ol, [["render", fl]]);
var ml = {};
var vl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var yl = createBaseVNode("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1);
var pl = [
  yl
];
function hl(e, a) {
  return openBlock(), createElementBlock("svg", vl, pl);
}
var Un = st(ml, [["render", hl]]);
var gl = {};
var wl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
};
var kl = createBaseVNode("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1);
var bl = [
  kl
];
function $l(e, a) {
  return openBlock(), createElementBlock("svg", wl, bl);
}
var Ln = st(gl, [["render", $l]]);
var An = (e, a) => {
  const n = parse(e, a.slice(0, e.length), new Date());
  return isValid(n) && isDate(n) ? n : null;
};
var zt = (e, a) => {
  if (typeof a == "string")
    return An(e, a);
  if (Array.isArray(a)) {
    let n = null;
    for (let t = 0; t < a.length && (n = An(e, a[t]), !n); t++)
      ;
    return n;
  }
  return typeof a == "function" ? a(e) : null;
};
var Ye = (e) => {
  let a = new Date(JSON.parse(JSON.stringify(e)));
  return a = setHours(a, 0), a = setMinutes(a, 0), a = setSeconds(a, 0), a = setMilliseconds(a, 0), a;
};
var rn = (e) => Array.isArray(e) ? isValid(e[0]) && (e[1] ? isValid(e[1]) : true) : e ? isValid(e) : false;
var Se = (e, a, n, t) => {
  let c = e ? new Date(e) : new Date();
  return (a || a === 0) && (c = setHours(c, +a)), (n || n === 0) && (c = setMinutes(c, +n)), (t || t === 0) && (c = setSeconds(c, +t)), setMilliseconds(c, 0);
};
var Dl = (e) => {
  const a = addMonths(e, 1);
  return { month: getMonth(a), year: getYear(a) };
};
var rt = (e, a, n) => {
  let t = e ? new Date(e) : new Date();
  return (a || a === 0) && (t = setMonth(t, a)), n && (t = setYear(t, n)), t;
};
var Pn = (e, a) => e ? `HH:mm${a ? ":ss" : ""}` : `hh:mm${a ? ":ss" : ""} aa`;
var Gn = (e, a, n, t, c, m, v, y) => e || (t ? "MM/yyyy" : c ? Pn(a, n) : m ? "MM/dd/yyyy" : v ? "yyyy" : y ? `MM/dd/yyyy, ${Pn(a, n)}` : "MM/dd/yyyy");
var Xt = (e) => {
  const a = e || new Date();
  return {
    hours: getHours(a),
    minutes: getMinutes(a),
    seconds: getSeconds(a)
  };
};
var Nt = (e) => ({ month: getMonth(e), year: getYear(e) });
var Cn = (e) => Array.isArray(e) ? [Nt(e[0]), e[1] ? Nt(e[1]) : null] : Nt(e);
var sn = (e) => Array.isArray(e) ? [Xt(e[0]), Xt(e[1])] : Xt(e);
var qt = (e, a, n) => n ? format(e, a, { locale: n }) : format(e, a);
var mt = (e, a, n, t, c) => Array.isArray(e) ? `${qt(e[0], a, n)} ${c && !e[1] ? "" : t || "-"} ${e[1] ? qt(e[1], a, n) : ""}` : qt(e, a, n);
var De = (e, a) => !e || !a ? false : isAfter(Ye(e), Ye(a));
var ke = (e, a) => !e || !a ? false : isBefore(Ye(e), Ye(a));
var ue = (e, a) => !e || !a ? false : isEqual(Ye(e), Ye(a));
var Ml = (e, a) => add(set(new Date(), e), a);
var Sl = (e, a) => sub(set(new Date(), e), a);
var Jt = (e) => set(new Date(), { hours: getHours(e), minutes: getMinutes(e), seconds: getSeconds(e) });
var Tn = (e) => set(new Date(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
});
var ct = (e, a, n, t) => {
  if (!e)
    return true;
  if (t) {
    const c = n === "max" ? isBefore(e, a) : isAfter(e, a), m = { seconds: 0, milliseconds: 0 };
    return c || isEqual(set(e, m), set(a, m));
  }
  return n === "max" ? e.getTime() <= a.getTime() : e.getTime() >= a.getTime();
};
var on = (e, a, n, t, c) => {
  let m = true;
  if (!e)
    return true;
  const v = !c && !t ? Array.isArray(e) ? [e[0] ? Jt(e[0]) : null, e[1] ? Jt(e[1]) : null] : Jt(e) : e;
  if (a || t) {
    const y = a ? Tn(a) : new Date(t);
    Array.isArray(v) ? m = ct(v[0], y, "max", !!t) && ct(v[1], y, "max", !!t) : m = ct(v, y, "max", !!t);
  }
  if (n || c) {
    const y = n ? Tn(n) : new Date(c);
    Array.isArray(v) ? m = ct(v[0], y, "min", !!c) && ct(v[1], y, "min", !!c) && m : m = ct(v, y, "min", !!c) && m;
  }
  return m;
};
var Al = (e, a, n) => {
  let t = true;
  return a && n && (t = De(new Date(e), new Date(a)) && ke(new Date(e), new Date(n))), a && (t = De(new Date(e), new Date(a))), n && (t = ke(new Date(e), new Date(n))), t;
};
var Ie = (e) => e instanceof Date ? e : parseISO(e);
var Zt = (e, a) => {
  if (a) {
    const t = new Date().getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - t).toISOString();
  }
  const n = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
  return new Date(n).toISOString();
};
var jn = (e, a, n) => e && e[0] && e[1] ? De(n, e[0]) && ke(n, e[1]) : e && e[0] && a ? De(n, e[0]) && ke(n, a) || ke(n, e[0]) && De(n, a) : false;
var Tt = (e, a) => {
  const n = startOfWeek(e, { weekStartsOn: a }), t = endOfWeek(e, { weekStartsOn: a });
  return [n, t];
};
var zn = (e, a) => Array.isArray(a) ? a.some((n) => ue(Ie(new Date(n)), Ie(e))) : a(e);
var Pl = (e, a, n, t, c, m, v, y) => {
  const h = n ? De(Ie(e), Ie(n)) : false, M = a ? ke(Ie(e), Ie(a)) : false, R = zn(e, t), Y = (m.months.length ? m.months.map((l) => +l) : []).includes(getMonth(e)), O = v.length ? v.some((l) => +l === getDay(e)) : false, L = c.length ? !c.some((l) => ue(Ie(l), Ie(e))) : false, T = getYear(e), te = T < +y[0] || T > +y[1];
  return !(h || M || R || Y || te || O || L);
};
var Xn = (e, a, n, t, c, m, v) => ({
  validate: (h) => Pl(h, e, a, n, t, c, m, v)
});
var ze = Symbol();
var Wt = Symbol();
var vn = Symbol();
var qn = Symbol();
var Jn = Symbol();
var Xe = Symbol();
var yn = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  autoApply: { type: Boolean, default: false },
  inline: { type: Boolean, default: false },
  textInput: { type: Boolean, default: false }
};
var pn = {
  range: { type: Boolean, default: false },
  uid: { type: String, default: null }
};
var Zn = {
  enableSeconds: { type: Boolean, default: false },
  is24: { type: Boolean, default: true },
  noHoursOverlay: { type: Boolean, default: false },
  noMinutesOverlay: { type: Boolean, default: false },
  noSecondsOverlay: { type: Boolean, default: false },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 }
};
var Qn = __spreadProps(__spreadValues({}, Zn), {
  fixedStart: { type: Boolean, default: false },
  fixedEnd: { type: Boolean, default: false },
  timePicker: { type: Boolean, default: false }
});
var xn = {
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: false },
  clearable: { type: Boolean, default: true },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: false },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: false },
  textInputOptions: { type: Object, default: () => null }
};
var ea = {
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null }
};
var hn = {
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null }
};
var ta = __spreadValues({
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: false },
  partialRange: { type: Boolean, default: true }
}, ea);
var gn = {
  monthPicker: { type: Boolean, default: false },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: false },
  modelAuto: { type: Boolean, default: false }
};
var na = {
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: { type: Boolean, default: false },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: false },
  monthChangeOnScroll: { type: [Boolean, String], default: true },
  dayNames: {
    type: [Function, Array],
    default: null
  }
};
var aa = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, Qn), ta), gn), hn), na), pn), {
  vertical: { type: Boolean, default: false },
  disableMonthYearSelect: { type: Boolean, default: false },
  menuClassName: { type: String, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: false },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: true },
  autoApply: { type: Boolean, default: false },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  monthYearComponent: { type: Object, default: null },
  timePickerComponent: { type: Object, default: null },
  actionRowComponent: { type: Object, default: null },
  hideOffsetDates: { type: Boolean, default: false },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: false },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: false },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: true },
  spaceConfirm: { type: Boolean, default: true },
  monthChangeOnArrows: { type: Boolean, default: true },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: false },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: false },
  keepActionRow: { type: Boolean, default: false },
  weekPicker: { type: Boolean, default: false },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: false },
  multiStatic: { type: Boolean, default: true },
  disableTimeRangeValidation: { type: Boolean, default: false },
  highlight: {
    type: [Array, Function],
    default: null
  },
  teleportCenter: { type: Boolean, default: false }
});
var Cl = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, xn), yn), aa), {
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: false },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: false },
  autoPosition: { type: Boolean, default: true },
  closeOnAutoApply: { type: Boolean, default: true },
  teleport: { type: [String, Object], default: "body" },
  altPosition: { type: [Boolean, Function], default: false },
  transitions: { type: [Boolean, Object], default: true },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: false },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 }
});
var la = {
  range: { type: Boolean, default: false },
  multiCalendars: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null }
};
var ra = __spreadProps(__spreadValues(__spreadValues({}, gn), la), {
  vertical: { type: Boolean, default: false },
  month: { type: Number, default: 0 },
  year: { type: Number, default: 0 },
  instance: { type: Number, default: 1 }
});
var Tl = ["aria-label", "aria-disabled", "aria-readonly"];
var _l = {
  key: 1,
  class: "dp__input_wrap"
};
var Rl = ["id", "name", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"];
var Vl = {
  key: 2,
  class: "dp__input_icon"
};
var Bl = {
  key: 4,
  class: "dp__clear_icon"
};
var Ol = defineComponent({
  __name: "DatepickerInput",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, xn), yn), pn), {
    inputValue: { type: String, default: "" },
    inline: { type: Boolean, default: false },
    isMenuOpen: { type: Boolean, default: false },
    pattern: { type: String, default: "" }
  }),
  emits: [
    "clear",
    "open",
    "update:inputValue",
    "setInputDate",
    "close",
    "selectDate",
    "setEmptyDate",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = ref(), m = ref(null), v = ref(false), y = inject(ze), h = computed(() => ({
      dp__pointer: !t.disabled && !t.readonly && !t.textInput,
      dp__disabled: t.disabled,
      dp__input_readonly: !t.textInput,
      dp__input: true,
      dp__input_icon_pad: !t.hideInputIcon,
      dp__input_valid: t.state,
      dp__input_invalid: t.state === false,
      dp__input_focus: v.value || t.isMenuOpen,
      dp__input_reg: !t.textInput,
      [t.inputClassName]: !!t.inputClassName
    })), M = (o) => {
      var U;
      const { value: F } = o.target, { format: J, rangeSeparator: _ } = t.textInputOptions;
      if (F !== "") {
        if (((U = t.textInputOptions) == null ? void 0 : U.openMenu) && !t.isMenuOpen && n("open"), t.range) {
          const [z, Z] = F.split(`${_}`);
          if (z && Z) {
            const Q = zt(z.trim(), J || t.pattern), j = zt(Z.trim(), J || t.pattern);
            c.value = Q && j ? [Q, j] : null;
          }
        } else
          c.value = zt(F, J || t.pattern);
        n("setInputDate", c.value);
      } else
        n("setInputDate", null), t.autoApply && (n("setEmptyDate"), c.value = null);
      n("update:inputValue", F);
    }, R = () => {
      var o, F;
      ((o = t.textInputOptions) == null ? void 0 : o.enterSubmit) && rn(c.value) && t.inputValue !== "" ? (n("setInputDate", c.value, true), c.value = null) : ((F = t.textInputOptions) == null ? void 0 : F.enterSubmit) && t.inputValue === "" && (c.value = null, n("clear"));
    }, B = () => {
      var o, F;
      ((o = t.textInputOptions) == null ? void 0 : o.tabSubmit) && rn(c.value) && t.inputValue !== "" ? (n("setInputDate", c.value, true), c.value = null) : ((F = t.textInputOptions) == null ? void 0 : F.tabSubmit) && t.inputValue === "" && (c.value = null, n("clear"));
    }, Y = () => {
      v.value = true, n("focus");
    }, O = (o) => {
      var F;
      o.preventDefault(), o.stopImmediatePropagation(), o.stopPropagation(), t.textInput && ((F = t.textInputOptions) == null ? void 0 : F.openMenu) ? t.isMenuOpen ? t.textInputOptions.enterSubmit && n("selectDate") : n("open") : t.textInput || n("toggle");
    }, L = () => {
      v.value = false, t.isMenuOpen || n("blur"), t.autoApply && t.textInput && c.value && (n("setInputDate", c.value), n("selectDate"), c.value = null);
    }, T = () => {
      n("clear");
    }, te = (o) => {
      t.textInput || o.preventDefault();
    };
    return a({
      focusInput: () => {
        m.value && m.value.focus({ preventScroll: true });
      }
    }), (o, F) => (openBlock(), createElementBlock("div", {
      onClick: O,
      "aria-label": unref(y).input,
      role: "textbox",
      "aria-multiline": "false",
      "aria-disabled": o.disabled,
      "aria-readonly": o.readonly
    }, [
      o.$slots.trigger && !o.$slots["dp-input"] && !e.inline ? renderSlot(o.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
      !o.$slots.trigger && (!e.inline || o.inlineWithInput) ? (openBlock(), createElementBlock("div", _l, [
        o.$slots["dp-input"] && !o.$slots.trigger && !e.inline ? renderSlot(o.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          onInput: M,
          onEnter: R,
          onTab: B,
          onClear: T
        }) : createCommentVNode("", true),
        o.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
          key: 1,
          ref_key: "inputRef",
          ref: m,
          id: o.uid ? `dp-input-${o.uid}` : void 0,
          name: o.name,
          class: normalizeClass(unref(h)),
          placeholder: o.placeholder,
          disabled: o.disabled,
          readonly: o.readonly,
          required: o.required,
          value: e.inputValue,
          autocomplete: o.autocomplete,
          onInput: M,
          onKeydown: [
            withKeys(O, ["enter"]),
            withKeys(B, ["tab"])
          ],
          onBlur: L,
          onFocus: Y,
          onKeypress: te
        }, null, 42, Rl)),
        o.$slots["input-icon"] && !o.hideInputIcon ? (openBlock(), createElementBlock("span", Vl, [
          renderSlot(o.$slots, "input-icon")
        ])) : createCommentVNode("", true),
        !o.$slots["input-icon"] && !o.hideInputIcon && !o.$slots["dp-input"] ? (openBlock(), createBlock(unref(Ht), {
          key: 3,
          class: "dp__input_icon dp__input_icons"
        })) : createCommentVNode("", true),
        o.$slots["clear-icon"] && e.inputValue && o.clearable && !o.disabled && !o.readonly ? (openBlock(), createElementBlock("span", Bl, [
          renderSlot(o.$slots, "clear-icon", { clear: T })
        ])) : createCommentVNode("", true),
        o.clearable && !o.$slots["clear-icon"] && e.inputValue && !o.disabled && !o.readonly ? (openBlock(), createBlock(unref(Ja), {
          key: 5,
          class: "dp__clear_icon dp__input_icons",
          onClick: withModifiers(T, ["stop", "prevent"])
        }, null, 8, ["onClick"])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ], 8, Tl));
  }
});
var Nl = (e, a, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), c = [];
  for (let m = 0; m < 7; m++) {
    const v = addDays(t, m), y = getMonth(v) !== a;
    c.push({
      text: n && y ? "" : v.getDate(),
      value: v,
      current: !y
    });
  }
  return c;
};
var Il = (e, a, n, t) => {
  const c = [], m = new Date(a, e), v = new Date(a, e + 1, 0), y = startOfWeek(m, { weekStartsOn: n }), h = (M) => {
    const R = Nl(M, e, t);
    if (c.push({ days: R }), !c[c.length - 1].days.some((B) => ue(Ye(B.value), Ye(v)))) {
      const B = addDays(M, 7);
      h(B);
    }
  };
  return h(y), c;
};
var Yl = (e, a = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += a)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
};
var El = (e, a) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((m) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${m}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, a), c = n.slice(a + 1, n.length);
  return [n[a]].concat(...c).concat(...t);
};
var Fl = (e) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: `${n}` });
  return a;
};
var Kl = (e, a) => {
  const n = new Intl.DateTimeFormat(e, { month: a, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((c) => {
    const m = c < 10 ? `0${c}` : c;
    return new Date(`2017-${m}-01T00:00:00+00:00`);
  }).map((c, m) => ({
    text: n.format(c),
    value: m
  }));
};
var Hl = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e];
var Wl = () => ({
  enterSubmit: true,
  tabSubmit: true,
  openMenu: true,
  rangeSeparator: " - "
});
var Ul = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e);
var Ll = (e) => {
  function n(t) {
    let c = "";
    const m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", v = m.length;
    for (let y = 0; y < t; y++)
      c += m.charAt(Math.floor(Math.random() * v));
    return c + e;
  }
  return n(5);
};
var we = (e) => {
  var n;
  const a = unref(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
};
var Gl = (e) => Object.assign({ type: "dot" }, e);
var _n = (e) => Object.assign({
  menuAppear: "dp-menu-appear",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down"
}, e);
var jl = (e) => Object.assign({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  calendarWrap: "Calendar wrapper",
  calendarDays: "Calendar days",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (a) => `Increment ${a}`,
  decrementValue: (a) => `Decrement ${a}`,
  openTpOverlay: (a) => `Open ${a} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month"
}, e);
var sa = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : false;
var oe = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
});
var Qt = ref(null);
var _t = ref(false);
var xt = ref(false);
var en = ref(false);
var tn = ref(false);
var $e = ref(0);
var he = ref(0);
var qe = () => {
  const e = computed(() => _t.value ? [...oe.selectionGrid, oe.actionRow].filter((l) => l.length) : xt.value ? [
    ...oe.timePicker[0],
    ...oe.timePicker[1],
    tn.value ? [] : [Qt.value],
    oe.actionRow
  ].filter((l) => l.length) : en.value ? [...oe.monthPicker, oe.actionRow] : [oe.monthYear, ...oe.calendar, oe.time, oe.actionRow].filter((l) => l.length)), a = (l) => {
    $e.value = l ? $e.value + 1 : $e.value - 1;
    let o = null;
    e.value[he.value] && (o = e.value[he.value][$e.value]), o || ($e.value = l ? $e.value - 1 : $e.value + 1);
  }, n = (l) => {
    if (he.value === 0 && !l || he.value === e.value.length && l)
      return;
    he.value = l ? he.value + 1 : he.value - 1, e.value[he.value] ? e.value[he.value] && !e.value[he.value][$e.value] && $e.value !== 0 && ($e.value = e.value[he.value].length - 1) : he.value = l ? he.value - 1 : he.value + 1;
  }, t = (l) => {
    let o = null;
    e.value[he.value] && (o = e.value[he.value][$e.value]), o ? o.focus({ preventScroll: !_t.value }) : $e.value = l ? $e.value - 1 : $e.value + 1;
  }, c = () => {
    a(true), t(true);
  }, m = () => {
    a(false), t(false);
  }, v = () => {
    n(false), t(true);
  }, y = () => {
    n(true), t(true);
  }, h = (l, o) => {
    oe[o] = l;
  }, M = (l, o) => {
    oe[o] = l;
  }, R = () => {
    $e.value = 0, he.value = 0;
  };
  return {
    buildMatrix: h,
    buildMultiLevelMatrix: M,
    setTimePickerBackRef: (l) => {
      Qt.value = l;
    },
    setSelectionGrid: (l) => {
      _t.value = l, R(), l || (oe.selectionGrid = []);
    },
    setTimePicker: (l, o = false) => {
      xt.value = l, tn.value = o, R(), l || (oe.timePicker[0] = [], oe.timePicker[1] = []);
    },
    setTimePickerElements: (l, o = 0) => {
      oe.timePicker[o] = l;
    },
    arrowRight: c,
    arrowLeft: m,
    arrowUp: v,
    arrowDown: y,
    clearArrowNav: () => {
      oe.monthYear = [], oe.calendar = [], oe.time = [], oe.actionRow = [], oe.selectionGrid = [], oe.timePicker[0] = [], oe.timePicker[1] = [], _t.value = false, xt.value = false, tn.value = false, en.value = false, R(), Qt.value = null;
    },
    setMonthPicker: (l) => {
      en.value = l, R();
    }
  };
};
var zl = ["aria-label"];
var Xl = {
  class: "dp__calendar_header",
  role: "row"
};
var ql = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
};
var Jl = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1);
var Zl = ["aria-label"];
var Ql = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
};
var xl = { class: "dp__cell_inner" };
var er = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var tr = createBaseVNode("div", { class: "dp__arrow_bottom_tp" }, null, -1);
var nr = defineComponent({
  __name: "Calendar",
  props: __spreadProps(__spreadValues(__spreadValues({}, ra), na), {
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    modeHeight: { type: [Number, String], default: 255 },
    specificMode: { type: Boolean, default: false }
  }),
  emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe"],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = ref(null), m = ref({ bottom: "", left: "", transform: "" }), v = ref([]), y = ref(null), h = ref(true), M = inject(Wt), R = inject(ze), B = inject(Xe), Y = ref(""), O = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), L = computed(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : El(t.locale, +t.weekStart)), { buildMultiLevelMatrix: T } = qe();
    onMounted(() => {
      n("mount", { cmp: "calendar", refs: v }), t.noSwipe || y.value && (y.value.addEventListener("touchstart", Z, { passive: false }), y.value.addEventListener("touchend", Q, { passive: false }), y.value.addEventListener("touchmove", j, { passive: false })), t.monthChangeOnScroll && y.value && y.value.addEventListener("wheel", i, { passive: false });
    });
    const te = (s, w) => {
      if (M != null && M.value) {
        const E = Ye(rt(new Date(), t.month, t.year));
        Y.value = De(Ye(rt(new Date(), s, w)), E) ? M.value[t.vertical ? "vNext" : "next"] : M.value[t.vertical ? "vPrevious" : "previous"], h.value = false, nextTick(() => {
          h.value = true;
        });
      }
    }, l = computed(() => ({
      dp__calendar_wrap: true,
      [t.calendarClassName]: !!t.calendarClassName
    })), o = computed(() => (s) => {
      const w = Gl(s);
      return {
        dp__marker_dot: w.type === "dot",
        dp__marker_line: w.type === "line"
      };
    }), F = computed(() => (s) => ue(s, c.value)), J = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: t.multiCalendars > 0 && t.instance !== 0
    })), _ = computed(() => t.specificMode ? { height: `${t.modeHeight}px` } : null), U = (s, w, E) => {
      var ee, I;
      if (n("setHoverDate", s), (I = (ee = s.marker) == null ? void 0 : ee.tooltip) != null && I.length) {
        const re = we(v.value[w][E]);
        if (re) {
          const { width: p, height: P } = re.getBoundingClientRect();
          m.value = {
            bottom: `${P}px`,
            left: `${p / 2}px`,
            transform: "translateX(-50%)"
          }, c.value = s.value;
        }
      }
    }, z = () => {
      c.value = null;
    }, Z = (s) => {
      O.value.startX = s.changedTouches[0].screenX, O.value.startY = s.changedTouches[0].screenY;
    }, Q = (s) => {
      O.value.endX = s.changedTouches[0].screenX, O.value.endY = s.changedTouches[0].screenY, D();
    }, j = (s) => {
      s.preventDefault();
    }, D = () => {
      const s = t.vertical ? "Y" : "X";
      Math.abs(O.value[`start${s}`] - O.value[`end${s}`]) > 10 && n("handleSwipe", O.value[`start${s}`] > O.value[`end${s}`] ? "right" : "left");
    }, $ = (s, w, E) => {
      s && (Array.isArray(v.value[w]) ? v.value[w][E] = s : v.value[w] = [s]), B != null && B.value && T(v.value, "calendar");
    }, i = (s) => {
      t.monthChangeOnScroll && (s.preventDefault(), n("handleScroll", s));
    };
    return a({ triggerTransition: te }), (s, w) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(J))
    }, [
      createBaseVNode("div", {
        style: normalizeStyle(unref(_))
      }, [
        e.specificMode ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "calendarWrapRef",
          ref: y,
          class: normalizeClass(unref(l)),
          role: "grid",
          "aria-label": unref(R).calendarWrap
        }, [
          createBaseVNode("div", Xl, [
            s.weekNumbers ? (openBlock(), createElementBlock("div", ql, toDisplayString(s.weekNumName), 1)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(L), (E, ee) => (openBlock(), createElementBlock("div", {
              class: "dp__calendar_header_item",
              role: "gridcell",
              key: ee
            }, [
              s.$slots["calendar-header"] ? renderSlot(s.$slots, "calendar-header", {
                key: 0,
                day: E,
                index: ee
              }) : createCommentVNode("", true),
              s.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(E), 1)
              ], 64))
            ]))), 128))
          ]),
          Jl,
          createVNode(Transition, {
            name: Y.value,
            css: !!unref(M)
          }, {
            default: withCtx(() => [
              h.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "dp__calendar",
                role: "grid",
                "aria-label": unref(R).calendarDays
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(e.mappedDates, (E, ee) => (openBlock(), createElementBlock("div", {
                  class: "dp__calendar_row",
                  role: "row",
                  key: ee
                }, [
                  s.weekNumbers ? (openBlock(), createElementBlock("div", Ql, [
                    createBaseVNode("div", xl, toDisplayString(e.getWeekNum(E.days)), 1)
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(E.days, (I, re) => (openBlock(), createElementBlock("div", {
                    role: "gridcell",
                    class: "dp__calendar_item",
                    ref_for: true,
                    ref: (p) => $(p, ee, re),
                    key: re + ee,
                    "aria-selected": I.classData.dp__active_date || I.classData.dp__range_start || I.classData.dp__range_start,
                    "aria-disabled": I.classData.dp__cell_disabled,
                    tabindex: "0",
                    onClick: withModifiers((p) => s.$emit("selectDate", I), ["stop", "prevent"]),
                    onKeydown: withKeys((p) => s.$emit("selectDate", I), ["enter"]),
                    onMouseover: (p) => U(I, ee, re),
                    onMouseleave: z
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["dp__cell_inner", I.classData])
                    }, [
                      s.$slots.day ? renderSlot(s.$slots, "day", {
                        key: 0,
                        day: +I.text,
                        date: I.value
                      }) : createCommentVNode("", true),
                      s.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(I.text), 1)
                      ], 64)),
                      I.marker ? (openBlock(), createElementBlock("div", {
                        key: 2,
                        class: normalizeClass(unref(o)(I.marker)),
                        style: normalizeStyle(I.marker.color ? { backgroundColor: I.marker.color } : {})
                      }, null, 6)) : createCommentVNode("", true),
                      unref(F)(I.value) ? (openBlock(), createElementBlock("div", {
                        key: 3,
                        class: "dp__marker_tooltip",
                        style: normalizeStyle(m.value)
                      }, [
                        createBaseVNode("div", {
                          class: "dp__tooltip_content",
                          onClick: w[0] || (w[0] = withModifiers(() => {
                          }, ["stop"]))
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(I.marker.tooltip, (p, P) => (openBlock(), createElementBlock("div", {
                            key: P,
                            class: "dp__tooltip_text"
                          }, [
                            s.$slots["marker-tooltip"] ? renderSlot(s.$slots, "marker-tooltip", {
                              key: 0,
                              tooltop: p,
                              day: I.value
                            }) : createCommentVNode("", true),
                            s.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createBaseVNode("div", {
                                class: "dp__tooltip_mark",
                                style: normalizeStyle(p.color ? { backgroundColor: p.color } : {})
                              }, null, 4),
                              createBaseVNode("div", null, toDisplayString(p.text), 1)
                            ], 64))
                          ]))), 128)),
                          tr
                        ])
                      ], 4)) : createCommentVNode("", true)
                    ], 2)
                  ], 40, er))), 128))
                ]))), 128))
              ], 8, Zl)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ], 10, zl))
      ], 4)
    ], 2));
  }
});
var ar = (e) => typeof e == "object";
var Rn = (e, a) => a;
var lr = (e) => Array.isArray(e) && e.length === 2;
var rr = (e) => Array.isArray(e);
var sr = (e) => typeof e == "object";
var bt = (e) => Array.isArray(e);
var _e = (e) => Array.isArray(e);
var It = (e) => Array.isArray(e) && e.length === 2;
var or = (e, a) => a ? Array.isArray(e) : It(e);
var ur = (e) => Array.isArray(e);
var ir = (e) => typeof e == "string" || typeof e == "object" || typeof e == "number";
var Vn = (e) => typeof e == "string";
var dr = { class: "dp__selection_preview" };
var cr = { class: "dp__action_buttons" };
var fr = ["onKeydown"];
var mr = defineComponent({
  __name: "ActionRow",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, ta), hn), ea), gn), la), {
    inline: { type: Boolean, default: false },
    timePicker: { type: Boolean, default: false },
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: false },
    enableTimePicker: { type: Boolean, default: true }
  }),
  emits: ["closePicker", "selectDate", "invalid-select"],
  setup(e, { emit: a }) {
    const n = e, { buildMatrix: t } = qe(), c = inject(Jn), m = inject(Xe), v = ref(null), y = ref(null);
    onMounted(() => {
      m != null && m.value && t([we(v), we(y)], "actionRow");
    });
    const h = computed(() => n.range && !n.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : true), M = computed(() => ({
      dp__action: true,
      dp__select: true,
      dp__action_disabled: !R.value || !B.value || !h.value
    })), R = computed(() => n.enableTimePicker ? on(n.internalModelValue, n.maxTime, n.minTime, n.maxDate, n.minDate) : true), B = computed(() => n.monthPicker ? Al(n.internalModelValue, n.minDate, n.maxDate) : true), Y = (T) => mt(T, n.previewFormat, c == null ? void 0 : c.value), O = computed(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? bt(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${Y(n.internalModelValue[0])} - ${Y(n.internalModelValue[1])}` : [Y(n.internalModelValue[0]), Y(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map((T) => `${Y(T)}`) : n.modelAuto ? `${Y(n.internalModelValue[0])}` : `${Y(n.internalModelValue[0])} -` : mt(n.internalModelValue, n.previewFormat, c == null ? void 0 : c.value) : n.timePicker ? n.previewFormat(sn(n.internalModelValue)) : n.monthPicker ? n.previewFormat(Nt(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), L = () => {
      R.value && B.value && h.value ? a("selectDate") : a("invalid-select");
    };
    return (T, te) => (openBlock(), createElementBlock("div", {
      class: "dp__action_row",
      style: normalizeStyle(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      createBaseVNode("div", dr, [
        T.$slots["action-preview"] ? renderSlot(T.$slots, "action-preview", {
          key: 0,
          value: T.internalModelValue
        }) : createCommentVNode("", true),
        T.$slots["action-preview"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          Array.isArray(unref(O)) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(unref(O)), 1)
          ], 64)),
          Array.isArray(unref(O)) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(O), (l, o) => (openBlock(), createElementBlock("div", { key: o }, toDisplayString(l), 1))), 128)) : createCommentVNode("", true)
        ], 64))
      ]),
      createBaseVNode("div", cr, [
        T.$slots["action-select"] ? renderSlot(T.$slots, "action-select", {
          key: 0,
          value: T.internalModelValue
        }) : createCommentVNode("", true),
        T.$slots["action-select"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          e.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", {
            key: 0,
            class: "dp__action dp__cancel",
            ref_key: "cancelButtonRef",
            ref: v,
            tabindex: "0",
            onClick: te[0] || (te[0] = (l) => T.$emit("closePicker")),
            onKeydown: te[1] || (te[1] = withKeys((l) => T.$emit("closePicker"), ["enter"]))
          }, toDisplayString(T.cancelText), 545)),
          createBaseVNode("span", {
            class: normalizeClass(unref(M)),
            tabindex: "0",
            onKeydown: withKeys(L, ["enter"]),
            onClick: L,
            ref_key: "selectButtonRef",
            ref: y
          }, toDisplayString(T.selectText), 43, fr)
        ], 64))
      ])
    ], 4));
  }
});
var vr = { class: "dp__selection_grid_header" };
var yr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"];
var pr = ["aria-label", "onKeydown"];
var Dt = defineComponent({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: false },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: false },
    monthPicker: { type: Boolean, default: false },
    yearPicker: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "selected", "toggle", "reset-flow"],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = ref(false), m = ref(null), v = ref(null), y = ref([]), h = inject(vn, false), M = inject(qn, ref(false)), R = inject(ze), B = inject(Xe), Y = ref(), O = ref(), { setSelectionGrid: L, buildMultiLevelMatrix: T, setMonthPicker: te } = qe();
    onBeforeUpdate(() => {
      m.value = null;
    }), onMounted(() => {
      nextTick().then(() => Q()), o(), l(true);
    }), onUnmounted(() => l(false));
    const l = (s) => {
      var w;
      B != null && B.value && ((w = t.headerRefs) != null && w.length ? te(s) : L(s));
    }, o = () => {
      const s = we(v);
      s && (M.value || s.focus({ preventScroll: true }), c.value = s.clientHeight < s.scrollHeight);
    }, F = computed(() => ({
      dp__overlay: true
    })), J = computed(() => ({
      dp__overlay_col: true
    })), _ = computed(() => t.items.map((s) => s.filter((w) => w).map((w) => {
      var I, re, p;
      const E = t.disabledValues.some((P) => P === w.value) || Z(w.value), ee = (I = t.multiModelValue) != null && I.length ? (re = t.multiModelValue) == null ? void 0 : re.some((P) => ue(P, setYear(t.monthPicker ? setMonth(new Date(), w.value) : new Date(), t.monthPicker ? t.year : w.value))) : t.skipActive ? false : w.value === t.modelValue;
      return __spreadProps(__spreadValues({}, w), {
        className: {
          dp__overlay_cell_active: ee,
          dp__overlay_cell: !ee,
          dp__overlay_cell_disabled: E,
          dp__overlay_cell_active_disabled: E && ee,
          dp__overlay_cell_pad: true,
          dp__cell_in_between: (p = t.multiModelValue) != null && p.length ? D(w.value) : false
        }
      });
    }))), U = computed(() => ({
      dp__button: true,
      dp__overlay_action: true,
      dp__over_action_scroll: c.value,
      dp__button_bottom: h
    })), z = computed(() => {
      var s, w;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((s = t.items) == null ? void 0 : s.length) <= 6,
        dp__container_block: ((w = t.items) == null ? void 0 : w.length) > 6
      };
    }), Z = (s) => {
      const w = t.maxValue || t.maxValue === 0, E = t.minValue || t.minValue === 0;
      return !w && !E ? false : w && E ? +s > +t.maxValue || +s < +t.minValue : w ? +s > +t.maxValue : E ? +s < +t.minValue : false;
    }, Q = () => {
      const s = we(m);
      if (s) {
        const w = we(v);
        w && (w.scrollTop = s.offsetTop - w.offsetTop - (w.getBoundingClientRect().height / 2 - s.getBoundingClientRect().height));
      }
    }, j = (s) => {
      !t.disabledValues.some((w) => w === s) && !Z(s) && (n("update:modelValue", s), n("selected"));
    }, D = (s) => {
      const w = t.monthPicker ? t.year : s;
      return jn(t.multiModelValue, setYear(t.monthPicker ? setMonth(new Date(), Y.value || 0) : new Date(), t.monthPicker ? w : Y.value || w), setYear(t.monthPicker ? setMonth(new Date(), s) : new Date(), w));
    }, $ = () => {
      n("toggle"), n("reset-flow");
    }, i = (s, w, E, ee) => {
      var I, re;
      if (s && (w.value === +t.modelValue && !t.disabledValues.includes(w.value) && (m.value = s), B != null && B.value)) {
        Array.isArray(y.value[E]) ? y.value[E][ee] = s : y.value[E] = [s];
        const p = (I = t.headerRefs) != null && I.length ? [t.headerRefs].concat(y.value) : y.value.concat([t.skipButtonRef ? [] : [O.value]]);
        T(p, (re = t.headerRefs) != null && re.length ? "monthPicker" : "selectionGrid");
      }
    };
    return a({ focusGrid: o }), (s, w) => (openBlock(), createElementBlock("div", {
      ref_key: "gridWrapRef",
      ref: v,
      class: normalizeClass(unref(F)),
      role: "dialog",
      tabindex: "0"
    }, [
      createBaseVNode("div", {
        class: normalizeClass(unref(z)),
        role: "grid"
      }, [
        createBaseVNode("div", vr, [
          renderSlot(s.$slots, "header")
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(_), (E, ee) => (openBlock(), createElementBlock("div", {
          class: "dp__overlay_row",
          key: unref(Ll)(ee),
          role: "row"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(E, (I, re) => (openBlock(), createElementBlock("div", {
            role: "gridcell",
            class: normalizeClass(unref(J)),
            key: I.value,
            "aria-selected": I.value === e.modelValue && !e.disabledValues.includes(I.value),
            "aria-disabled": I.className.dp__overlay_cell_disabled,
            ref_for: true,
            ref: (p) => i(p, I, ee, re),
            tabindex: "0",
            onClick: (p) => j(I.value),
            onKeydown: withKeys((p) => j(I.value), ["enter"]),
            onMouseover: (p) => Y.value = I.value
          }, [
            createBaseVNode("div", {
              class: normalizeClass(I.className)
            }, [
              s.$slots.item ? renderSlot(s.$slots, "item", {
                key: 0,
                item: I
              }) : createCommentVNode("", true),
              s.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(I.text), 1)
              ], 64))
            ], 2)
          ], 42, yr))), 128))
        ]))), 128)),
        s.$slots["button-icon"] ? (openBlock(), createElementBlock("div", {
          key: 0,
          role: "button",
          "aria-label": unref(R).toggleOverlay,
          class: normalizeClass(unref(U)),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: O,
          onClick: $,
          onKeydown: withKeys($, ["enter"])
        }, [
          renderSlot(s.$slots, "button-icon")
        ], 42, pr)) : createCommentVNode("", true)
      ], 2)
    ], 2));
  }
});
var Ut = () => {
  const e = inject(Wt);
  return { transitionName: computed(() => (n) => e != null && e.value ? n ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
};
var hr = {
  key: 0,
  class: "dp__time_input"
};
var gr = createTextVNode(" : ");
var wr = ["aria-label", "onKeydown", "onClick"];
var kr = ["aria-label", "onKeydown", "onClick"];
var br = ["aria-label", "onKeydown", "onClick"];
var $r = { key: 0 };
var Dr = ["aria-label", "onKeydown"];
var Mr = defineComponent({
  __name: "TimeInput",
  props: __spreadProps(__spreadValues({}, Zn), {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    filters: { type: Object, default: () => ({}) },
    disabled: { type: Boolean, default: false },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 }
  }),
  emits: [
    "setHours",
    "setMinutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = reactive({
      hours: false,
      minutes: false,
      seconds: false
    }), m = ref("AM"), v = ref(null), y = inject(ze), h = inject(Xe), M = ref([]), { transitionName: R, showTransition: B } = Ut(), { setTimePickerElements: Y, setTimePickerBackRef: O } = qe();
    onMounted(() => {
      n("mounted");
    });
    const L = computed(() => ({
      dp__time_col: true,
      dp__time_col_reg: !t.enableSeconds && t.is24,
      dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
      dp__time_col_sec: t.enableSeconds && t.is24,
      dp__time_col_sec_with_button: t.enableSeconds && !t.is24
    })), T = computed(() => {
      const D = [{ type: "hours" }, "separator", { type: "minutes" }];
      return t.enableSeconds ? D.concat(["separator", { type: "seconds" }]) : D;
    }), te = computed(() => T.value.filter((D) => typeof D != "string")), l = computed(() => (D) => {
      if (D === "hours") {
        const $ = U(t.hours);
        return { text: $ < 10 ? `0${$}` : `${$}`, value: $ };
      }
      return { text: t[D] < 10 ? `0${t[D]}` : `${t[D]}`, value: t[D] };
    }), o = (D) => {
      const $ = D === "hours" ? t.is24 ? 24 : 12 : 60, i = +t[`${D}GridIncrement`], s = [];
      for (let w = 0; w < $; w += i)
        s.push({ value: w, text: w < 10 ? `0${w}` : `${w}` });
      return Yl(s);
    }, F = (D) => t[`no${D[0].toUpperCase() + D.slice(1)}Overlay`], J = (D) => {
      F(D) || (c[D] = !c[D], c[D] || n("overlay-closed"));
    }, _ = (D, $ = true) => {
      const i = D === "hours" ? getHours : D === "minutes" ? getMinutes : getSeconds, s = $ ? Ml : Sl;
      n(`update:${D}`, i(s({ [D]: +t[D] }, { [D]: +t[`${D}Increment`] })));
    }, U = (D) => t.is24 ? D : (D >= 12 ? m.value = "PM" : m.value = "AM", Hl(D)), z = () => {
      m.value === "PM" ? (m.value = "AM", n("update:hours", t.hours - 12)) : (m.value = "PM", n("update:hours", t.hours + 12));
    }, Z = (D) => {
      c[D] = true;
    }, Q = (D, $, i) => {
      if (D && (h == null ? void 0 : h.value)) {
        Array.isArray(M.value[$]) ? M.value[$][i] = D : M.value[$] = [D];
        const s = M.value.reduce((w, E) => E.map((ee, I) => [...w[I] || [], E[I]]), []);
        O(t.closeTimePickerBtn), v.value && (s[1] = s[1].concat(v.value)), Y(s, t.order);
      }
    }, j = (D, $) => D === "hours" && !t.is24 ? n(`update:${D}`, m.value === "PM" ? $ + 12 : $) : n(`update:${D}`, $);
    return a({ openChildCmp: Z }), (D, $) => e.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", hr, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(T), (i, s) => (openBlock(), createElementBlock("div", {
        key: s,
        class: normalizeClass(unref(L))
      }, [
        i === "separator" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          gr
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": unref(y).incrementValue(i.type),
            tabindex: "0",
            onKeydown: withKeys((w) => _(i.type), ["enter"]),
            onClick: (w) => _(i.type),
            ref_for: true,
            ref: (w) => Q(w, s, 0)
          }, [
            D.$slots["arrow-up"] ? renderSlot(D.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
            D.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Un), { key: 1 }))
          ], 40, wr),
          createBaseVNode("div", {
            role: "button",
            "aria-label": unref(y).openTpOverlay(i.type),
            class: normalizeClass(F(i.type) ? "" : "dp__time_display"),
            tabindex: "0",
            onKeydown: withKeys((w) => J(i.type), ["enter"]),
            onClick: (w) => J(i.type),
            ref_for: true,
            ref: (w) => Q(w, s, 1)
          }, [
            D.$slots[i.type] ? renderSlot(D.$slots, i.type, {
              key: 0,
              text: unref(l)(i.type).text,
              value: unref(l)(i.type).value
            }) : createCommentVNode("", true),
            D.$slots[i.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(unref(l)(i.type).text), 1)
            ], 64))
          ], 42, kr),
          createBaseVNode("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": unref(y).decrementValue(i.type),
            tabindex: "0",
            onKeydown: withKeys((w) => _(i.type, false), ["enter"]),
            onClick: (w) => _(i.type, false),
            ref_for: true,
            ref: (w) => Q(w, s, 2)
          }, [
            D.$slots["arrow-down"] ? renderSlot(D.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
            D.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ln), { key: 1 }))
          ], 40, br)
        ], 64))
      ], 2))), 128)),
      D.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", $r, [
        D.$slots["am-pm-button"] ? renderSlot(D.$slots, "am-pm-button", {
          key: 0,
          toggle: z,
          value: m.value
        }) : createCommentVNode("", true),
        D.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: v,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": unref(y).amPmButton,
          tabindex: "0",
          onClick: z,
          onKeydown: withKeys(withModifiers(z, ["prevent"]), ["enter"])
        }, toDisplayString(m.value), 41, Dr))
      ])),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(te), (i, s) => (openBlock(), createBlock(Transition, {
        key: s,
        name: unref(R)(c[i.type]),
        css: unref(B)
      }, {
        default: withCtx(() => [
          c[i.type] ? (openBlock(), createBlock(Dt, {
            key: 0,
            items: o(i.type),
            "disabled-values": e.filters.times[i.type],
            "onUpdate:modelValue": (w) => j(i.type, w),
            onSelected: (w) => J(i.type),
            onToggle: (w) => J(i.type),
            onResetFlow: $[0] || ($[0] = (w) => D.$emit("reset-flow"))
          }, createSlots({
            "button-icon": withCtx(() => [
              D.$slots["clock-icon"] ? renderSlot(D.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
              D.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wn), { key: 1 }))
            ]),
            _: 2
          }, [
            D.$slots[`${i.type}-overlay`] ? {
              name: "item",
              fn: withCtx(({ item: w }) => [
                renderSlot(D.$slots, `${i.type}-overlay`, {
                  text: w.text,
                  value: w.value
                })
              ])
            } : void 0
          ]), 1032, ["items", "disabled-values", "onUpdate:modelValue", "onSelected", "onToggle"])) : createCommentVNode("", true)
        ]),
        _: 2
      }, 1032, ["name", "css"]))), 128))
    ]));
  }
});
var kt = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["calendar", "month-year"] },
  { name: "hours-overlay", use: ["calendar", "time"] },
  { name: "minutes-overlay", use: ["calendar", "time"] },
  { name: "seconds-overlay", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] }
];
var Sr = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }];
var Ar = {
  all: () => kt,
  monthYear: () => kt.filter((e) => e.use.includes("month-year")),
  input: () => Sr,
  timePicker: () => kt.filter((e) => e.use.includes("time")),
  action: () => kt.filter((e) => e.use.includes("action")),
  calendar: () => kt.filter((e) => e.use.includes("calendar"))
};
var at = (e, a) => {
  const n = [];
  return Ar[a]().forEach((t) => {
    e[t.name] && n.push(t.name);
  }), n;
};
var Pr = ["aria-label"];
var Cr = { class: "dp__overlay_container dp__container_flex" };
var Tr = {
  key: 1,
  class: "dp__overlay_row"
};
var _r = ["aria-label"];
var Rr = defineComponent({
  __name: "TimePicker",
  props: __spreadProps(__spreadValues({}, Qn), {
    range: { type: Boolean, default: false },
    filters: { type: Object, default: () => ({}) },
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    customProps: { type: Object, default: null },
    modelAuto: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null }
  }),
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = useSlots(), m = ref(null), v = ref(null), y = inject(vn, false), h = ref([]), M = ref(null), R = inject(ze), B = inject(Xe), { transitionName: Y, showTransition: O } = Ut(), { buildMatrix: L, setTimePicker: T } = qe();
    onMounted(() => {
      n("mount"), !t.timePicker && (B == null ? void 0 : B.value) ? L([we(m.value)], "time") : T(true, t.timePicker);
    });
    const te = computed(() => t.range && t.modelAuto ? sa(t.internalModelValue) : true), l = ref(false), o = ($) => ({
      hours: Array.isArray(t.hours) ? t.hours[$] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[$] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[$] : t.seconds
    }), F = computed(() => {
      const $ = [];
      if (t.range)
        for (let i = 0; i < 2; i++)
          $.push(o(i));
      else
        $.push(o(0));
      return $;
    }), J = ($, i = false, s = "") => {
      i || n("reset-flow"), l.value = $, B != null && B.value && (T($), $ || n("overlay-closed")), nextTick(() => {
        s !== "" && h.value[0] && h.value[0].openChildCmp(s);
      });
    }, _ = computed(() => ({
      dp__button: true,
      dp__button_bottom: y
    })), U = at(c, "timePicker"), z = ($, i, s) => t.range ? i === 0 ? [$, F.value[1][s]] : [F.value[0][s], $] : $, Z = ($) => {
      n("update:hours", $);
    }, Q = ($) => {
      n("update:minutes", $);
    }, j = ($) => {
      n("update:seconds", $);
    }, D = () => {
      M.value && (B == null ? void 0 : B.value) && M.value.focus({ preventScroll: true });
    };
    return a({ toggleTimePicker: J }), ($, i) => (openBlock(), createElementBlock("div", null, [
      $.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(unref(_)),
        role: "button",
        "aria-label": unref(R).openTimePicker,
        tabindex: "0",
        ref_key: "openTimePickerBtn",
        ref: m,
        onKeydown: i[0] || (i[0] = withKeys((s) => J(true), ["enter"])),
        onClick: i[1] || (i[1] = (s) => J(true))
      }, [
        $.$slots["clock-icon"] ? renderSlot($.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
        $.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wn), { key: 1 }))
      ], 42, Pr)),
      createVNode(Transition, {
        name: unref(Y)(l.value),
        css: unref(O)
      }, {
        default: withCtx(() => [
          l.value || $.timePicker ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "dp__overlay",
            ref_key: "overlayRef",
            ref: M,
            tabindex: "0"
          }, [
            createBaseVNode("div", Cr, [
              $.$slots["time-picker-overlay"] ? renderSlot($.$slots, "time-picker-overlay", {
                key: 0,
                range: e.range,
                hours: e.hours,
                minutes: e.minutes,
                seconds: e.seconds,
                setHours: Z,
                setMinutes: Q,
                setSeconds: j
              }) : createCommentVNode("", true),
              $.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Tr, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(F), (s, w) => withDirectives((openBlock(), createBlock(Mr, mergeProps({
                  key: w,
                  disabled: w === 0 ? $.fixedStart : $.fixedEnd,
                  hours: s.hours,
                  minutes: s.minutes,
                  seconds: s.seconds,
                  filters: e.filters,
                  ref_for: true,
                  ref_key: "timeInputRefs",
                  ref: h
                }, {
                  is24: $.is24,
                  hoursGridIncrement: $.hoursGridIncrement,
                  minutesGridIncrement: $.minutesGridIncrement,
                  secondsGridIncrement: $.secondsGridIncrement,
                  hoursIncrement: $.hoursIncrement,
                  minutesIncrement: $.minutesIncrement,
                  secondsIncrement: $.secondsIncrement,
                  filters: e.filters,
                  noHoursOverlay: $.noHoursOverlay,
                  noMinutesOverlay: $.noMinutesOverlay,
                  noSecondsOverlay: $.noSecondsOverlay,
                  enableSeconds: $.enableSeconds,
                  closeTimePickerBtn: v.value,
                  order: w
                }, {
                  "onUpdate:hours": (E) => Z(z(E, w, "hours")),
                  "onUpdate:minutes": (E) => Q(z(E, w, "minutes")),
                  "onUpdate:seconds": (E) => j(z(E, w, "seconds")),
                  onMounted: D,
                  onOverlayClosed: D
                }), createSlots({ _: 2 }, [
                  renderList(unref(U), (E, ee) => ({
                    name: E,
                    fn: withCtx((I) => [
                      renderSlot($.$slots, E, normalizeProps(guardReactiveProps(I)))
                    ])
                  }))
                ]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                  [vShow, w === 0 ? true : unref(te)]
                ])), 128))
              ])),
              $.timePicker ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                key: 2,
                ref_key: "closeTimePickerBtn",
                ref: v,
                class: normalizeClass(unref(_)),
                role: "button",
                "aria-label": unref(R).closeTimePicker,
                tabindex: "0",
                onKeydown: i[2] || (i[2] = withKeys((s) => J(false), ["enter"])),
                onClick: i[3] || (i[3] = (s) => J(false))
              }, [
                $.$slots["calendar-icon"] ? renderSlot($.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                $.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ht), { key: 1 }))
              ], 42, _r))
            ])
          ], 512)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ]));
  }
});
var Vr = ["aria-label"];
var nn = defineComponent({
  __name: "ActionIcon",
  props: { ariaLabel: { type: String, default: "" } },
  emits: ["activate", "setRef"],
  setup(e, { emit: a }) {
    const n = ref(null);
    return onMounted(() => a("setRef", n)), (t, c) => (openBlock(), createElementBlock("div", {
      class: "dp__month_year_col_nav",
      onClick: c[0] || (c[0] = (m) => t.$emit("activate")),
      onKeydown: c[1] || (c[1] = withKeys((m) => t.$emit("activate"), ["enter"])),
      tabindex: "0",
      ref_key: "elRef",
      ref: n
    }, [
      createBaseVNode("div", {
        class: "dp__inner_nav",
        role: "button",
        "aria-label": e.ariaLabel
      }, [
        renderSlot(t.$slots, "default")
      ], 8, Vr)
    ], 544));
  }
});
var Br = ["aria-label"];
var Bn = defineComponent({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: false },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "setRef"],
  setup(e, { emit: a }) {
    const { transitionName: n, showTransition: t } = Ut(), c = ref(null);
    return onMounted(() => a("setRef", c)), (m, v) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        class: "dp__month_year_select",
        onClick: v[0] || (v[0] = (y) => m.$emit("toggle")),
        onKeydown: v[1] || (v[1] = withKeys((y) => m.$emit("toggle"), ["enter"])),
        role: "button",
        "aria-label": e.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: c
      }, [
        renderSlot(m.$slots, "default")
      ], 40, Br),
      createVNode(Transition, {
        name: unref(n)(e.showSelectionGrid),
        css: unref(t)
      }, {
        default: withCtx(() => [
          e.showSelectionGrid ? (openBlock(), createBlock(Dt, mergeProps({ key: 0 }, {
            modelValue: e.modelValue,
            items: e.items,
            disabledValues: e.disabledValues,
            minValue: e.minValue,
            maxValue: e.maxValue
          }, {
            "header-refs": [],
            "onUpdate:modelValue": v[2] || (v[2] = (y) => m.$emit("update:model-value", y)),
            onToggle: v[3] || (v[3] = (y) => m.$emit("toggle"))
          }), createSlots({
            "button-icon": withCtx(() => [
              m.$slots["calendar-icon"] ? renderSlot(m.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
              m.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ht), { key: 1 }))
            ]),
            _: 2
          }, [
            m.$slots[e.slotName] ? {
              name: "item",
              fn: withCtx(({ item: y }) => [
                renderSlot(m.$slots, e.slotName, { item: y })
              ])
            } : void 0
          ]), 1040)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
});
var Ft = (e, a, n) => [set(new Date(e), { date: 1 }), set(new Date(), { month: a, year: n, date: 1 })];
var On = (e, a, n) => ke(...Ft(e, a, n)) || ue(...Ft(e, a, n));
var Nn = (e, a, n) => De(...Ft(e, a, n)) || ue(...Ft(e, a, n));
var oa = (e, a, n, t, c, m) => {
  let v = false;
  return m ? e && a ? (a && c && Nn(a, n, t) && (v = true), e && !c && On(e, n, t) && (v = true)) : (e && On(e, n, t) || a && Nn(a, n, t)) && (v = true) : v = true, v;
};
var Or = (e, a) => {
  const n = (v, y) => {
    let h = v;
    return e.filters.months.includes(getMonth(h)) ? (h = y ? addMonths(v, 1) : subMonths(v, 1), n(h, y)) : h;
  }, t = (v, y) => {
    let h = v;
    return e.filters.years.includes(getYear(h)) ? (h = y ? addYears(v, 1) : subYears(v, 1), t(h, y)) : h;
  }, c = (v) => {
    const y = set(new Date(), { month: e.month, year: e.year });
    let h = v ? addMonths(y, 1) : subMonths(y, 1), M = getMonth(h), R = getYear(h);
    e.filters.months.includes(M) && (h = n(h, v), M = getMonth(h), R = getYear(h)), e.filters.years.includes(R) && (h = t(h, v), R = getYear(h)), oa(e.minDate, e.maxDate, M, R, v, e.preventMinMaxNavigation) && m(M, R);
  }, m = (v, y) => {
    a("update-month-year", { month: v, year: y });
  };
  return { handleMonthYearChange: c };
};
var Nr = { class: "dp__month_year_row" };
var Ir = { class: "dp__month_picker_header" };
var Yr = ["aria-label"];
var Er = ["aria-label", "onKeydown"];
var Fr = ["aria-label"];
var Kr = defineComponent({
  __name: "MonthYearPicker",
  props: __spreadProps(__spreadValues(__spreadValues({}, ra), hn), {
    preventMinMaxNavigation: { type: Boolean, default: false },
    reverseYears: { type: Boolean, default: false },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    filters: { type: Object, default: () => ({}) },
    multiCalendarsSolo: { type: Boolean, default: false },
    yearPicker: { type: Boolean, default: false }
  }),
  emits: ["update-month-year", "monthYearSelect", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: a, emit: n }) {
    const t = e, { transitionName: c, showTransition: m } = Ut(), { buildMatrix: v } = qe(), y = ref(false), h = ref(false), M = ref([null, null, null, null]), R = ref(null), B = ref(null), Y = ref(null), O = inject(ze), L = inject(Xe), { handleMonthYearChange: T } = Or(t, n);
    onMounted(() => {
      n("mount");
    });
    const te = (p) => ({
      get: () => t[p],
      set: (P) => {
        const N = p === "month" ? "year" : "month";
        n("update-month-year", { [p]: P, [N]: t[N] }), n("monthYearSelect", p === "year"), p === "month" ? w(true) : E(true);
      }
    }), l = computed(te("month")), o = computed(te("year")), F = computed(() => (p) => {
      const P = p === "month";
      return {
        showSelectionGrid: (P ? y : h).value,
        items: (P ? D : $).value,
        disabledValues: t.filters[P ? "months" : "years"],
        minValue: (P ? U : J).value,
        maxValue: (P ? z : _).value,
        headerRefs: P && t.monthPicker ? [R.value, B.value, Y.value] : []
      };
    }), J = computed(() => t.minDate ? getYear(new Date(t.minDate)) : null), _ = computed(() => t.maxDate ? getYear(new Date(t.maxDate)) : null), U = computed(() => {
      if (t.minDate && J.value) {
        if (J.value > t.year)
          return 12;
        if (J.value === t.year)
          return getMonth(new Date(t.minDate));
      }
      return null;
    }), z = computed(() => t.maxDate && _.value ? _.value < t.year ? -1 : _.value === t.year ? getMonth(new Date(t.maxDate)) : null : null), Z = computed(() => t.range && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), Q = (p, P = false) => {
      const N = [];
      for (let pe = 0; pe < p.length; pe += 3) {
        const Ee = [p[pe], p[pe + 1], p[pe + 2]];
        N.push(P ? Ee.reverse() : Ee);
      }
      return P ? N.reverse() : N;
    }, j = computed(() => {
      const p = t.months.find((P) => P.value === t.month);
      return p || { text: "", value: 0 };
    }), D = computed(() => Q(t.months)), $ = computed(() => Q(t.years, t.reverseYears)), i = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === 0 : true), s = computed(() => t.multiCalendars ? t.multiCalendarsSolo ? true : t.instance === t.multiCalendars - 1 : true), w = (p = false) => {
      ee(p), y.value = !y.value, y.value || n("overlay-closed");
    }, E = (p = false) => {
      ee(p), h.value = !h.value, h.value || n("overlay-closed");
    }, ee = (p) => {
      p || n("reset-flow");
    }, I = (p = false) => {
      n("update-month-year", { year: p ? t.year + 1 : t.year - 1, month: t.month });
    }, re = (p, P) => {
      L != null && L.value && (M.value[P] = we(p), v(M.value, "monthYear"));
    };
    return a({
      toggleMonthPicker: w,
      toggleYearPicker: E
    }), (p, P) => (openBlock(), createElementBlock("div", Nr, [
      !p.monthPicker && !e.yearPicker ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        unref(i) && !p.vertical ? (openBlock(), createBlock(nn, {
          key: 0,
          "aria-label": unref(O).prevMonth,
          onActivate: P[0] || (P[0] = (N) => unref(T)(false)),
          onSetRef: P[1] || (P[1] = (N) => re(N, 0))
        }, {
          default: withCtx(() => [
            p.$slots["arrow-left"] ? renderSlot(p.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
            p.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Mn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label"])) : createCommentVNode("", true),
        createVNode(Bn, mergeProps({
          "aria-label": unref(O).openMonthsOverlay,
          "slot-name": "month-overlay",
          modelValue: unref(l),
          "onUpdate:modelValue": P[2] || (P[2] = (N) => isRef(l) ? l.value = N : null)
        }, unref(F)("month"), {
          onToggle: w,
          onSetRef: P[3] || (P[3] = (N) => re(N, 1))
        }), createSlots({
          default: withCtx(() => [
            p.$slots.month ? renderSlot(p.$slots, "month", normalizeProps(mergeProps({ key: 0 }, unref(j)))) : createCommentVNode("", true),
            p.$slots.month ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(unref(j).text), 1)
            ], 64))
          ]),
          _: 2
        }, [
          p.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: withCtx(() => [
              renderSlot(p.$slots, "calendar-icon")
            ])
          } : void 0,
          p.$slots["month-overlay"] ? {
            name: "month-overlay",
            fn: withCtx(({ item: N }) => [
              renderSlot(p.$slots, "month-overlay", {
                text: N.text,
                value: N.value
              })
            ])
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        createVNode(Bn, mergeProps({
          "aria-label": unref(O).openYearsOverlay,
          "slot-name": "year-overlay",
          modelValue: unref(o),
          "onUpdate:modelValue": P[4] || (P[4] = (N) => isRef(o) ? o.value = N : null)
        }, unref(F)("year"), {
          onToggle: E,
          onSetRef: P[5] || (P[5] = (N) => re(N, 2))
        }), createSlots({
          default: withCtx(() => [
            p.$slots.year ? renderSlot(p.$slots, "year", {
              key: 0,
              year: p.year
            }) : createCommentVNode("", true),
            p.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(p.year), 1)
            ], 64))
          ]),
          _: 2
        }, [
          p.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: withCtx(() => [
              renderSlot(p.$slots, "calendar-icon")
            ])
          } : void 0,
          p.$slots["year-overlay"] ? {
            name: "year-overlay",
            fn: withCtx(({ item: N }) => [
              renderSlot(p.$slots, "year-overlay", {
                text: N.text,
                value: N.value
              })
            ])
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        unref(i) && p.vertical ? (openBlock(), createBlock(nn, {
          key: 1,
          "aria-label": unref(O).prevMonth,
          onActivate: P[6] || (P[6] = (N) => unref(T)(false))
        }, {
          default: withCtx(() => [
            p.$slots["arrow-up"] ? renderSlot(p.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
            p.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Un), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label"])) : createCommentVNode("", true),
        unref(s) ? (openBlock(), createBlock(nn, {
          key: 2,
          "arial-label": unref(O).nextMonth,
          onActivate: P[7] || (P[7] = (N) => unref(T)(true)),
          ref: "rightIcon",
          onSetRef: P[8] || (P[8] = (N) => re(N, 3))
        }, {
          default: withCtx(() => [
            p.$slots[p.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(p.$slots, p.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
            p.$slots[p.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(p.vertical ? unref(Ln) : unref(Sn)), { key: 1 }))
          ]),
          _: 3
        }, 8, ["arial-label"])) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      p.monthPicker ? (openBlock(), createBlock(Dt, mergeProps({ key: 1 }, unref(F)("month"), {
        "skip-active": t.range,
        year: p.year,
        "multi-model-value": unref(Z),
        "month-picker": "",
        modelValue: unref(l),
        "onUpdate:modelValue": P[15] || (P[15] = (N) => isRef(l) ? l.value = N : null),
        onToggle: w,
        onSelected: P[16] || (P[16] = (N) => p.$emit("overlay-closed"))
      }), createSlots({
        header: withCtx(() => [
          createBaseVNode("div", Ir, [
            createBaseVNode("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpPrevIconRef",
              ref: R,
              onClick: P[9] || (P[9] = (N) => I(false)),
              onKeydown: P[10] || (P[10] = withKeys((N) => I(false), ["enter"]))
            }, [
              createBaseVNode("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": unref(O).prevMonth
              }, [
                p.$slots["arrow-left"] ? renderSlot(p.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                p.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Mn), { key: 1 }))
              ], 8, Yr)
            ], 544),
            createBaseVNode("div", {
              class: "dp__pointer",
              role: "button",
              ref_key: "mpYearButtonRef",
              ref: B,
              "aria-label": unref(O).openYearsOverlay,
              tabindex: "0",
              onClick: E,
              onKeydown: withKeys(E, ["enter"])
            }, [
              p.$slots.year ? renderSlot(p.$slots, "year", {
                key: 0,
                year: p.year
              }) : createCommentVNode("", true),
              p.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(p.year), 1)
              ], 64))
            ], 40, Er),
            createBaseVNode("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpNextIconRef",
              ref: Y,
              onClick: P[11] || (P[11] = (N) => I(true)),
              onKeydown: P[12] || (P[12] = withKeys((N) => I(true), ["enter"]))
            }, [
              createBaseVNode("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": unref(O).nextMonth
              }, [
                p.$slots["arrow-right"] ? renderSlot(p.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
                p.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Sn), { key: 1 }))
              ], 8, Fr)
            ], 544)
          ]),
          createVNode(Transition, {
            name: unref(c)(h.value),
            css: unref(m)
          }, {
            default: withCtx(() => [
              h.value ? (openBlock(), createBlock(Dt, mergeProps({ key: 0 }, unref(F)("year"), {
                modelValue: unref(o),
                "onUpdate:modelValue": P[13] || (P[13] = (N) => isRef(o) ? o.value = N : null),
                onToggle: E,
                onSelected: P[14] || (P[14] = (N) => p.$emit("overlay-closed"))
              }), createSlots({
                "button-icon": withCtx(() => [
                  p.$slots["calendar-icon"] ? renderSlot(p.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                  p.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ht), { key: 1 }))
                ]),
                _: 2
              }, [
                p.$slots["year-overlay"] ? {
                  name: "item",
                  fn: withCtx(({ item: N }) => [
                    renderSlot(p.$slots, "year-overlay", {
                      text: N.text,
                      value: N.value
                    })
                  ])
                } : void 0
              ]), 1040, ["modelValue"])) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 2
      }, [
        p.$slots["month-overlay"] ? {
          name: "item",
          fn: withCtx(({ item: N }) => [
            renderSlot(p.$slots, "month-overlay", {
              text: N.text,
              value: N.value
            })
          ])
        } : void 0
      ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : createCommentVNode("", true),
      e.yearPicker ? (openBlock(), createBlock(Dt, mergeProps({ key: 2 }, unref(F)("year"), {
        modelValue: unref(o),
        "onUpdate:modelValue": P[17] || (P[17] = (N) => isRef(o) ? o.value = N : null),
        "multi-model-value": unref(Z),
        "skip-active": t.range,
        "skip-button-ref": "",
        "year-picker": "",
        onToggle: E,
        onSelected: P[18] || (P[18] = (N) => p.$emit("overlay-closed"))
      }), createSlots({ _: 2 }, [
        p.$slots["year-overlay"] ? {
          name: "item",
          fn: withCtx(({ item: N }) => [
            renderSlot(p.$slots, "year-overlay", {
              text: N.text,
              value: N.value
            })
          ])
        } : void 0
      ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : createCommentVNode("", true)
    ]));
  }
});
var Hr = (e, a, n, t) => {
  const c = ref(new Date()), m = ref(), v = ref([{ month: getMonth(new Date()), year: getYear(new Date()) }]), y = ref(e.range ? [getHours(new Date()), getHours(new Date())] : getHours(new Date())), h = ref(e.range ? [getMinutes(new Date()), getMinutes(new Date())] : getMinutes(new Date())), M = ref(e.range ? [0, 0] : 0);
  watch(v, () => {
    setTimeout(() => {
      e.openOnTop && a("dpOpen");
    }, 0);
  }, { deep: true }), onMounted(() => {
    Q(true), l.value || (e.startDate && (v.value[0].month = getMonth(new Date(e.startDate)), v.value[0].year = getYear(new Date(e.startDate)), e.multiCalendars && N(0)), e.startTime && te());
  });
  const R = computed(() => (r) => v.value[r] ? v.value[r].month : 0), B = computed(() => (r) => v.value[r] ? v.value[r].year : 0), Y = (r, k, A) => {
    v.value[r].month = k, v.value[r].year = A;
  }, O = (r, k) => v.value[r].month = k, L = (r, k) => v.value[r].year = k, T = (r = true) => e.enableSeconds ? Array.isArray(M.value) ? r ? M.value[0] : M.value[1] : M.value : 0, te = () => {
    e.startTime && (ur(e.startTime) ? (y.value = [+e.startTime[0].hours, +e.startTime[1].hours], h.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (M.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (y.value = +e.startTime.hours, h.value = +e.startTime.minutes, e.enableSeconds && (M.value = +e.startTime.seconds)));
  }, l = computed({
    get: () => e.internalModelValue,
    set: (r) => {
      !e.readonly && !e.disabled && a("update:internalModelValue", r);
    }
  });
  watch(l, () => Q());
  const o = (r) => {
    const { validate: k } = Xn(e.minDate, e.maxDate, e.disabledDates, e.allowedDates, e.filters, e.disabledWeekDays, e.yearRange);
    return !k(r);
  }, F = (r) => !l.value || e.hideOffsetDates && !r.current ? false : e.range ? e.modelAuto && Array.isArray(l.value) ? ue(r.value, l.value[0] ? l.value[0] : c.value) : false : e.multiDates && Array.isArray(l.value) ? l.value.some((k) => ue(k, r.value)) : ue(r.value, l.value ? l.value : c.value), J = (r) => jn(l.value, m.value, r.value), _ = (r, k = false) => {
    if ((!e.multiCalendars || !e.multiStatic || k) && (O(0, getMonth(r)), L(0, getYear(r))), e.multiCalendars)
      for (let A = 1; A <= e.multiCalendars; A++) {
        const X = set(new Date(), { month: R.value(A - 1), year: B.value(A - 1) }), Me = add(X, { months: 1 });
        v.value[A] = { month: getMonth(Me), year: getYear(Me) };
      }
  }, U = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const r = new Date(l.value[1] ? l.value[1] : addMonths(l.value[0], 1)), [k, A] = [getMonth(l.value[0]), getYear(l.value[0])], [X, Me] = [getMonth(l.value[1]), getYear(l.value[1])];
      (k !== X || k === X && A !== Me) && e.multiCalendarsSolo && (O(1, getMonth(r)), L(1, getYear(r)));
    }
  }, z = (r) => {
    _(r), y.value = getHours(r), h.value = getMinutes(r), M.value = getSeconds(r);
  }, Z = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null, Q = (r = false) => {
    if (l.value)
      if (bt(l.value)) {
        if (l.value.length === 2 && !e.multiDates)
          _(l.value[0], r), y.value = [
            getHours(l.value[0]),
            l.value[1] ? getHours(l.value[1]) : getHours(new Date())
          ], h.value = [
            getMinutes(l.value[0]),
            l.value[1] ? getMinutes(l.value[1]) : getMinutes(new Date())
          ], M.value = [
            getSeconds(l.value[0]),
            l.value[1] ? getSeconds(l.value[1]) : getSeconds(new Date())
          ];
        else if (bt(l.value) && e.multiDates) {
          const k = l.value[l.value.length - 1];
          k && z(k);
        }
        e.multiCalendars && e.multiCalendarsSolo && U();
      } else
        z(l.value);
    else
      e.timePicker ? (te(), e.range ? _e(y.value) && _e(h.value) && (l.value = [
        Se(new Date(), y.value[0], h.value[0], T()),
        Se(new Date(), y.value[1], h.value[1], T(false))
      ]) : l.value = Se(new Date(), y.value, h.value, T())) : e.monthPicker && !e.range ? l.value = rt(new Date(), R.value(0), B.value(0)) : e.multiCalendars ? _(new Date()) : e.yearPicker && !e.range && (l.value = new Date());
  }, j = (r) => {
    const k = getMonth(new Date(r)), A = getYear(new Date(r));
    if (O(0, k), L(0, A), e.multiCalendars > 0)
      for (let X = 1; X < e.multiCalendars; X++) {
        const Me = Dl(set(new Date(r), { year: R.value(X - 1), month: B.value(X - 1) }));
        O(X, Me.month), L(X, Me.year);
      }
  }, D = (r) => {
    if (l.value && Array.isArray(l.value))
      if (l.value.some((k) => ue(r, k))) {
        const k = l.value.filter((A) => !ue(A, r));
        l.value = k.length ? k : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > l.value.length || !e.multiDatesLimit) && l.value.push(r);
    else
      l.value = [r];
  }, $ = (r) => {
    if (Array.isArray(l.value) && l.value[0]) {
      const k = differenceInCalendarDays(r, l.value[0]), A = De(l.value[0], r) ? r : l.value[0], X = De(r, l.value[0]) ? r : l.value[0], xe = eachDayOfInterval({ start: A, end: X }).filter((it) => o(it)).length, Te = Math.abs(k < 0 ? k + 1 : k - 1) - xe;
      if (e.minRange && e.maxRange)
        return Te >= +e.minRange && Te <= +e.maxRange;
      if (e.minRange)
        return Te >= +e.minRange;
      if (e.maxRange)
        return Te <= +e.maxRange;
    }
    return true;
  }, i = (r) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && (De(r, l.value[0]) || ue(r, l.value[0])) ? [l.value[0], r] : e.fixedEnd && (ke(r, l.value[1]) || ue(r, l.value[1])) ? [r, l.value[1]] : l.value : [], s = () => {
    e.autoApply && a("autoApply");
  }, w = (r) => !eachDayOfInterval({ start: r[0], end: r[1] }).some((A) => o(A)), E = (r, k = false) => {
    if (!o(r.value) && !(!r.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return l.value = Tt(new Date(r.value), +e.weekStart), s();
      if (!e.range && !_e(y.value) && !_e(h.value)) {
        const A = Se(new Date(r.value), y.value, h.value, T());
        e.multiDates ? D(A) : l.value = A, n(), s();
      } else if (_e(y.value) && _e(h.value) && !e.multiDates) {
        let A = l.value ? l.value.slice() : [];
        if (A.length === 2 && !(e.fixedStart || e.fixedEnd) && (A = []), e.autoRange) {
          const X = [new Date(r.value), addDays(new Date(r.value), +e.autoRange)];
          w(X) && (k && j(r.value), A = X);
        } else
          e.fixedStart || e.fixedEnd ? A = i(new Date(r.value)) : A[0] ? $(new Date(r.value)) && (ke(new Date(r.value), new Date(A[0])) ? A.unshift(new Date(r.value)) : A[1] = new Date(r.value)) : A[0] = new Date(r.value);
        A.length && (A[0] && !A[1] ? A[0] = Se(A[0], y.value[0], h.value[0], T()) : (A[0] = Se(A[0], y.value[0], h.value[0], T()), A[1] = Se(A[1], y.value[1], h.value[1], T(false)), n()), l.value = A, A[0] && A[1] && e.autoApply && a("autoApply"));
      }
    }
  }, ee = (r) => {
    const k = r.find((A) => A.current);
    return k ? getISOWeek(k.value) : "";
  }, I = (r) => {
    !r.current && e.hideOffsetDates || (m.value = r.value);
  }, re = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return false;
        const k = addDays(m.value, +e.autoRange), A = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ue(A[1], new Date(r.value)) : ue(k, new Date(r.value));
      }
      return false;
    }
    return false;
  }, p = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        const k = addDays(m.value, +e.autoRange);
        if (e.hideOffsetDates && !r.current)
          return false;
        const A = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? De(r.value, A[0]) && ke(r.value, A[1]) : De(r.value, m.value) && ke(r.value, k);
      }
      return false;
    }
    return false;
  }, P = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return false;
        const k = Tt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ue(k[0], r.value) : ue(m.value, r.value);
      }
      return false;
    }
    return false;
  }, N = (r) => {
    for (let k = r - 1; k >= 0; k--) {
      const A = subMonths(set(new Date(), { month: R.value(k + 1), year: B.value(k + 1) }), 1);
      Y(k, getMonth(A), getYear(A));
    }
    for (let k = r + 1; k <= e.multiCalendars - 1; k++) {
      const A = addMonths(set(new Date(), { month: R.value(k - 1), year: B.value(k - 1) }), 1);
      Y(k, getMonth(A), getYear(A));
    }
  }, pe = (r) => rt(new Date(), R.value(r), B.value(r)), Ee = (r, k) => {
    const A = e.monthPicker ? R.value(r) !== k.month : B.value(r) !== k.year;
    if (O(r, k.month), L(r, k.year), e.multiCalendars && !e.multiCalendarsSolo && N(r), e.monthPicker || e.yearPicker)
      if (e.range) {
        if (A) {
          let X = l.value ? l.value.slice() : [];
          X.length === 2 && X[1] !== null && (X = []), X.length ? ke(pe(r), X[0]) ? X.unshift(pe(r)) : X[1] = pe(r) : X = [pe(r)], l.value = X;
        }
      } else
        l.value = pe(r);
    n(), a("updateMonthYear", { instance: r, month: k.month, year: k.year }), At(e.multiCalendarsSolo ? r : void 0);
  }, Je = (r) => Se(r, y.value, h.value, T()), Ne = (r) => {
    bt(r) && bt(l.value) && _e(y.value) && _e(h.value) ? (r[0] && l.value[0] && (l.value[0] = Se(r[0], y.value[0], h.value[0], T())), r[1] && l.value[1] && (l.value[1] = Se(r[1], y.value[1], h.value[1], T(false)))) : e.multiDates && Array.isArray(l.value) ? l.value[l.value.length - 1] = Je(r) : !e.range && !It(r) && (l.value = Je(r)), a("timeUpdate");
  }, Ke = (r, k = true, A = false) => {
    const X = k ? r : y.value, Me = !k && !A ? r : h.value, xe = A ? r : M.value;
    if (e.range && It(l.value) && _e(X) && _e(Me) && _e(xe) && !e.disableTimeRangeValidation) {
      const Te = (We) => Se(l.value[We], X[We], Me[We], xe[We]), it = (We) => setMilliseconds(l.value[We], 0);
      if (ue(l.value[0], l.value[1]) && (isAfter(Te(0), it(1)) || isBefore(Te(1), it(0))))
        return;
    }
    if (y.value = X, h.value = Me, M.value = xe, l.value)
      if (e.multiDates) {
        const Te = Z();
        Te && Ne(Te);
      } else
        Ne(l.value);
    else
      e.timePicker && Ne(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, He = () => {
    m.value = null;
  }, Ze = (r) => Rn(l.value, e.range) && l.value[0] && m.value ? r ? De(m.value, l.value[0]) : ke(m.value, l.value[0]) : true, be = (r, k = true) => (e.range || e.weekPicker) && It(l.value) ? e.hideOffsetDates && !r.current ? false : ue(new Date(r.value), l.value[k ? 0 : 1]) : e.range ? ue(new Date(r.value), l.value && Array.isArray(l.value) ? k ? l.value[0] || null : l.value[1] : null) && (k ? !ke(m.value || null, Array.isArray(l.value) ? l.value[0] : null) : true) || ue(r.value, Array.isArray(l.value) ? l.value[0] : null) && Ze(k) : false, ot = (r, k) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? false : !r && !F(k) && !(!k.current && e.hideOffsetDates) && (e.range ? !be(k) && !be(k, false) : true), pt = (r, k, A) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? r ? false : A ? De(e.internalModelValue[0], k.value) : ke(e.internalModelValue[0], k.value) : false, ht = (r = false) => {
    e.autoApply && (e.monthPicker || e.yearPicker) && nextTick().then(() => {
      e.range ? a("autoApply", r || !l.value || l.value.length === 1) : a("autoApply", r);
    });
  }, f = (r, k) => {
    const A = set(new Date(), { month: R.value(k), year: B.value(k) }), X = r < 0 ? addMonths(A, 1) : subMonths(A, 1);
    oa(e.minDate, e.maxDate, getMonth(X), getYear(X), r < 0, e.preventMinMaxNavigation) && (Y(k, getMonth(X), getYear(X)), e.multiCalendars && !e.multiCalendarsSolo && N(k), At());
  }, ne = (r, k) => {
    e.monthChangeOnScroll && f(e.monthChangeOnScroll !== "inverse" ? -r.deltaY : r.deltaY, k);
  }, ce = (r, k, A = false) => {
    e.monthChangeOnArrows && e.vertical === A && ut(r, k);
  }, ut = (r, k) => {
    f(r === "right" ? -1 : 1, k);
  }, Qe = (r) => e.markers.find((k) => ue(Ie(r.value), Ie(k.date))), Lt = () => {
    e.range ? Rn(l.value, e.range) && (l.value && l.value[0] ? l.value = ke(new Date(), l.value[0]) ? [new Date(), l.value[0]] : [l.value[0], new Date()] : l.value = [new Date()]) : a("update:internalModelValue", new Date()), e.autoApply && a("selectDate");
  }, Gt = (r) => {
    r.length && r.length <= 2 && e.range && (l.value = r.map((k) => new Date(k)), e.autoApply && a("selectDate"));
  }, At = (r) => {
    r || r === 0 ? t.value[r].triggerTransition(R.value(r), B.value(r)) : t.value.forEach((k, A) => k.triggerTransition(R.value(A), B.value(A)));
  };
  return {
    today: c,
    hours: y,
    minutes: h,
    seconds: M,
    month: R,
    year: B,
    monthYearSelect: ht,
    isDisabled: o,
    updateTime: Ke,
    setHoverDate: I,
    getWeekNum: ee,
    selectDate: E,
    rangeActive: J,
    isActiveDate: F,
    updateMonthYear: Ee,
    isHoverRangeEnd: re,
    isAutoRangeInBetween: p,
    isAutoRangeStart: P,
    clearHoverDate: He,
    rangeActiveStartEnd: be,
    handleScroll: ne,
    getMarker: Qe,
    handleArrow: ce,
    handleSwipe: ut,
    selectCurrentDate: Lt,
    isHoverDate: ot,
    isHoverDateStartEnd: pt,
    presetDateRange: Gt
  };
};
var Rt = reactive({
  menuFocused: false,
  shiftKeyInMenu: false
});
var ua = () => ({
  setMenuFocused: (t) => {
    Rt.menuFocused = t;
  },
  getStore: () => Rt,
  setShiftKey: (t) => {
    Rt.shiftKeyInMenu !== t && (Rt.shiftKeyInMenu = t);
  }
});
var Wr = ["id", "aria-label", "onKeydown"];
var Ur = {
  key: 0,
  class: "dp__preset_ranges"
};
var Lr = ["onClick"];
var Gr = {
  key: 1,
  class: "dp__now_wrap"
};
var jr = defineComponent({
  __name: "DatepickerMenu",
  props: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, aa), pn), yn), {
    internalModelValue: { type: [Date, Array], default: null },
    multiCalendars: { type: Number, default: 0 },
    openOnTop: { type: Boolean, default: false }
  }),
  emits: [
    "update:internalModelValue",
    "closePicker",
    "selectDate",
    "dpOpen",
    "autoApply",
    "timeUpdate",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { emit: a }) {
    const n = e, t = useSlots(), c = ref(null), m = reactive({
      timePicker: !!(!n.enableTimePicker || n.timePicker || n.monthPicker),
      monthYearInput: !!n.timePicker,
      calendar: false
    }), v = ref([]), y = ref([]), h = ref(null), M = ref(null), R = ref(0), B = ref(false), Y = ref(0), O = inject(Wt), L = inject(ze), T = inject(Xe), { setMenuFocused: te, setShiftKey: l, getStore: o } = ua();
    onMounted(() => {
      var G;
      B.value = true, (G = n.presetRanges) != null && G.length || X();
      const d = we(M);
      if (d && !n.textInput && !n.inline && (te(true), z()), d) {
        const H = (q) => {
          !n.monthYearComponent && !n.timePickerComponent && q.preventDefault(), q.stopImmediatePropagation(), q.stopPropagation();
        };
        d.addEventListener("pointerdown", H), d.addEventListener("mousedown", H);
      }
      document.addEventListener("resize", X);
    }), onUnmounted(() => {
      document.removeEventListener("resize", X);
    });
    const { arrowRight: F, arrowLeft: J, arrowDown: _, arrowUp: U } = qe(), z = () => {
      const d = we(M);
      d && d.focus({ preventScroll: true });
    }, Z = () => {
      var d;
      ((d = n.flow) == null ? void 0 : d.length) && Y.value !== -1 && (Y.value += 1, a("flow-step", Y.value), wn());
    }, Q = () => {
      Y.value = -1;
    }, {
      updateTime: j,
      updateMonthYear: D,
      today: $,
      month: i,
      year: s,
      hours: w,
      minutes: E,
      seconds: ee,
      isDisabled: I,
      isActiveDate: re,
      selectDate: p,
      getWeekNum: P,
      setHoverDate: N,
      isHoverRangeEnd: pe,
      isAutoRangeInBetween: Ee,
      isAutoRangeStart: Je,
      rangeActive: Ne,
      clearHoverDate: Ke,
      rangeActiveStartEnd: He,
      monthYearSelect: Ze,
      handleScroll: be,
      handleArrow: ot,
      handleSwipe: pt,
      getMarker: ht,
      selectCurrentDate: f,
      isHoverDateStartEnd: ne,
      isHoverDate: ce,
      presetDateRange: ut
    } = Hr(n, a, Z, y), Qe = at(t, "calendar"), Lt = at(t, "action"), Gt = at(t, "timePicker"), At = at(t, "monthYear"), r = computed(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), k = computed(() => Fl(n.yearRange)), A = computed(() => Kl(n.locale, n.monthNameFormat)), X = () => {
      const d = we(c);
      d && (R.value = d.getBoundingClientRect().width);
    }, Me = computed(() => (d) => Il(i.value(d), s.value(d), +n.weekStart, n.hideOffsetDates)), xe = computed(() => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]), Te = computed(() => (d) => d === 1), it = computed(() => n.monthPicker || n.timePicker || n.yearPicker), We = computed(() => ({
      dp__flex_display: n.multiCalendars > 0
    })), da = computed(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    })), ca = computed(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly
    })), fa = computed(() => (d) => pa(Me, d)), ma = computed(() => ({
      locale: n.locale,
      weekNumName: n.weekNumName,
      weekStart: n.weekStart,
      weekNumbers: n.weekNumbers,
      customProps: n.customProps,
      calendarClassName: n.calendarClassName,
      specificMode: it.value,
      getWeekNum: P,
      multiCalendars: n.multiCalendars,
      modeHeight: n.modeHeight,
      internalModelValue: n.internalModelValue,
      noSwipe: n.noSwipe,
      vertical: n.vertical,
      dayNames: n.dayNames,
      monthChangeOnScroll: n.monthChangeOnScroll
    })), va = computed(() => ({
      dp__menu: true,
      dp__menu_index: !n.inline,
      dp__relative: n.inline,
      [n.menuClassName]: !!n.menuClassName
    })), ya = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : false, gt = () => n.modelAuto ? sa(n.internalModelValue) : true, pa = (d, G) => d.value(G).map((H) => __spreadProps(__spreadValues({}, H), {
      days: H.days.map((q) => {
        const x = I(q.value), wt = ce(x, q), et = n.range ? n.modelAuto ? ya() && re(q) : false : re(q), kn = n.highlight ? zn(q.value, n.highlight) : false, bn = (n.range || n.weekPicker) && (n.multiCalendars > 0 ? q.current : true) && !x && gt() && !(!q.current && n.hideOffsetDates) && !re(q) ? Ne(q) : false;
        return q.marker = ht(q), q.classData = {
          dp__cell_offset: !q.current,
          dp__pointer: !x && !(!q.current && n.hideOffsetDates),
          dp__active_date: et,
          dp__date_hover: wt,
          dp__date_hover_start: ne(wt, q, true),
          dp__date_hover_end: ne(wt, q, false),
          dp__range_between: bn && !n.weekPicker,
          dp__range_between_week: bn && n.weekPicker,
          dp__today: !n.noToday && ue(q.value, $.value) && q.current,
          dp__cell_disabled: x,
          dp__cell_auto_range: Ee(q),
          dp__cell_auto_range_start: Je(q),
          dp__cell_auto_range_end: pe(q),
          dp__range_start: n.multiCalendars > 0 ? q.current && He(q) && gt() : He(q) && gt(),
          dp__range_end: n.multiCalendars > 0 ? q.current && He(q, false) && gt() : He(q, false) && gt(),
          [n.calendarCellClassName]: !!n.calendarCellClassName,
          dp__cell_highlight: kn && !et,
          dp__cell_highlight_active: kn && et
        }, q;
      })
    })), ha = (d) => {
      d.stopPropagation(), d.preventDefault(), d.stopImmediatePropagation();
    }, ga = () => {
      n.escClose && a("closePicker");
    }, wa = (d) => {
      d.stopImmediatePropagation(), d.preventDefault(), n.spaceConfirm && a("selectDate");
    }, jt = (d) => {
      var G;
      (G = n.flow) != null && G.length && (m[d] = true, Object.keys(m).filter((H) => !m[H]).length || wn());
    }, wn = () => {
      n.flow[Y.value] === "month" && v.value[0] && v.value[0].toggleMonthPicker(true), n.flow[Y.value] === "year" && v.value && v.value[0].toggleYearPicker(true), n.flow[Y.value] === "calendar" && h.value && h.value.toggleTimePicker(false, true), n.flow[Y.value] === "time" && h.value && h.value.toggleTimePicker(true, true);
      const d = n.flow[Y.value];
      (d === "hours" || d === "minutes" || d === "seconds") && h.value && h.value.toggleTimePicker(true, true, d);
    }, Pt = (d) => {
      if (T != null && T.value) {
        if (d === "up")
          return U();
        if (d === "down")
          return _();
        if (d === "left")
          return J();
        if (d === "right")
          return F();
      } else
        d === "left" || d === "up" ? ot("left", 0, d === "up") : ot("right", 0, d === "down");
    }, ka = (d) => {
      l(d.shiftKey), !n.disableMonthYearSelect && d.code === "Tab" && d.target.classList.contains("dp__menu") && o().shiftKeyInMenu && (d.preventDefault(), d.stopImmediatePropagation(), a("closePicker"));
    };
    return (d, G) => (openBlock(), createBlock(Transition, {
      appear: "",
      name: unref(O).menuAppear,
      mode: "out-in",
      css: !!unref(O)
    }, {
      default: withCtx(() => [
        createBaseVNode("div", {
          id: d.uid ? `dp-menu-${d.uid}` : void 0,
          tabindex: "0",
          ref_key: "dpMenuRef",
          ref: M,
          role: "dialog",
          "aria-label": unref(L).menu,
          class: normalizeClass(unref(va)),
          onMouseleave: G[12] || (G[12] = (...H) => unref(Ke) && unref(Ke)(...H)),
          onClick: ha,
          onKeydown: [
            withKeys(ga, ["esc"]),
            withKeys(wa, ["space"]),
            G[13] || (G[13] = withKeys(withModifiers((H) => Pt("left"), ["prevent"]), ["left"])),
            G[14] || (G[14] = withKeys(withModifiers((H) => Pt("up"), ["prevent"]), ["up"])),
            G[15] || (G[15] = withKeys(withModifiers((H) => Pt("down"), ["prevent"]), ["down"])),
            G[16] || (G[16] = withKeys(withModifiers((H) => Pt("right"), ["prevent"]), ["right"])),
            ka
          ]
        }, [
          (d.disabled || d.readonly) && d.inline ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(ca))
          }, null, 2)) : createCommentVNode("", true),
          !d.inline && !d.teleportCenter ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(r))
          }, null, 2)) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(d.presetRanges.length ? "dp__menu_content_wrapper" : null)
          }, [
            d.presetRanges.length ? (openBlock(), createElementBlock("div", Ur, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(d.presetRanges, (H, q) => (openBlock(), createElementBlock("div", {
                key: q,
                style: normalizeStyle(H.style || {}),
                class: "dp__preset_range",
                onClick: (x) => unref(ut)(H.range)
              }, toDisplayString(H.label), 13, Lr))), 128))
            ])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "dp__instance_calendar",
              ref_key: "calendarWrapperRef",
              ref: c,
              role: "document"
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(We))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(xe), (H, q) => (openBlock(), createElementBlock("div", {
                  key: H,
                  class: normalizeClass(unref(da))
                }, [
                  !d.disableMonthYearSelect && !d.timePicker ? (openBlock(), createBlock(resolveDynamicComponent(d.monthYearComponent ? d.monthYearComponent : Kr), mergeProps({
                    key: 0,
                    ref_for: true,
                    ref: (x) => {
                      x && (v.value[q] = x);
                    }
                  }, {
                    months: unref(A),
                    years: unref(k),
                    filters: d.filters,
                    monthPicker: d.monthPicker,
                    month: unref(i)(H),
                    year: unref(s)(H),
                    customProps: d.customProps,
                    multiCalendars: e.multiCalendars,
                    multiCalendarsSolo: d.multiCalendarsSolo,
                    instance: H,
                    minDate: d.minDate,
                    maxDate: d.maxDate,
                    preventMinMaxNavigation: d.preventMinMaxNavigation,
                    internalModelValue: e.internalModelValue,
                    range: d.range,
                    reverseYears: d.reverseYears,
                    vertical: d.vertical,
                    yearPicker: d.yearPicker
                  }, {
                    onMount: G[0] || (G[0] = (x) => jt("monthYearInput")),
                    onResetFlow: Q,
                    onUpdateMonthYear: (x) => unref(D)(H, x),
                    onMonthYearSelect: unref(Ze),
                    onOverlayClosed: z
                  }), createSlots({ _: 2 }, [
                    renderList(unref(At), (x, wt) => ({
                      name: x,
                      fn: withCtx((et) => [
                        renderSlot(d.$slots, x, normalizeProps(guardReactiveProps(et)))
                      ])
                    }))
                  ]), 1040, ["onUpdateMonthYear", "onMonthYearSelect"])) : createCommentVNode("", true),
                  createVNode(nr, mergeProps({
                    ref_for: true,
                    ref: (x) => {
                      x && (y.value[q] = x);
                    }
                  }, unref(ma), {
                    "flow-step": Y.value,
                    "onUpdate:flow-step": G[1] || (G[1] = (x) => Y.value = x),
                    instance: H,
                    "mapped-dates": unref(fa)(H),
                    month: unref(i)(H),
                    year: unref(s)(H),
                    onSelectDate: (x) => unref(p)(x, !unref(Te)(H)),
                    onSetHoverDate: G[2] || (G[2] = (x) => unref(N)(x)),
                    onHandleScroll: (x) => unref(be)(x, H),
                    onHandleSwipe: (x) => unref(pt)(x, H),
                    onMount: G[3] || (G[3] = (x) => jt("calendar")),
                    onResetFlow: Q
                  }), createSlots({ _: 2 }, [
                    renderList(unref(Qe), (x, wt) => ({
                      name: x,
                      fn: withCtx((et) => [
                        renderSlot(d.$slots, x, normalizeProps(guardReactiveProps(__spreadValues({}, et))))
                      ])
                    }))
                  ]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleScroll", "onHandleSwipe"])
                ], 2))), 128))
              ], 2),
              createBaseVNode("div", null, [
                d.enableTimePicker && !d.monthPicker && !d.weekPicker ? (openBlock(), createBlock(resolveDynamicComponent(d.timePickerComponent ? d.timePickerComponent : Rr), mergeProps({
                  key: 0,
                  ref_key: "timePickerRef",
                  ref: h
                }, {
                  is24: d.is24,
                  hoursIncrement: d.hoursIncrement,
                  minutesIncrement: d.minutesIncrement,
                  hoursGridIncrement: d.hoursGridIncrement,
                  secondsIncrement: d.secondsIncrement,
                  minutesGridIncrement: d.minutesGridIncrement,
                  secondsGridIncrement: d.secondsGridIncrement,
                  noHoursOverlay: d.noHoursOverlay,
                  noMinutesOverlay: d.noMinutesOverlay,
                  noSecondsOverlay: d.noSecondsOverlay,
                  range: d.range,
                  filters: d.filters,
                  timePicker: d.timePicker,
                  hours: unref(w),
                  minutes: unref(E),
                  seconds: unref(ee),
                  customProps: d.customProps,
                  enableSeconds: d.enableSeconds,
                  fixedStart: d.fixedStart,
                  fixedEnd: d.fixedEnd,
                  modelAuto: d.modelAuto,
                  internalModelValue: e.internalModelValue
                }, {
                  onMount: G[4] || (G[4] = (H) => jt("timePicker")),
                  "onUpdate:hours": G[5] || (G[5] = (H) => unref(j)(H)),
                  "onUpdate:minutes": G[6] || (G[6] = (H) => unref(j)(H, false)),
                  "onUpdate:seconds": G[7] || (G[7] = (H) => unref(j)(H, false, true)),
                  onResetFlow: Q,
                  onOverlayClosed: z
                }), createSlots({ _: 2 }, [
                  renderList(unref(Gt), (H, q) => ({
                    name: H,
                    fn: withCtx((x) => [
                      renderSlot(d.$slots, H, normalizeProps(guardReactiveProps(x)))
                    ])
                  }))
                ]), 1040)) : createCommentVNode("", true)
              ])
            ], 512),
            d.showNowButton ? (openBlock(), createElementBlock("div", Gr, [
              d.$slots["now-button"] ? renderSlot(d.$slots, "now-button", {
                key: 0,
                selectCurrentDate: unref(f)
              }) : createCommentVNode("", true),
              d.$slots["now-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                role: "button",
                class: "dp__now_button",
                onClick: G[8] || (G[8] = (...H) => unref(f) && unref(f)(...H))
              }, toDisplayString(d.nowButtonLabel), 1))
            ])) : createCommentVNode("", true)
          ], 2),
          !d.autoApply || d.keepActionRow ? (openBlock(), createBlock(resolveDynamicComponent(d.actionRowComponent ? d.actionRowComponent : mr), mergeProps({ key: 2 }, {
            calendarWidth: R.value,
            selectText: d.selectText,
            cancelText: d.cancelText,
            internalModelValue: e.internalModelValue,
            range: d.range,
            previewFormat: d.previewFormat,
            inline: d.inline,
            monthPicker: d.monthPicker,
            timePicker: d.timePicker,
            customProps: d.customProps,
            multiCalendars: e.multiCalendars,
            menuMount: B.value,
            maxTime: d.maxTime,
            minTime: d.minTime,
            enableTimePicker: d.enableTimePicker,
            minDate: d.minDate,
            maxDate: d.maxDate,
            multiDates: d.multiDates,
            modelAuto: d.modelAuto,
            partialRange: d.partialRange
          }, {
            onClosePicker: G[9] || (G[9] = (H) => d.$emit("closePicker")),
            onSelectDate: G[10] || (G[10] = (H) => d.$emit("selectDate")),
            onInvalidSelect: G[11] || (G[11] = (H) => d.$emit("invalid-select"))
          }), createSlots({ _: 2 }, [
            renderList(unref(Lt), (H, q) => ({
              name: H,
              fn: withCtx((x) => [
                renderSlot(d.$slots, H, normalizeProps(guardReactiveProps(__spreadValues({}, x))))
              ])
            }))
          ]), 1040)) : createCommentVNode("", true)
        ], 42, Wr)
      ]),
      _: 3
    }, 8, ["name", "css"]));
  }
});
var Yt = ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Yt || {});
var zr = (e, a, n, t, c, m, v, y, h) => {
  const M = ref({
    top: "0",
    left: "0",
    transform: "none"
  }), R = ref(false), B = 390, Y = (_) => {
    const U = _.getBoundingClientRect();
    return {
      left: U.left + window.scrollX,
      top: U.top + window.scrollY
    };
  }, O = (_) => {
    const U = _.getBoundingClientRect();
    let z = 0, Z = 0;
    for (; _ && !isNaN(_.offsetLeft) && !isNaN(_.offsetTop); )
      z += _.offsetLeft - _.scrollLeft, Z = U.top + _.scrollTop, _ = _.offsetParent;
    return { top: Z, left: z };
  }, L = (_, U) => {
    M.value.left = `${_ + U}px`, M.value.transform = "translateX(-100%)";
  }, T = (_) => {
    M.value.left = `${_}px`, M.value.transform = "translateX(0)";
  }, te = (_, U) => {
    e === Yt.left && T(_), e === Yt.right && L(_, U), e === Yt.center && (M.value.left = `${_ + U / 2}px`, M.value.transform = "translateX(-50%)");
  }, l = () => {
    const _ = we(c);
    if (_) {
      const U = window.innerHeight, { top: z } = a ? O(_) : Y(_), { left: Z, width: Q, top: j, height: D } = _.getBoundingClientRect(), $ = U - j - D;
      M.value.top = j > $ ? `${z - B}px` : `${z}px`, te(Z, Q);
    }
  }, o = () => {
    M.value.left = "50%", M.value.top = "50%", M.value.transform = "translate(-50%, -50%)", M.value.position = "fixed";
  }, F = (_ = true) => {
    if (!m) {
      if (y.value)
        return o();
      const U = we(c);
      if (a && typeof a != "boolean")
        M.value = a(U);
      else if (U) {
        const { left: z, width: Z, height: Q } = U.getBoundingClientRect(), { top: j } = a ? O(U) : Y(U);
        M.value.top = `${Q + j + +v}px`, te(z, Z), _ && n && J();
      }
    }
  }, J = () => {
    const _ = we(c);
    if (_ && n && !m) {
      const { height: U, top: z, left: Z, width: Q } = _.getBoundingClientRect(), { top: j } = a ? O(_) : Y(_), $ = window.innerHeight - z - U, i = we(t);
      if (i) {
        const { height: s, left: w, right: E } = i.getBoundingClientRect(), ee = s + U;
        ee > z && ee > $ ? z < $ ? (F(false), R.value = false) : (M.value.top = `${j - s - +v}px`, R.value = true) : ee > $ ? (M.value.top = `${j - s - +v}px`, R.value = true) : (F(false), R.value = false), w < 0 ? T(Z) : E > document.documentElement.clientWidth && L(Z, Q);
      }
    }
    h("recalculatePosition");
  };
  return { openOnTop: R, menuPosition: M, setMenuPosition: F, setInitialPosition: l, recalculatePosition: J };
};
var Xr = (e, a, n, t, c, m, v, y, h, M, R, B, Y, O, L, T, te) => {
  const l = ref(""), o = ref();
  watch(o, () => {
    te("internalModelChange", o.value);
  });
  const F = (i) => [Z(i[0]), i[1] ? Z(i[1]) : null], J = (i) => {
    let s = null;
    i ? a ? lr(i) && "hours" in i[0] && "minutes" in i[0] ? s = [
      Se(null, +i[0].hours, +i[0].minutes, +i[0].seconds),
      Se(null, +i[1].hours, +i[1].minutes, +i[1].seconds)
    ] : ar(i) && (s = Se(null, +i.hours, +i.minutes, +i.seconds)) : n ? rr(i) && "month" in i[0] && "year" in i[0] ? (s = [rt(null, +i[0].month, +i[0].year)], i[1] ? s[1] = rt(null, +i[1].month, +i[1].year) : !i[1] && c && (s[1] = null)) : sr(i) && "month" in i && "year" in i && (s = rt(null, +i.month, +i.year)) : Y ? Array.isArray(i) ? s = [
      setYear(new Date(), i[0]),
      !i[1] && c ? null : setYear(new Date(), i[1])
    ] : s = setYear(new Date(), i) : M && Array.isArray(i) ? s = i.map((w) => Z(w)) : B && Array.isArray(i) ? s = [new Date(i[0]), new Date(i[1])] : t ? T ? Array.isArray(i) ? s = F(i) : s = [Z(i), null] : or(i, c) && (s = F(i)) : ir(i) && (s = Z(i)) : s = null, rn(s) ? (o.value = s, U()) : (o.value = null, l.value = "");
  }, _ = () => Gn(e, m, y, n, a, B, Y, v), U = () => {
    if (!o.value)
      l.value = "";
    else if (!e || typeof e == "string") {
      const i = _();
      Array.isArray(o.value) && M ? l.value = o.value.map((s) => mt(s, i, h == null ? void 0 : h.value)).join("; ") : l.value = mt(o.value, i, h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator, T);
    } else
      a ? l.value = e(sn(o.value)) : n ? l.value = e(Cn(o.value)) : l.value = e(o.value);
  }, z = () => o.value ? t ? c ? o.value.length >= 1 : o.value.length === 2 : !!o.value : false, Z = (i) => {
    if (R) {
      const s = new Date(i);
      return R === "preserve" ? new Date(s.getTime() + s.getTimezoneOffset() * 6e4) : s;
    }
    return L ? L === "date" || L === "timestamp" ? new Date(i) : L === "format" && (typeof e == "string" || !e) ? parse(i, _(), new Date()) : parse(i, L, new Date()) : new Date(i);
  }, Q = (i) => L ? L === "timestamp" ? +i : L === "format" && (typeof e == "string" || !e) ? mt(i, _(), h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator) : mt(i, L, h == null ? void 0 : h.value, O == null ? void 0 : O.rangeSeparator) : i, j = (i) => {
    te("update:modelValue", i);
  }, D = () => [
    Q(o.value[0]),
    o.value[1] ? Q(o.value[1]) : null
  ];
  return {
    parseExternalModelValue: J,
    formatInputValue: U,
    internalModelValue: o,
    inputValue: l,
    emitModelValue: () => {
      if (n)
        j(Cn(o.value));
      else if (a)
        j(sn(o.value));
      else if (B)
        j(o.value);
      else if (Y)
        j(Array.isArray(o.value) ? [
          getYear(o.value[0]),
          o.value[1] ? getYear(o.value[1]) : null
        ] : getYear(o.value));
      else {
        if (o.value && t && c && o.value.length === 1 && o.value.push(null), R) {
          let i;
          if (Array.isArray(o.value)) {
            const s = (w) => w && Zt(w, R === "preserve");
            T ? i = o.value[1] ? o.value.map(s) : Zt(o.value[0], R === "preserve") : i = o.value.map(s);
          } else
            i = Zt(o.value, R === "preserve");
          return j(i);
        }
        Array.isArray(o.value) && !M ? j(T ? o.value[1] ? D() : Q(o.value[0]) : D()) : Array.isArray(o.value) && M ? j(o.value.map((i) => Q(i))) : j(Q(o.value));
      }
      U();
    },
    checkBeforeEmit: z
  };
};
var qr = typeof window < "u" ? window : void 0;
var an = () => {
};
var Jr = (e) => getCurrentScope() ? (onScopeDispose(e), true) : false;
var Zr = (e, a, n, t) => {
  if (!e)
    return an;
  let c = an;
  const m = watch(() => unref(e), (y) => {
    c(), y && (y.addEventListener(a, n, t), c = () => {
      y.removeEventListener(a, n, t), c = an;
    });
  }, { immediate: true, flush: "post" }), v = () => {
    m(), c();
  };
  return Jr(v), v;
};
var Qr = (e, a, n, t = {}) => {
  const { window: c = qr, event: m = "pointerdown" } = t;
  return c ? Zr(c, m, (y) => {
    const h = we(e), M = we(a);
    !h || !M || h === y.target || y.composedPath().includes(h) || y.composedPath().includes(M) || n(y);
  }, { passive: true }) : void 0;
};
var xr = defineComponent({
  __name: "VueDatePicker",
  props: __spreadValues({}, Cl),
  emits: [
    "update:modelValue",
    "textSubmit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internalModelChange",
    "recalculatePosition",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, c = useSlots(), m = ref(false), v = toRef(t, "modelValue"), y = ref(null), h = ref(null), M = toRef(t, "teleportCenter");
    provide(vn, t.autoApply);
    const R = computed(() => t.formatLocale);
    provide(Jn, R), provide(qn, toRef(t, "textInput")), provide(Xe, toRef(t, "arrowNavigation")), onMounted(() => {
      J(t.modelValue), t.inline || (window.addEventListener("scroll", P), window.addEventListener("resize", N)), t.inline && (m.value = true);
    }), onUnmounted(() => {
      t.inline || (window.removeEventListener("scroll", P), window.removeEventListener("resize", N));
    });
    const B = at(c, "all"), Y = at(c, "input");
    watch(v, () => {
      J(v.value);
    }, { deep: true });
    const { openOnTop: O, menuPosition: L, setMenuPosition: T, recalculatePosition: te, setInitialPosition: l } = zr(t.position, t.altPosition, t.autoPosition, y, h, t.inline, t.offset, M, n), {
      internalModelValue: o,
      inputValue: F,
      parseExternalModelValue: J,
      emitModelValue: _,
      checkBeforeEmit: U,
      formatInputValue: z
    } = Xr(t.format, t.timePicker, t.monthPicker, t.range, t.partialRange, t.is24, t.enableTimePicker, t.enableSeconds, R, t.multiDates, t.utc, t.weekPicker, t.yearPicker, t.textInputOptions, t.modelType, t.modelAuto, n), { clearArrowNav: Z } = qe(), { setMenuFocused: Q, setShiftKey: j } = ua(), D = computed(() => ({
      dp__main: true,
      dp__theme_dark: t.dark,
      dp__theme_light: !t.dark,
      dp__flex_display: t.inline,
      dp__flex_display_with_input: t.inlineWithInput
    })), $ = computed(() => Vn(t.format) ? t.format : Gn(null, t.is24, t.enableSeconds, t.monthPicker, t.timePicker, t.weekPicker, t.yearPicker, t.enableTimePicker)), i = computed(() => t.previewFormat ? t.previewFormat : Vn($.value) ? $.value : t.format), s = computed(() => typeof t.transitions == "boolean" ? t.transitions ? _n({}) : false : _n(t.transitions));
    provide(Wt, s);
    const w = computed(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), E = computed(() => Object.assign(Wl(), t.textInputOptions)), ee = computed(() => jl(t.ariaLabels));
    provide(ze, ee);
    const I = computed(() => Ul(t.filters)), re = computed(() => {
      const f = (ne) => {
        const ce = {
          hours: getHours(new Date()),
          minutes: getMinutes(new Date()),
          seconds: getSeconds(new Date())
        };
        return Object.assign(ce, ne);
      };
      return t.range ? t.startTime && Array.isArray(t.startTime) ? [f(t.startTime[0]), f(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? f(t.startTime) : null;
    }), p = computed(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), P = () => {
      m.value && (t.closeOnScroll ? be() : t.autoPosition ? T() : window.removeEventListener("scroll", P));
    }, N = () => {
      m.value && T();
    }, pe = () => {
      !t.disabled && !t.readonly && (l(), m.value = true, nextTick().then(() => {
        T(), m.value && n("open");
      }), m.value || Ze(), J(t.modelValue));
    }, Ee = () => {
      F.value = "", Ze(), n("update:modelValue", null), n("cleared"), be();
    }, Je = () => {
      const { validate: f } = Xn(t.minDate, t.maxDate, t.disabledDates, t.allowedDates, I.value, t.disabledWeekDays, t.yearRange), ne = o.value;
      return !ne || !Array.isArray(ne) && f(ne) ? true : Array.isArray(ne) ? ne.length === 2 && f(ne[0]) && f(ne[1]) ? true : !!f(ne[0]) : false;
    }, Ne = () => {
      U() && Je() ? (_(), be()) : n("invalid-select", o.value);
    }, Ke = (f) => {
      _(), t.closeOnAutoApply && !f && be();
    }, He = (f = false) => {
      t.autoApply && (!t.enableTimePicker || t.monthPicker || t.yearPicker ? true : on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate)) && Je() && (t.range && Array.isArray(o.value) ? (t.partialRange || o.value.length === 2) && Ke(f) : Ke(f));
    }, Ze = () => {
      o.value = null;
    }, be = () => {
      t.inline || (m.value && (m.value = false, Q(false), j(false), Z(), n("closed"), l(), F.value && J(v.value)), Ze(), h.value && h.value.focusInput());
    }, ot = (f, ne) => {
      if (!f) {
        o.value = null;
        return;
      }
      o.value = f, ne && (Ne(), n("textSubmit"));
    }, pt = () => {
      t.autoApply && on(o.value, t.maxTime, t.minTime, t.maxDate, t.minDate) && _();
    }, ht = () => m.value ? be() : pe();
    return Qr(y, h, be), a({
      closeMenu: be,
      selectDate: Ne,
      clearValue: Ee,
      openMenu: pe,
      onScroll: P,
      formatInputValue: z
    }), (f, ne) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(D))
    }, [
      createVNode(Ol, mergeProps({
        ref_key: "inputRef",
        ref: h
      }, {
        placeholder: f.placeholder,
        hideInputIcon: f.hideInputIcon,
        readonly: f.readonly,
        disabled: f.disabled,
        inputClassName: f.inputClassName,
        clearable: f.clearable,
        state: f.state,
        inline: f.inline,
        inlineWithInput: f.inlineWithInput,
        textInput: f.textInput,
        textInputOptions: unref(E),
        range: f.range,
        isMenuOpen: m.value,
        pattern: unref($),
        autoApply: f.autoApply,
        uid: f.uid,
        required: f.required,
        name: f.name,
        autocomplete: f.autocomplete
      }, {
        "input-value": unref(F),
        "onUpdate:input-value": ne[0] || (ne[0] = (ce) => isRef(F) ? F.value = ce : null),
        onClear: Ee,
        onOpen: pe,
        onSetInputDate: ot,
        onSetEmptyDate: unref(_),
        onSelectDate: Ne,
        onToggle: ht,
        onClose: be,
        onFocus: ne[1] || (ne[1] = (ce) => f.$emit("focus")),
        onBlur: ne[2] || (ne[2] = (ce) => f.$emit("blur"))
      }), createSlots({ _: 2 }, [
        renderList(unref(Y), (ce, ut) => ({
          name: ce,
          fn: withCtx((Qe) => [
            renderSlot(f.$slots, ce, normalizeProps(guardReactiveProps(Qe)))
          ])
        }))
      ]), 1040, ["input-value", "onSetEmptyDate"]),
      m.value ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: f.teleport,
        disabled: f.inline
      }, [
        m.value ? (openBlock(), createBlock(jr, mergeProps({
          key: 0,
          ref_key: "dpMenuRef",
          ref: y,
          class: unref(w),
          style: unref(L)
        }, {
          weekNumbers: f.weekNumbers,
          weekStart: f.weekStart,
          disableMonthYearSelect: f.disableMonthYearSelect,
          menuClassName: f.menuClassName,
          calendarClassName: f.calendarClassName,
          yearRange: f.yearRange,
          range: f.range,
          multiCalendars: unref(p),
          multiCalendarsSolo: f.multiCalendarsSolo,
          multiStatic: f.multiStatic,
          calendarCellClassName: f.calendarCellClassName,
          enableTimePicker: f.enableTimePicker,
          is24: f.is24,
          hoursIncrement: f.hoursIncrement,
          minutesIncrement: f.minutesIncrement,
          hoursGridIncrement: f.hoursGridIncrement,
          minutesGridIncrement: f.minutesGridIncrement,
          minDate: f.minDate,
          maxDate: f.maxDate,
          autoApply: f.autoApply,
          selectText: f.selectText,
          cancelText: f.cancelText,
          previewFormat: unref(i),
          locale: f.locale,
          weekNumName: f.weekNumName,
          disabledDates: f.disabledDates,
          filters: unref(I),
          minTime: f.minTime,
          maxTime: f.maxTime,
          inline: f.inline,
          openOnTop: unref(O),
          monthPicker: f.monthPicker,
          timePicker: f.timePicker,
          monthNameFormat: f.monthNameFormat,
          startDate: f.startDate,
          startTime: unref(re),
          monthYearComponent: f.monthYearComponent,
          timePickerComponent: f.timePickerComponent,
          actionRowComponent: f.actionRowComponent,
          customProps: f.customProps,
          hideOffsetDates: f.hideOffsetDates,
          autoRange: f.autoRange,
          noToday: f.noToday,
          noHoursOverlay: f.noHoursOverlay,
          noMinutesOverlay: f.noMinutesOverlay,
          disabledWeekDays: f.disabledWeekDays,
          allowedDates: f.allowedDates,
          showNowButton: f.showNowButton,
          nowButtonLabel: f.nowButtonLabel,
          monthChangeOnScroll: f.monthChangeOnScroll,
          markers: f.markers,
          uid: f.uid,
          modeHeight: f.modeHeight,
          enableSeconds: f.enableSeconds,
          secondsIncrement: f.secondsIncrement,
          secondsGridIncrement: f.secondsGridIncrement,
          noSecondsOverlay: f.noSecondsOverlay,
          escClose: f.escClose,
          spaceConfirm: f.spaceConfirm,
          monthChangeOnArrows: f.monthChangeOnArrows,
          textInput: f.textInput,
          disabled: f.disabled,
          readonly: f.readonly,
          multiDates: f.multiDates,
          presetRanges: f.presetRanges,
          flow: f.flow,
          preventMinMaxNavigation: f.preventMinMaxNavigation,
          minRange: f.minRange,
          maxRange: f.maxRange,
          fixedStart: f.fixedStart,
          fixedEnd: f.fixedEnd,
          multiDatesLimit: f.multiDatesLimit,
          reverseYears: f.reverseYears,
          keepActionRow: f.keepActionRow,
          weekPicker: f.weekPicker,
          noSwipe: f.noSwipe,
          vertical: f.vertical,
          arrowNavigation: f.arrowNavigation,
          yearPicker: f.yearPicker,
          disableTimeRangeValidation: f.disableTimeRangeValidation,
          dayNames: f.dayNames,
          modelAuto: f.modelAuto,
          highlight: f.highlight,
          partialRange: f.partialRange,
          teleportCenter: f.teleportCenter
        }, {
          internalModelValue: unref(o),
          "onUpdate:internalModelValue": ne[3] || (ne[3] = (ce) => isRef(o) ? o.value = ce : null),
          onClosePicker: be,
          onSelectDate: Ne,
          onDpOpen: unref(te),
          onAutoApply: He,
          onTimeUpdate: pt,
          onFlowStep: ne[4] || (ne[4] = (ce) => f.$emit("flow-step", ce)),
          onUpdateMonthYear: ne[5] || (ne[5] = (ce) => f.$emit("updateMonthYear", ce)),
          onInvalidSelect: ne[6] || (ne[6] = (ce) => f.$emit("invalid-select", unref(o)))
        }), createSlots({ _: 2 }, [
          renderList(unref(B), (ce, ut) => ({
            name: ce,
            fn: withCtx((Qe) => [
              renderSlot(f.$slots, ce, normalizeProps(guardReactiveProps(__spreadValues({}, Qe))))
            ])
          }))
        ]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : createCommentVNode("", true)
      ], 8, ["to", "disabled"])) : createCommentVNode("", true)
    ], 2));
  }
});
var ia = (() => {
  const e = xr;
  return e.install = (a) => {
    a.component("Vue3DatePicker", e);
  }, e;
})();
var es = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: ia
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(es).forEach(([e, a]) => {
  e !== "default" && (ia[e] = a);
});

// dep:@vuepic_vue-datepicker
var vuepic_vue_datepicker_default = ia;
export {
  vuepic_vue_datepicker_default as default
};
//# sourceMappingURL=@vuepic_vue-datepicker.js.map
