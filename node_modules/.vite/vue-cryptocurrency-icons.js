import {
  __commonJS
} from "./chunk-GKLGRTFA.js";

// node_modules/vue-cryptocurrency-icons/node_modules/vue/dist/vue.runtime.common.dev.js
var require_vue_runtime_common_dev = __commonJS({
  "node_modules/vue-cryptocurrency-icons/node_modules/vue/dist/vue.runtime.common.dev.js"(exports, module) {
    "use strict";
    var emptyObject = Object.freeze({});
    var isArray = Array.isArray;
    function isUndef(v) {
      return v === void 0 || v === null;
    }
    function isDef(v) {
      return v !== void 0 && v !== null;
    }
    function isTrue(v) {
      return v === true;
    }
    function isFalse(v) {
      return v === false;
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(obj) {
      return obj !== null && typeof obj === "object";
    }
    var _toString = Object.prototype.toString;
    function toRawType(value) {
      return _toString.call(value).slice(8, -1);
    }
    function isPlainObject(obj) {
      return _toString.call(obj) === "[object Object]";
    }
    function isRegExp(v) {
      return _toString.call(v) === "[object RegExp]";
    }
    function isValidArrayIndex(val) {
      const n = parseFloat(String(val));
      return n >= 0 && Math.floor(n) === n && isFinite(val);
    }
    function isPromise(val) {
      return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
    }
    function toString(val) {
      return val == null ? "" : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
    }
    function toNumber(val) {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    }
    function makeMap(str, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase ? (val) => map[val.toLowerCase()] : (val) => map[val];
    }
    var isBuiltInTag = makeMap("slot,component", true);
    var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
    function remove$2(arr, item) {
      if (arr.length) {
        const index2 = arr.indexOf(item);
        if (index2 > -1) {
          return arr.splice(index2, 1);
        }
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }
    function cached(fn) {
      const cache = /* @__PURE__ */ Object.create(null);
      return function cachedFn(str) {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    }
    var camelizeRE = /-(\w)/g;
    var camelize = cached((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    var capitalize = cached((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cached((str) => {
      return str.replace(hyphenateRE, "-$1").toLowerCase();
    });
    function polyfillBind(fn, ctx) {
      function boundFn(a) {
        const l = arguments.length;
        return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
      }
      boundFn._length = fn.length;
      return boundFn;
    }
    function nativeBind(fn, ctx) {
      return fn.bind(ctx);
    }
    var bind = Function.prototype.bind ? nativeBind : polyfillBind;
    function toArray(list, start) {
      start = start || 0;
      let i = list.length - start;
      const ret = new Array(i);
      while (i--) {
        ret[i] = list[i + start];
      }
      return ret;
    }
    function extend(to, _from) {
      for (const key in _from) {
        to[key] = _from[key];
      }
      return to;
    }
    function toObject(arr) {
      const res = {};
      for (let i = 0; i < arr.length; i++) {
        if (arr[i]) {
          extend(res, arr[i]);
        }
      }
      return res;
    }
    function noop(a, b, c) {
    }
    var no = (a, b, c) => false;
    var identity = (_) => _;
    function looseEqual(a, b) {
      if (a === b)
        return true;
      const isObjectA = isObject(a);
      const isObjectB = isObject(b);
      if (isObjectA && isObjectB) {
        try {
          const isArrayA = Array.isArray(a);
          const isArrayB = Array.isArray(b);
          if (isArrayA && isArrayB) {
            return a.length === b.length && a.every((e, i) => {
              return looseEqual(e, b[i]);
            });
          } else if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime();
          } else if (!isArrayA && !isArrayB) {
            const keysA = Object.keys(a);
            const keysB = Object.keys(b);
            return keysA.length === keysB.length && keysA.every((key) => {
              return looseEqual(a[key], b[key]);
            });
          } else {
            return false;
          }
        } catch (e) {
          return false;
        }
      } else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
      } else {
        return false;
      }
    }
    function looseIndexOf(arr, val) {
      for (let i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val))
          return i;
      }
      return -1;
    }
    function once(fn) {
      let called = false;
      return function() {
        if (!called) {
          called = true;
          fn.apply(this, arguments);
        }
      };
    }
    function hasChanged(x, y) {
      if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
      } else {
        return x === x || y === y;
      }
    }
    var SSR_ATTR = "data-server-rendered";
    var ASSET_TYPES = ["component", "directive", "filter"];
    var LIFECYCLE_HOOKS = [
      "beforeCreate",
      "created",
      "beforeMount",
      "mounted",
      "beforeUpdate",
      "updated",
      "beforeDestroy",
      "destroyed",
      "activated",
      "deactivated",
      "errorCaptured",
      "serverPrefetch",
      "renderTracked",
      "renderTriggered"
    ];
    var config = {
      optionMergeStrategies: /* @__PURE__ */ Object.create(null),
      silent: false,
      productionTip: true,
      devtools: true,
      performance: false,
      errorHandler: null,
      warnHandler: null,
      ignoredElements: [],
      keyCodes: /* @__PURE__ */ Object.create(null),
      isReservedTag: no,
      isReservedAttr: no,
      isUnknownElement: no,
      getTagNamespace: noop,
      parsePlatformTagName: identity,
      mustUseProp: no,
      async: true,
      _lifecycleHooks: LIFECYCLE_HOOKS
    };
    var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
    function isReserved(str) {
      const c = (str + "").charCodeAt(0);
      return c === 36 || c === 95;
    }
    function def(obj, key, val, enumerable) {
      Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
      });
    }
    var bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\d]`);
    function parsePath(path) {
      if (bailRE.test(path)) {
        return;
      }
      const segments = path.split(".");
      return function(obj) {
        for (let i = 0; i < segments.length; i++) {
          if (!obj)
            return;
          obj = obj[segments[i]];
        }
        return obj;
      };
    }
    var hasProto = "__proto__" in {};
    var inBrowser = typeof window !== "undefined";
    var UA = inBrowser && window.navigator.userAgent.toLowerCase();
    var isIE = UA && /msie|trident/.test(UA);
    var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
    var isEdge = UA && UA.indexOf("edge/") > 0;
    UA && UA.indexOf("android") > 0;
    var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
    UA && /chrome\/\d+/.test(UA) && !isEdge;
    UA && /phantomjs/.test(UA);
    var isFF = UA && UA.match(/firefox\/(\d+)/);
    var nativeWatch = {}.watch;
    var supportsPassive = false;
    if (inBrowser) {
      try {
        const opts = {};
        Object.defineProperty(opts, "passive", {
          get() {
            supportsPassive = true;
          }
        });
        window.addEventListener("test-passive", null, opts);
      } catch (e) {
      }
    }
    var _isServer;
    var isServerRendering = () => {
      if (_isServer === void 0) {
        if (!inBrowser && typeof global !== "undefined") {
          _isServer = global["process"] && global["process"].env.VUE_ENV === "server";
        } else {
          _isServer = false;
        }
      }
      return _isServer;
    };
    var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
    function isNative(Ctor) {
      return typeof Ctor === "function" && /native code/.test(Ctor.toString());
    }
    var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) && typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
    var _Set;
    if (typeof Set !== "undefined" && isNative(Set)) {
      _Set = Set;
    } else {
      _Set = class Set {
        constructor() {
          this.set = /* @__PURE__ */ Object.create(null);
        }
        has(key) {
          return this.set[key] === true;
        }
        add(key) {
          this.set[key] = true;
        }
        clear() {
          this.set = /* @__PURE__ */ Object.create(null);
        }
      };
    }
    var currentInstance = null;
    function getCurrentInstance() {
      return currentInstance && { proxy: currentInstance };
    }
    function setCurrentInstance(vm = null) {
      if (!vm)
        currentInstance && currentInstance._scope.off();
      currentInstance = vm;
      vm && vm._scope.on();
    }
    var VNode = class {
      constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = void 0;
        this.context = context;
        this.fnContext = void 0;
        this.fnOptions = void 0;
        this.fnScopeId = void 0;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = void 0;
        this.parent = void 0;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = void 0;
        this.isAsyncPlaceholder = false;
      }
      get child() {
        return this.componentInstance;
      }
    };
    var createEmptyVNode = (text = "") => {
      const node = new VNode();
      node.text = text;
      node.isComment = true;
      return node;
    };
    function createTextVNode(val) {
      return new VNode(void 0, void 0, void 0, String(val));
    }
    function cloneVNode(vnode) {
      const cloned = new VNode(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
      cloned.ns = vnode.ns;
      cloned.isStatic = vnode.isStatic;
      cloned.key = vnode.key;
      cloned.isComment = vnode.isComment;
      cloned.fnContext = vnode.fnContext;
      cloned.fnOptions = vnode.fnOptions;
      cloned.fnScopeId = vnode.fnScopeId;
      cloned.asyncMeta = vnode.asyncMeta;
      cloned.isCloned = true;
      return cloned;
    }
    var uid$2 = 0;
    var Dep = class {
      constructor() {
        this.id = uid$2++;
        this.subs = [];
      }
      addSub(sub) {
        this.subs.push(sub);
      }
      removeSub(sub) {
        remove$2(this.subs, sub);
      }
      depend(info) {
        if (Dep.target) {
          Dep.target.addDep(this);
          if (info && Dep.target.onTrack) {
            Dep.target.onTrack(Object.assign({ effect: Dep.target }, info));
          }
        }
      }
      notify(info) {
        const subs = this.subs.slice();
        if (!config.async) {
          subs.sort((a, b) => a.id - b.id);
        }
        for (let i = 0, l = subs.length; i < l; i++) {
          if (info) {
            const sub = subs[i];
            sub.onTrigger && sub.onTrigger(Object.assign({ effect: subs[i] }, info));
          }
          subs[i].update();
        }
      }
    };
    Dep.target = null;
    var targetStack = [];
    function pushTarget(target2) {
      targetStack.push(target2);
      Dep.target = target2;
    }
    function popTarget() {
      targetStack.pop();
      Dep.target = targetStack[targetStack.length - 1];
    }
    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto);
    var methodsToPatch = [
      "push",
      "pop",
      "shift",
      "unshift",
      "splice",
      "sort",
      "reverse"
    ];
    methodsToPatch.forEach(function(method) {
      const original = arrayProto[method];
      def(arrayMethods, method, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;
        let inserted;
        switch (method) {
          case "push":
          case "unshift":
            inserted = args;
            break;
          case "splice":
            inserted = args.slice(2);
            break;
        }
        if (inserted)
          ob.observeArray(inserted);
        {
          ob.dep.notify({
            type: "array mutation",
            target: this,
            key: method
          });
        }
        return result;
      });
    });
    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
    var NO_INIITIAL_VALUE = {};
    var shouldObserve = true;
    function toggleObserving(value) {
      shouldObserve = value;
    }
    var mockDep = {
      notify: noop,
      depend: noop,
      addSub: noop,
      removeSub: noop
    };
    var Observer = class {
      constructor(value, shallow = false, mock = false) {
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        this.dep = mock ? mockDep : new Dep();
        this.vmCount = 0;
        def(value, "__ob__", this);
        if (isArray(value)) {
          if (!mock) {
            if (hasProto) {
              value.__proto__ = arrayMethods;
            } else {
              for (let i = 0, l = arrayKeys.length; i < l; i++) {
                const key = arrayKeys[i];
                def(value, key, arrayMethods[key]);
              }
            }
          }
          if (!shallow) {
            this.observeArray(value);
          }
        } else {
          const keys = Object.keys(value);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            defineReactive(value, key, NO_INIITIAL_VALUE, void 0, shallow, mock);
          }
        }
      }
      observeArray(value) {
        for (let i = 0, l = value.length; i < l; i++) {
          observe(value[i], false, this.mock);
        }
      }
    };
    function observe(value, shallow, ssrMockReactivity) {
      if (!isObject(value) || isRef(value) || value instanceof VNode) {
        return;
      }
      let ob;
      if (hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
      } else if (shouldObserve && (ssrMockReactivity || !isServerRendering()) && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value.__v_skip) {
        ob = new Observer(value, shallow, ssrMockReactivity);
      }
      return ob;
    }
    function defineReactive(obj, key, val, customSetter, shallow, mock) {
      const dep = new Dep();
      const property = Object.getOwnPropertyDescriptor(obj, key);
      if (property && property.configurable === false) {
        return;
      }
      const getter = property && property.get;
      const setter = property && property.set;
      if ((!getter || setter) && (val === NO_INIITIAL_VALUE || arguments.length === 2)) {
        val = obj[key];
      }
      let childOb = !shallow && observe(val, false, mock);
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
          const value = getter ? getter.call(obj) : val;
          if (Dep.target) {
            {
              dep.depend({
                target: obj,
                type: "get",
                key
              });
            }
            if (childOb) {
              childOb.dep.depend();
              if (isArray(value)) {
                dependArray(value);
              }
            }
          }
          return isRef(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
          const value = getter ? getter.call(obj) : val;
          if (!hasChanged(value, newVal)) {
            return;
          }
          if (customSetter) {
            customSetter();
          }
          if (setter) {
            setter.call(obj, newVal);
          } else if (getter) {
            return;
          } else if (!shallow && isRef(value) && !isRef(newVal)) {
            value.value = newVal;
            return;
          } else {
            val = newVal;
          }
          childOb = !shallow && observe(newVal, false, mock);
          {
            dep.notify({
              type: "set",
              target: obj,
              key,
              newValue: newVal,
              oldValue: value
            });
          }
        }
      });
      return dep;
    }
    function set(target2, key, val) {
      if (isUndef(target2) || isPrimitive(target2)) {
        warn(`Cannot set reactive property on undefined, null, or primitive value: ${target2}`);
      }
      if (isReadonly(target2)) {
        warn(`Set operation on key "${key}" failed: target is readonly.`);
        return;
      }
      const ob = target2.__ob__;
      if (isArray(target2) && isValidArrayIndex(key)) {
        target2.length = Math.max(target2.length, key);
        target2.splice(key, 1, val);
        if (ob && !ob.shallow && ob.mock) {
          observe(val, false, true);
        }
        return val;
      }
      if (key in target2 && !(key in Object.prototype)) {
        target2[key] = val;
        return val;
      }
      if (target2._isVue || ob && ob.vmCount) {
        warn("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
        return val;
      }
      if (!ob) {
        target2[key] = val;
        return val;
      }
      defineReactive(ob.value, key, val, void 0, ob.shallow, ob.mock);
      {
        ob.dep.notify({
          type: "add",
          target: target2,
          key,
          newValue: val,
          oldValue: void 0
        });
      }
      return val;
    }
    function del(target2, key) {
      if (isUndef(target2) || isPrimitive(target2)) {
        warn(`Cannot delete reactive property on undefined, null, or primitive value: ${target2}`);
      }
      if (isArray(target2) && isValidArrayIndex(key)) {
        target2.splice(key, 1);
        return;
      }
      const ob = target2.__ob__;
      if (target2._isVue || ob && ob.vmCount) {
        warn("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
        return;
      }
      if (isReadonly(target2)) {
        warn(`Delete operation on key "${key}" failed: target is readonly.`);
        return;
      }
      if (!hasOwn(target2, key)) {
        return;
      }
      delete target2[key];
      if (!ob) {
        return;
      }
      {
        ob.dep.notify({
          type: "delete",
          target: target2,
          key
        });
      }
    }
    function dependArray(value) {
      for (let e, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
          e.__ob__.dep.depend();
        }
        if (isArray(e)) {
          dependArray(e);
        }
      }
    }
    function reactive(target2) {
      makeReactive(target2, false);
      return target2;
    }
    function shallowReactive(target2) {
      makeReactive(target2, true);
      def(target2, "__v_isShallow", true);
      return target2;
    }
    function makeReactive(target2, shallow) {
      if (!isReadonly(target2)) {
        {
          if (isArray(target2)) {
            warn(`Avoid using Array as root value for ${shallow ? `shallowReactive()` : `reactive()`} as it cannot be tracked in watch() or watchEffect(). Use ${shallow ? `shallowRef()` : `ref()`} instead. This is a Vue-2-only limitation.`);
          }
          const existingOb = target2 && target2.__ob__;
          if (existingOb && existingOb.shallow !== shallow) {
            warn(`Target is already a ${existingOb.shallow ? `` : `non-`}shallow reactive object, and cannot be converted to ${shallow ? `` : `non-`}shallow.`);
          }
        }
        const ob = observe(target2, shallow, isServerRendering());
        if (!ob) {
          if (target2 == null || isPrimitive(target2)) {
            warn(`value cannot be made reactive: ${String(target2)}`);
          }
          if (isCollectionType(target2)) {
            warn(`Vue 2 does not support reactive collection types such as Map or Set.`);
          }
        }
      }
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value.__ob__);
    }
    function isShallow(value) {
      return !!(value && value.__v_isShallow);
    }
    function isReadonly(value) {
      return !!(value && value.__v_isReadonly);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    function isCollectionType(value) {
      const type = toRawType(value);
      return type === "Map" || type === "WeakMap" || type === "Set" || type === "WeakSet";
    }
    var RefFlag = `__v_isRef`;
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref$1(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      const ref2 = {};
      def(ref2, RefFlag, true);
      def(ref2, "__v_isShallow", shallow);
      def(ref2, "dep", defineReactive(ref2, "value", rawValue, null, shallow, isServerRendering()));
      return ref2;
    }
    function triggerRef(ref2) {
      if (!ref2.dep) {
        warn(`received object is not a triggerable ref.`);
      }
      {
        ref2.dep && ref2.dep.notify({
          type: "set",
          target: ref2,
          key: "value"
        });
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    function proxyRefs(objectWithRefs) {
      if (isReactive(objectWithRefs)) {
        return objectWithRefs;
      }
      const proxy2 = {};
      const keys = Object.keys(objectWithRefs);
      for (let i = 0; i < keys.length; i++) {
        proxyWithRefUnwrap(proxy2, objectWithRefs, keys[i]);
      }
      return proxy2;
    }
    function proxyWithRefUnwrap(target2, source, key) {
      Object.defineProperty(target2, key, {
        enumerable: true,
        configurable: true,
        get: () => {
          const val = source[key];
          if (isRef(val)) {
            return val.value;
          } else {
            const ob = val && val.__ob__;
            if (ob)
              ob.dep.depend();
            return val;
          }
        },
        set: (value) => {
          const oldValue = source[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
          } else {
            source[key] = value;
          }
        }
      });
    }
    function customRef(factory) {
      const dep = new Dep();
      const { get, set: set2 } = factory(() => {
        {
          dep.depend({
            target: ref2,
            type: "get",
            key: "value"
          });
        }
      }, () => {
        {
          dep.notify({
            target: ref2,
            type: "set",
            key: "value"
          });
        }
      });
      const ref2 = {
        get value() {
          return get();
        },
        set value(newVal) {
          set2(newVal);
        }
      };
      def(ref2, RefFlag, true);
      return ref2;
    }
    function toRefs(object) {
      if (!isReactive(object)) {
        warn(`toRefs() expects a reactive object but received a plain one.`);
      }
      const ret = isArray(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = toRef(object, key);
      }
      return ret;
    }
    function toRef(object, key, defaultValue) {
      const val = object[key];
      if (isRef(val)) {
        return val;
      }
      const ref2 = {
        get value() {
          const val2 = object[key];
          return val2 === void 0 ? defaultValue : val2;
        },
        set value(newVal) {
          object[key] = newVal;
        }
      };
      def(ref2, RefFlag, true);
      return ref2;
    }
    var rawToReadonlyFlag = `__v_rawToReadonly`;
    var rawToShallowReadonlyFlag = `__v_rawToShallowReadonly`;
    function readonly(target2) {
      return createReadonly(target2, false);
    }
    function createReadonly(target2, shallow) {
      if (!isPlainObject(target2)) {
        {
          if (isArray(target2)) {
            warn(`Vue 2 does not support readonly arrays.`);
          } else if (isCollectionType(target2)) {
            warn(`Vue 2 does not support readonly collection types such as Map or Set.`);
          } else {
            warn(`value cannot be made readonly: ${typeof target2}`);
          }
        }
        return target2;
      }
      if (isReadonly(target2)) {
        return target2;
      }
      const existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
      const existingProxy = target2[existingFlag];
      if (existingProxy) {
        return existingProxy;
      }
      const proxy2 = Object.create(Object.getPrototypeOf(target2));
      def(target2, existingFlag, proxy2);
      def(proxy2, "__v_isReadonly", true);
      def(proxy2, "__v_raw", target2);
      if (isRef(target2)) {
        def(proxy2, RefFlag, true);
      }
      if (shallow || isShallow(target2)) {
        def(proxy2, "__v_isShallow", true);
      }
      const keys = Object.keys(target2);
      for (let i = 0; i < keys.length; i++) {
        defineReadonlyProperty(proxy2, target2, keys[i], shallow);
      }
      return proxy2;
    }
    function defineReadonlyProperty(proxy2, target2, key, shallow) {
      Object.defineProperty(proxy2, key, {
        enumerable: true,
        configurable: true,
        get() {
          const val = target2[key];
          return shallow || !isPlainObject(val) ? val : readonly(val);
        },
        set() {
          warn(`Set operation on key "${key}" failed: target is readonly.`);
        }
      });
    }
    function shallowReadonly(target2) {
      return createReadonly(target2, true);
    }
    function computed(getterOrOptions, debugOptions) {
      let getter;
      let setter;
      const onlyGetter = isFunction(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = () => {
          warn("Write operation failed: computed value is readonly");
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const watcher = isServerRendering() ? null : new Watcher(currentInstance, getter, noop, { lazy: true });
      if (watcher && debugOptions) {
        watcher.onTrack = debugOptions.onTrack;
        watcher.onTrigger = debugOptions.onTrigger;
      }
      const ref2 = {
        effect: watcher,
        get value() {
          if (watcher) {
            if (watcher.dirty) {
              watcher.evaluate();
            }
            if (Dep.target) {
              if (Dep.target.onTrack) {
                Dep.target.onTrack({
                  effect: Dep.target,
                  target: ref2,
                  type: "get",
                  key: "value"
                });
              }
              watcher.depend();
            }
            return watcher.value;
          } else {
            return getter();
          }
        },
        set value(newVal) {
          setter(newVal);
        }
      };
      def(ref2, RefFlag, true);
      def(ref2, "__v_isReadonly", onlyGetter);
      return ref2;
    }
    var WATCHER = `watcher`;
    var WATCHER_CB = `${WATCHER} callback`;
    var WATCHER_GETTER = `${WATCHER} getter`;
    var WATCHER_CLEANUP = `${WATCHER} cleanup`;
    function watchEffect(effect, options) {
      return doWatch(effect, null, options);
    }
    function watchPostEffect(effect, options) {
      return doWatch(effect, null, Object.assign(Object.assign({}, options), { flush: "post" }));
    }
    function watchSyncEffect(effect, options) {
      return doWatch(effect, null, Object.assign(Object.assign({}, options), { flush: "sync" }));
    }
    var INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      if (typeof cb !== "function") {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
      }
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, { immediate, deep, flush = "pre", onTrack, onTrigger } = emptyObject) {
      if (!cb) {
        if (immediate !== void 0) {
          warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
        }
        if (deep !== void 0) {
          warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
        }
      }
      const warnInvalidSource = (s) => {
        warn(`Invalid watch source: ${s}. A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
      };
      const instance = currentInstance;
      const call = (fn, type, args = null) => invokeWithErrorHandling(fn, null, args, instance, type);
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => {
          source.__ob__.dep.depend();
          return source;
        };
        deep = true;
      } else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return traverse(s);
          } else if (isFunction(s)) {
            return call(s, WATCHER_GETTER);
          } else {
            warnInvalidSource(s);
          }
        });
      } else if (isFunction(source)) {
        if (cb) {
          getter = () => call(source, WATCHER_GETTER);
        } else {
          getter = () => {
            if (instance && instance._isDestroyed) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return call(source, WATCHER, [onCleanup]);
          };
        }
      } else {
        getter = noop;
        warnInvalidSource(source);
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = watcher.onStop = () => {
          call(fn, WATCHER_CLEANUP);
        };
      };
      if (isServerRendering()) {
        onCleanup = noop;
        if (!cb) {
          getter();
        } else if (immediate) {
          call(cb, WATCHER_CB, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        return noop;
      }
      const watcher = new Watcher(currentInstance, getter, noop, {
        lazy: true
      });
      watcher.noRecurse = !cb;
      let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
      watcher.run = () => {
        if (!watcher.active) {
          return;
        }
        if (cb) {
          const newValue = watcher.get();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
            if (cleanup) {
              cleanup();
            }
            call(cb, WATCHER_CB, [
              newValue,
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          watcher.get();
        }
      };
      if (flush === "sync") {
        watcher.update = watcher.run;
      } else if (flush === "post") {
        watcher.post = true;
        watcher.update = () => queueWatcher(watcher);
      } else {
        watcher.update = () => {
          if (instance && instance === currentInstance && !instance._isMounted) {
            const buffer = instance._preWatchers || (instance._preWatchers = []);
            if (buffer.indexOf(watcher) < 0)
              buffer.push(watcher);
          } else {
            queueWatcher(watcher);
          }
        };
      }
      {
        watcher.onTrack = onTrack;
        watcher.onTrigger = onTrigger;
      }
      if (cb) {
        if (immediate) {
          watcher.run();
        } else {
          oldValue = watcher.get();
        }
      } else if (flush === "post" && instance) {
        instance.$once("hook:mounted", () => watcher.get());
      } else {
        watcher.get();
      }
      return () => {
        watcher.teardown();
      };
    }
    var activeEffectScope;
    var EffectScope = class {
      constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
          this.parent = activeEffectScope;
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
      }
      run(fn) {
        if (this.active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        } else {
          warn(`cannot run an inactive effect scope.`);
        }
      }
      on() {
        activeEffectScope = this;
      }
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this.active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].teardown();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.active = false;
        }
      }
    };
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
      } else {
        warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
      }
    }
    function provide(key, value) {
      if (!currentInstance) {
        {
          warn(`provide() can only be used inside setup().`);
        }
      } else {
        resolveProvided(currentInstance)[key] = value;
      }
    }
    function resolveProvided(vm) {
      const existing = vm._provided;
      const parentProvides = vm.$parent && vm.$parent._provided;
      if (parentProvides === existing) {
        return vm._provided = Object.create(parentProvides);
      } else {
        return existing;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance;
      if (instance) {
        const provides = instance.$parent && instance.$parent._provided;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance) : defaultValue;
        } else {
          warn(`injection "${String(key)}" not found.`);
        }
      } else {
        warn(`inject() can only be used inside setup() or functional components.`);
      }
    }
    var normalizeEvent = cached((name) => {
      const passive = name.charAt(0) === "&";
      name = passive ? name.slice(1) : name;
      const once2 = name.charAt(0) === "~";
      name = once2 ? name.slice(1) : name;
      const capture = name.charAt(0) === "!";
      name = capture ? name.slice(1) : name;
      return {
        name,
        once: once2,
        capture,
        passive
      };
    });
    function createFnInvoker(fns, vm) {
      function invoker() {
        const fns2 = invoker.fns;
        if (isArray(fns2)) {
          const cloned = fns2.slice();
          for (let i = 0; i < cloned.length; i++) {
            invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);
          }
        } else {
          return invokeWithErrorHandling(fns2, null, arguments, vm, `v-on handler`);
        }
      }
      invoker.fns = fns;
      return invoker;
    }
    function updateListeners(on, oldOn, add2, remove2, createOnceHandler2, vm) {
      let name, cur, old, event;
      for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
          warn(`Invalid handler for event "${event.name}": got ` + String(cur), vm);
        } else if (isUndef(old)) {
          if (isUndef(cur.fns)) {
            cur = on[name] = createFnInvoker(cur, vm);
          }
          if (isTrue(event.once)) {
            cur = on[name] = createOnceHandler2(event.name, cur, event.capture);
          }
          add2(event.name, cur, event.capture, event.passive, event.params);
        } else if (cur !== old) {
          old.fns = cur;
          on[name] = old;
        }
      }
      for (name in oldOn) {
        if (isUndef(on[name])) {
          event = normalizeEvent(name);
          remove2(event.name, oldOn[name], event.capture);
        }
      }
    }
    function mergeVNodeHook(def2, hookKey, hook) {
      if (def2 instanceof VNode) {
        def2 = def2.data.hook || (def2.data.hook = {});
      }
      let invoker;
      const oldHook = def2[hookKey];
      function wrappedHook() {
        hook.apply(this, arguments);
        remove$2(invoker.fns, wrappedHook);
      }
      if (isUndef(oldHook)) {
        invoker = createFnInvoker([wrappedHook]);
      } else {
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
          invoker = oldHook;
          invoker.fns.push(wrappedHook);
        } else {
          invoker = createFnInvoker([oldHook, wrappedHook]);
        }
      }
      invoker.merged = true;
      def2[hookKey] = invoker;
    }
    function extractPropsFromVNodeData(data, Ctor, tag) {
      const propOptions = Ctor.options.props;
      if (isUndef(propOptions)) {
        return;
      }
      const res = {};
      const { attrs: attrs2, props: props2 } = data;
      if (isDef(attrs2) || isDef(props2)) {
        for (const key in propOptions) {
          const altKey = hyphenate(key);
          {
            const keyInLowerCase = key.toLowerCase();
            if (key !== keyInLowerCase && attrs2 && hasOwn(attrs2, keyInLowerCase)) {
              tip(`Prop "${keyInLowerCase}" is passed to component ${formatComponentName(tag || Ctor)}, but the declared prop name is "${key}". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "${altKey}" instead of "${key}".`);
            }
          }
          checkProp(res, props2, key, altKey, true) || checkProp(res, attrs2, key, altKey, false);
        }
      }
      return res;
    }
    function checkProp(res, hash, key, altKey, preserve) {
      if (isDef(hash)) {
        if (hasOwn(hash, key)) {
          res[key] = hash[key];
          if (!preserve) {
            delete hash[key];
          }
          return true;
        } else if (hasOwn(hash, altKey)) {
          res[key] = hash[altKey];
          if (!preserve) {
            delete hash[altKey];
          }
          return true;
        }
      }
      return false;
    }
    function simpleNormalizeChildren(children) {
      for (let i = 0; i < children.length; i++) {
        if (isArray(children[i])) {
          return Array.prototype.concat.apply([], children);
        }
      }
      return children;
    }
    function normalizeChildren(children) {
      return isPrimitive(children) ? [createTextVNode(children)] : isArray(children) ? normalizeArrayChildren(children) : void 0;
    }
    function isTextNode(node) {
      return isDef(node) && isDef(node.text) && isFalse(node.isComment);
    }
    function normalizeArrayChildren(children, nestedIndex) {
      const res = [];
      let i, c, lastIndex, last;
      for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === "boolean")
          continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        if (isArray(c)) {
          if (c.length > 0) {
            c = normalizeArrayChildren(c, `${nestedIndex || ""}_${i}`);
            if (isTextNode(c[0]) && isTextNode(last)) {
              res[lastIndex] = createTextVNode(last.text + c[0].text);
              c.shift();
            }
            res.push.apply(res, c);
          }
        } else if (isPrimitive(c)) {
          if (isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c);
          } else if (c !== "") {
            res.push(createTextVNode(c));
          }
        } else {
          if (isTextNode(c) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c.text);
          } else {
            if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
              c.key = `__vlist${nestedIndex}_${i}__`;
            }
            res.push(c);
          }
        }
      }
      return res;
    }
    function renderList(val, render) {
      let ret = null, i, l, keys, key;
      if (isArray(val) || typeof val === "string") {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
          ret[i] = render(val[i], i);
        }
      } else if (typeof val === "number") {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
          ret[i] = render(i + 1, i);
        }
      } else if (isObject(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
          ret = [];
          const iterator = val[Symbol.iterator]();
          let result = iterator.next();
          while (!result.done) {
            ret.push(render(result.value, ret.length));
            result = iterator.next();
          }
        } else {
          keys = Object.keys(val);
          ret = new Array(keys.length);
          for (i = 0, l = keys.length; i < l; i++) {
            key = keys[i];
            ret[i] = render(val[key], key, i);
          }
        }
      }
      if (!isDef(ret)) {
        ret = [];
      }
      ret._isVList = true;
      return ret;
    }
    function renderSlot(name, fallbackRender, props2, bindObject) {
      const scopedSlotFn = this.$scopedSlots[name];
      let nodes;
      if (scopedSlotFn) {
        props2 = props2 || {};
        if (bindObject) {
          if (!isObject(bindObject)) {
            warn("slot v-bind without argument expects an Object", this);
          }
          props2 = extend(extend({}, bindObject), props2);
        }
        nodes = scopedSlotFn(props2) || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
      } else {
        nodes = this.$slots[name] || (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
      }
      const target2 = props2 && props2.slot;
      if (target2) {
        return this.$createElement("template", { slot: target2 }, nodes);
      } else {
        return nodes;
      }
    }
    function resolveFilter(id) {
      return resolveAsset(this.$options, "filters", id, true) || identity;
    }
    function isKeyNotMatch(expect, actual) {
      if (isArray(expect)) {
        return expect.indexOf(actual) === -1;
      } else {
        return expect !== actual;
      }
    }
    function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
      const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
      if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
      } else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
      } else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key;
      }
      return eventKeyCode === void 0;
    }
    function bindObjectProps(data, tag, value, asProp, isSync) {
      if (value) {
        if (!isObject(value)) {
          warn("v-bind without argument expects an Object or Array value", this);
        } else {
          if (isArray(value)) {
            value = toObject(value);
          }
          let hash;
          for (const key in value) {
            if (key === "class" || key === "style" || isReservedAttribute(key)) {
              hash = data;
            } else {
              const type = data.attrs && data.attrs.type;
              hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
            }
            const camelizedKey = camelize(key);
            const hyphenatedKey = hyphenate(key);
            if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
              hash[key] = value[key];
              if (isSync) {
                const on = data.on || (data.on = {});
                on[`update:${key}`] = function($event) {
                  value[key] = $event;
                };
              }
            }
          }
        }
      }
      return data;
    }
    function renderStatic(index2, isInFor) {
      const cached2 = this._staticTrees || (this._staticTrees = []);
      let tree = cached2[index2];
      if (tree && !isInFor) {
        return tree;
      }
      tree = cached2[index2] = this.$options.staticRenderFns[index2].call(this._renderProxy, this._c, this);
      markStatic(tree, `__static__${index2}`, false);
      return tree;
    }
    function markOnce(tree, index2, key) {
      markStatic(tree, `__once__${index2}${key ? `_${key}` : ``}`, true);
      return tree;
    }
    function markStatic(tree, key, isOnce) {
      if (isArray(tree)) {
        for (let i = 0; i < tree.length; i++) {
          if (tree[i] && typeof tree[i] !== "string") {
            markStaticNode(tree[i], `${key}_${i}`, isOnce);
          }
        }
      } else {
        markStaticNode(tree, key, isOnce);
      }
    }
    function markStaticNode(node, key, isOnce) {
      node.isStatic = true;
      node.key = key;
      node.isOnce = isOnce;
    }
    function bindObjectListeners(data, value) {
      if (value) {
        if (!isPlainObject(value)) {
          warn("v-on without argument expects an Object value", this);
        } else {
          const on = data.on = data.on ? extend({}, data.on) : {};
          for (const key in value) {
            const existing = on[key];
            const ours = value[key];
            on[key] = existing ? [].concat(existing, ours) : ours;
          }
        }
      }
      return data;
    }
    function resolveScopedSlots(fns, res, hasDynamicKeys, contentHashKey) {
      res = res || { $stable: !hasDynamicKeys };
      for (let i = 0; i < fns.length; i++) {
        const slot = fns[i];
        if (isArray(slot)) {
          resolveScopedSlots(slot, res, hasDynamicKeys);
        } else if (slot) {
          if (slot.proxy) {
            slot.fn.proxy = true;
          }
          res[slot.key] = slot.fn;
        }
      }
      if (contentHashKey) {
        res.$key = contentHashKey;
      }
      return res;
    }
    function bindDynamicKeys(baseObj, values) {
      for (let i = 0; i < values.length; i += 2) {
        const key = values[i];
        if (typeof key === "string" && key) {
          baseObj[values[i]] = values[i + 1];
        } else if (key !== "" && key !== null) {
          warn(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);
        }
      }
      return baseObj;
    }
    function prependModifier(value, symbol) {
      return typeof value === "string" ? symbol + value : value;
    }
    function installRenderHelpers(target2) {
      target2._o = markOnce;
      target2._n = toNumber;
      target2._s = toString;
      target2._l = renderList;
      target2._t = renderSlot;
      target2._q = looseEqual;
      target2._i = looseIndexOf;
      target2._m = renderStatic;
      target2._f = resolveFilter;
      target2._k = checkKeyCodes;
      target2._b = bindObjectProps;
      target2._v = createTextVNode;
      target2._e = createEmptyVNode;
      target2._u = resolveScopedSlots;
      target2._g = bindObjectListeners;
      target2._d = bindDynamicKeys;
      target2._p = prependModifier;
    }
    function resolveSlots(children, context) {
      if (!children || !children.length) {
        return {};
      }
      const slots = {};
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        const data = child.data;
        if (data && data.attrs && data.attrs.slot) {
          delete data.attrs.slot;
        }
        if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
          const name = data.slot;
          const slot = slots[name] || (slots[name] = []);
          if (child.tag === "template") {
            slot.push.apply(slot, child.children || []);
          } else {
            slot.push(child);
          }
        } else {
          (slots.default || (slots.default = [])).push(child);
        }
      }
      for (const name in slots) {
        if (slots[name].every(isWhitespace)) {
          delete slots[name];
        }
      }
      return slots;
    }
    function isWhitespace(node) {
      return node.isComment && !node.asyncFactory || node.text === " ";
    }
    function isAsyncPlaceholder(node) {
      return node.isComment && node.asyncFactory;
    }
    function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
      let res;
      const hasNormalSlots = Object.keys(normalSlots).length > 0;
      const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
      const key = scopedSlots && scopedSlots.$key;
      if (!scopedSlots) {
        res = {};
      } else if (scopedSlots._normalized) {
        return scopedSlots._normalized;
      } else if (isStable && prevScopedSlots && prevScopedSlots !== emptyObject && key === prevScopedSlots.$key && !hasNormalSlots && !prevScopedSlots.$hasNormal) {
        return prevScopedSlots;
      } else {
        res = {};
        for (const key2 in scopedSlots) {
          if (scopedSlots[key2] && key2[0] !== "$") {
            res[key2] = normalizeScopedSlot(ownerVm, normalSlots, key2, scopedSlots[key2]);
          }
        }
      }
      for (const key2 in normalSlots) {
        if (!(key2 in res)) {
          res[key2] = proxyNormalSlot(normalSlots, key2);
        }
      }
      if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
      }
      def(res, "$stable", isStable);
      def(res, "$key", key);
      def(res, "$hasNormal", hasNormalSlots);
      return res;
    }
    function normalizeScopedSlot(vm, normalSlots, key, fn) {
      const normalized = function() {
        const cur = currentInstance;
        setCurrentInstance(vm);
        let res = arguments.length ? fn.apply(null, arguments) : fn({});
        res = res && typeof res === "object" && !isArray(res) ? [res] : normalizeChildren(res);
        const vnode = res && res[0];
        setCurrentInstance(cur);
        return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) ? void 0 : res;
      };
      if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
          get: normalized,
          enumerable: true,
          configurable: true
        });
      }
      return normalized;
    }
    function proxyNormalSlot(slots, key) {
      return () => slots[key];
    }
    function initSetup(vm) {
      const options = vm.$options;
      const setup = options.setup;
      if (setup) {
        const ctx = vm._setupContext = createSetupContext(vm);
        setCurrentInstance(vm);
        pushTarget();
        const setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, `setup`);
        popTarget();
        setCurrentInstance();
        if (isFunction(setupResult)) {
          options.render = setupResult;
        } else if (isObject(setupResult)) {
          if (setupResult instanceof VNode) {
            warn(`setup() should not return VNodes directly - return a render function instead.`);
          }
          vm._setupState = setupResult;
          if (!setupResult.__sfc) {
            for (const key in setupResult) {
              if (!isReserved(key)) {
                proxyWithRefUnwrap(vm, setupResult, key);
              } else {
                warn(`Avoid using variables that start with _ or $ in setup().`);
              }
            }
          } else {
            const proxy2 = vm._setupProxy = {};
            for (const key in setupResult) {
              if (key !== "__sfc") {
                proxyWithRefUnwrap(proxy2, setupResult, key);
              }
            }
          }
        } else if (setupResult !== void 0) {
          warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
        }
      }
    }
    function createSetupContext(vm) {
      let exposeCalled = false;
      return {
        get attrs() {
          if (!vm._attrsProxy) {
            const proxy2 = vm._attrsProxy = {};
            def(proxy2, "_v_attr_proxy", true);
            syncSetupProxy(proxy2, vm.$attrs, emptyObject, vm, "$attrs");
          }
          return vm._attrsProxy;
        },
        get listeners() {
          if (!vm._listenersProxy) {
            const proxy2 = vm._listenersProxy = {};
            syncSetupProxy(proxy2, vm.$listeners, emptyObject, vm, "$listeners");
          }
          return vm._listenersProxy;
        },
        get slots() {
          return initSlotsProxy(vm);
        },
        emit: bind(vm.$emit, vm),
        expose(exposed) {
          {
            if (exposeCalled) {
              warn(`expose() should be called only once per setup().`, vm);
            }
            exposeCalled = true;
          }
          if (exposed) {
            Object.keys(exposed).forEach((key) => proxyWithRefUnwrap(vm, exposed, key));
          }
        }
      };
    }
    function syncSetupProxy(to, from, prev, instance, type) {
      let changed = false;
      for (const key in from) {
        if (!(key in to)) {
          changed = true;
          defineProxyAttr(to, key, instance, type);
        } else if (from[key] !== prev[key]) {
          changed = true;
        }
      }
      for (const key in to) {
        if (!(key in from)) {
          changed = true;
          delete to[key];
        }
      }
      return changed;
    }
    function defineProxyAttr(proxy2, key, instance, type) {
      Object.defineProperty(proxy2, key, {
        enumerable: true,
        configurable: true,
        get() {
          return instance[type][key];
        }
      });
    }
    function initSlotsProxy(vm) {
      if (!vm._slotsProxy) {
        syncSetupSlots(vm._slotsProxy = {}, vm.$scopedSlots);
      }
      return vm._slotsProxy;
    }
    function syncSetupSlots(to, from) {
      for (const key in from) {
        to[key] = from[key];
      }
      for (const key in to) {
        if (!(key in from)) {
          delete to[key];
        }
      }
    }
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs() {
      return getContext().attrs;
    }
    function useListeners() {
      return getContext().listeners;
    }
    function getContext() {
      if (!currentInstance) {
        warn(`useContext() called without active instance.`);
      }
      const vm = currentInstance;
      return vm._setupContext || (vm._setupContext = createSetupContext(vm));
    }
    function mergeDefaults(raw, defaults) {
      const props2 = isArray(raw) ? raw.reduce((normalized, p) => (normalized[p] = {}, normalized), {}) : raw;
      for (const key in defaults) {
        const opt = props2[key];
        if (opt) {
          if (isArray(opt) || isFunction(opt)) {
            props2[key] = { type: opt, default: defaults[key] };
          } else {
            opt.default = defaults[key];
          }
        } else if (opt === null) {
          props2[key] = { default: defaults[key] };
        } else {
          warn(`props default key "${key}" has no corresponding declaration.`);
        }
      }
      return props2;
    }
    function initRender(vm) {
      vm._vnode = null;
      vm._staticTrees = null;
      const options = vm.$options;
      const parentVnode = vm.$vnode = options._parentVnode;
      const renderContext = parentVnode && parentVnode.context;
      vm.$slots = resolveSlots(options._renderChildren, renderContext);
      vm.$scopedSlots = parentVnode ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots) : emptyObject;
      vm._c = (a, b, c, d) => createElement$1(vm, a, b, c, d, false);
      vm.$createElement = (a, b, c, d) => createElement$1(vm, a, b, c, d, true);
      const parentData = parentVnode && parentVnode.data;
      {
        defineReactive(vm, "$attrs", parentData && parentData.attrs || emptyObject, () => {
          !isUpdatingChildComponent && warn(`$attrs is readonly.`, vm);
        }, true);
        defineReactive(vm, "$listeners", options._parentListeners || emptyObject, () => {
          !isUpdatingChildComponent && warn(`$listeners is readonly.`, vm);
        }, true);
      }
    }
    var currentRenderingInstance = null;
    function renderMixin(Vue2) {
      installRenderHelpers(Vue2.prototype);
      Vue2.prototype.$nextTick = function(fn) {
        return nextTick(fn, this);
      };
      Vue2.prototype._render = function() {
        const vm = this;
        const { render, _parentVnode } = vm.$options;
        if (_parentVnode && vm._isMounted) {
          vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
          if (vm._slotsProxy) {
            syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
          }
        }
        vm.$vnode = _parentVnode;
        let vnode;
        try {
          setCurrentInstance(vm);
          currentRenderingInstance = vm;
          vnode = render.call(vm._renderProxy, vm.$createElement);
        } catch (e) {
          handleError(e, vm, `render`);
          if (vm.$options.renderError) {
            try {
              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
            } catch (e2) {
              handleError(e2, vm, `renderError`);
              vnode = vm._vnode;
            }
          } else {
            vnode = vm._vnode;
          }
        } finally {
          currentRenderingInstance = null;
          setCurrentInstance();
        }
        if (isArray(vnode) && vnode.length === 1) {
          vnode = vnode[0];
        }
        if (!(vnode instanceof VNode)) {
          if (isArray(vnode)) {
            warn("Multiple root nodes returned from render function. Render function should return a single root node.", vm);
          }
          vnode = createEmptyVNode();
        }
        vnode.parent = _parentVnode;
        return vnode;
      };
    }
    function ensureCtor(comp, base) {
      if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === "Module") {
        comp = comp.default;
      }
      return isObject(comp) ? base.extend(comp) : comp;
    }
    function createAsyncPlaceholder(factory, data, context, children, tag) {
      const node = createEmptyVNode();
      node.asyncFactory = factory;
      node.asyncMeta = { data, context, children, tag };
      return node;
    }
    function resolveAsyncComponent(factory, baseCtor) {
      if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp;
      }
      if (isDef(factory.resolved)) {
        return factory.resolved;
      }
      const owner = currentRenderingInstance;
      if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        factory.owners.push(owner);
      }
      if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp;
      }
      if (owner && !isDef(factory.owners)) {
        const owners = factory.owners = [owner];
        let sync = true;
        let timerLoading = null;
        let timerTimeout = null;
        owner.$on("hook:destroyed", () => remove$2(owners, owner));
        const forceRender = (renderCompleted) => {
          for (let i = 0, l = owners.length; i < l; i++) {
            owners[i].$forceUpdate();
          }
          if (renderCompleted) {
            owners.length = 0;
            if (timerLoading !== null) {
              clearTimeout(timerLoading);
              timerLoading = null;
            }
            if (timerTimeout !== null) {
              clearTimeout(timerTimeout);
              timerTimeout = null;
            }
          }
        };
        const resolve = once((res2) => {
          factory.resolved = ensureCtor(res2, baseCtor);
          if (!sync) {
            forceRender(true);
          } else {
            owners.length = 0;
          }
        });
        const reject = once((reason) => {
          warn(`Failed to resolve async component: ${String(factory)}` + (reason ? `
Reason: ${reason}` : ""));
          if (isDef(factory.errorComp)) {
            factory.error = true;
            forceRender(true);
          }
        });
        const res = factory(resolve, reject);
        if (isObject(res)) {
          if (isPromise(res)) {
            if (isUndef(factory.resolved)) {
              res.then(resolve, reject);
            }
          } else if (isPromise(res.component)) {
            res.component.then(resolve, reject);
            if (isDef(res.error)) {
              factory.errorComp = ensureCtor(res.error, baseCtor);
            }
            if (isDef(res.loading)) {
              factory.loadingComp = ensureCtor(res.loading, baseCtor);
              if (res.delay === 0) {
                factory.loading = true;
              } else {
                timerLoading = setTimeout(() => {
                  timerLoading = null;
                  if (isUndef(factory.resolved) && isUndef(factory.error)) {
                    factory.loading = true;
                    forceRender(false);
                  }
                }, res.delay || 200);
              }
            }
            if (isDef(res.timeout)) {
              timerTimeout = setTimeout(() => {
                timerTimeout = null;
                if (isUndef(factory.resolved)) {
                  reject(`timeout (${res.timeout}ms)`);
                }
              }, res.timeout);
            }
          }
        }
        sync = false;
        return factory.loading ? factory.loadingComp : factory.resolved;
      }
    }
    function getFirstComponentChild(children) {
      if (isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          const c = children[i];
          if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
            return c;
          }
        }
      }
    }
    var SIMPLE_NORMALIZE = 1;
    var ALWAYS_NORMALIZE = 2;
    function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
      if (isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = void 0;
      }
      if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
      }
      return _createElement(context, tag, data, children, normalizationType);
    }
    function _createElement(context, tag, data, children, normalizationType) {
      if (isDef(data) && isDef(data.__ob__)) {
        warn(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}
Always create fresh vnode data objects in each render!`, context);
        return createEmptyVNode();
      }
      if (isDef(data) && isDef(data.is)) {
        tag = data.is;
      }
      if (!tag) {
        return createEmptyVNode();
      }
      if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
        warn("Avoid using non-primitive value as key, use string/number value instead.", context);
      }
      if (isArray(children) && isFunction(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
      }
      if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
      } else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
      }
      let vnode, ns;
      if (typeof tag === "string") {
        let Ctor;
        ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
        if (config.isReservedTag(tag)) {
          if (isDef(data) && isDef(data.nativeOn) && data.tag !== "component") {
            warn(`The .native modifier for v-on is only valid on components but it was used on <${tag}>.`, context);
          }
          vnode = new VNode(config.parsePlatformTagName(tag), data, children, void 0, void 0, context);
        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
          vnode = createComponent(Ctor, data, context, children, tag);
        } else {
          vnode = new VNode(tag, data, children, void 0, void 0, context);
        }
      } else {
        vnode = createComponent(tag, data, context, children);
      }
      if (isArray(vnode)) {
        return vnode;
      } else if (isDef(vnode)) {
        if (isDef(ns))
          applyNS(vnode, ns);
        if (isDef(data))
          registerDeepBindings(data);
        return vnode;
      } else {
        return createEmptyVNode();
      }
    }
    function applyNS(vnode, ns, force) {
      vnode.ns = ns;
      if (vnode.tag === "foreignObject") {
        ns = void 0;
        force = true;
      }
      if (isDef(vnode.children)) {
        for (let i = 0, l = vnode.children.length; i < l; i++) {
          const child = vnode.children[i];
          if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
            applyNS(child, ns, force);
          }
        }
      }
    }
    function registerDeepBindings(data) {
      if (isObject(data.style)) {
        traverse(data.style);
      }
      if (isObject(data.class)) {
        traverse(data.class);
      }
    }
    function h(type, props2, children) {
      if (!currentInstance) {
        warn(`globally imported h() can only be invoked when there is an active component instance, e.g. synchronously in a component's render or setup function.`);
      }
      return createElement$1(currentInstance, type, props2, children, 2, true);
    }
    function handleError(err, vm, info) {
      pushTarget();
      try {
        if (vm) {
          let cur = vm;
          while (cur = cur.$parent) {
            const hooks2 = cur.$options.errorCaptured;
            if (hooks2) {
              for (let i = 0; i < hooks2.length; i++) {
                try {
                  const capture = hooks2[i].call(cur, err, vm, info) === false;
                  if (capture)
                    return;
                } catch (e) {
                  globalHandleError(e, cur, "errorCaptured hook");
                }
              }
            }
          }
        }
        globalHandleError(err, vm, info);
      } finally {
        popTarget();
      }
    }
    function invokeWithErrorHandling(handler, context, args, vm, info) {
      let res;
      try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise(res) && !res._handled) {
          res.catch((e) => handleError(e, vm, info + ` (Promise/async)`));
          res._handled = true;
        }
      } catch (e) {
        handleError(e, vm, info);
      }
      return res;
    }
    function globalHandleError(err, vm, info) {
      if (config.errorHandler) {
        try {
          return config.errorHandler.call(null, err, vm, info);
        } catch (e) {
          if (e !== err) {
            logError(e, null, "config.errorHandler");
          }
        }
      }
      logError(err, vm, info);
    }
    function logError(err, vm, info) {
      {
        warn(`Error in ${info}: "${err.toString()}"`, vm);
      }
      if (inBrowser && typeof console !== "undefined") {
        console.error(err);
      } else {
        throw err;
      }
    }
    var isUsingMicroTask = false;
    var callbacks = [];
    var pending = false;
    function flushCallbacks() {
      pending = false;
      const copies = callbacks.slice(0);
      callbacks.length = 0;
      for (let i = 0; i < copies.length; i++) {
        copies[i]();
      }
    }
    var timerFunc;
    if (typeof Promise !== "undefined" && isNative(Promise)) {
      const p = Promise.resolve();
      timerFunc = () => {
        p.then(flushCallbacks);
        if (isIOS)
          setTimeout(noop);
      };
      isUsingMicroTask = true;
    } else if (!isIE && typeof MutationObserver !== "undefined" && (isNative(MutationObserver) || MutationObserver.toString() === "[object MutationObserverConstructor]")) {
      let counter = 1;
      const observer = new MutationObserver(flushCallbacks);
      const textNode = document.createTextNode(String(counter));
      observer.observe(textNode, {
        characterData: true
      });
      timerFunc = () => {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
      };
      isUsingMicroTask = true;
    } else if (typeof setImmediate !== "undefined" && isNative(setImmediate)) {
      timerFunc = () => {
        setImmediate(flushCallbacks);
      };
    } else {
      timerFunc = () => {
        setTimeout(flushCallbacks, 0);
      };
    }
    function nextTick(cb, ctx) {
      let _resolve;
      callbacks.push(() => {
        if (cb) {
          try {
            cb.call(ctx);
          } catch (e) {
            handleError(e, ctx, "nextTick");
          }
        } else if (_resolve) {
          _resolve(ctx);
        }
      });
      if (!pending) {
        pending = true;
        timerFunc();
      }
      if (!cb && typeof Promise !== "undefined") {
        return new Promise((resolve) => {
          _resolve = resolve;
        });
      }
    }
    function useCssModule(name = "$style") {
      {
        if (!currentInstance) {
          warn(`useCssModule must be called inside setup()`);
          return emptyObject;
        }
        const mod = currentInstance[name];
        if (!mod) {
          warn(`Current instance does not have CSS module named "${name}".`);
          return emptyObject;
        }
        return mod;
      }
    }
    function useCssVars(getter) {
      if (!inBrowser && true)
        return;
      const instance = currentInstance;
      if (!instance) {
        warn(`useCssVars is called without current active component instance.`);
        return;
      }
      watchPostEffect(() => {
        const el = instance.$el;
        const vars = getter(instance, instance._setupProxy);
        if (el && el.nodeType === 1) {
          const style2 = el.style;
          for (const key in vars) {
            style2.setProperty(`--${key}`, vars[key]);
          }
        }
      });
    }
    function defineAsyncComponent(source) {
      if (isFunction(source)) {
        source = { loader: source };
      }
      const {
        loader,
        loadingComponent,
        errorComponent,
        delay = 200,
        timeout,
        suspensible = false,
        onError: userOnError
      } = source;
      if (suspensible) {
        warn(`The suspensiblbe option for async components is not supported in Vue2. It is ignored.`);
      }
      let pendingRequest = null;
      let retries = 0;
      const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
      };
      const load = () => {
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
          err = err instanceof Error ? err : new Error(String(err));
          if (userOnError) {
            return new Promise((resolve, reject) => {
              const userRetry = () => resolve(retry());
              const userFail = () => reject(err);
              userOnError(err, userRetry, userFail, retries + 1);
            });
          } else {
            throw err;
          }
        }).then((comp) => {
          if (thisRequest !== pendingRequest && pendingRequest) {
            return pendingRequest;
          }
          if (!comp) {
            warn(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
          }
          if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
            comp = comp.default;
          }
          if (comp && !isObject(comp) && !isFunction(comp)) {
            throw new Error(`Invalid async component load result: ${comp}`);
          }
          return comp;
        }));
      };
      return () => {
        const component = load();
        return {
          component,
          delay,
          timeout,
          error: errorComponent,
          loading: loadingComponent
        };
      };
    }
    function createLifeCycle(hookName) {
      return (fn, target2 = currentInstance) => {
        if (!target2) {
          warn(`${formatName(hookName)} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`);
          return;
        }
        return injectHook(target2, hookName, fn);
      };
    }
    function formatName(name) {
      if (name === "beforeDestroy") {
        name = "beforeUnmount";
      } else if (name === "destroyed") {
        name = "unmounted";
      }
      return `on${name[0].toUpperCase() + name.slice(1)}`;
    }
    function injectHook(instance, hookName, fn) {
      const options = instance.$options;
      options[hookName] = mergeLifecycleHook(options[hookName], fn);
    }
    var onBeforeMount = createLifeCycle("beforeMount");
    var onMounted = createLifeCycle("mounted");
    var onBeforeUpdate = createLifeCycle("beforeUpdate");
    var onUpdated = createLifeCycle("updated");
    var onBeforeUnmount = createLifeCycle("beforeDestroy");
    var onUnmounted = createLifeCycle("destroyed");
    var onActivated = createLifeCycle("activated");
    var onDeactivated = createLifeCycle("deactivated");
    var onServerPrefetch = createLifeCycle("serverPrefetch");
    var onRenderTracked = createLifeCycle("renderTracked");
    var onRenderTriggered = createLifeCycle("renderTriggered");
    var injectErrorCapturedHook = createLifeCycle("errorCaptured");
    function onErrorCaptured(hook, target2 = currentInstance) {
      injectErrorCapturedHook(hook, target2);
    }
    var version = "2.7.9";
    function defineComponent(options) {
      return options;
    }
    var vca = Object.freeze({
      __proto__: null,
      version,
      defineComponent,
      ref: ref$1,
      shallowRef,
      isRef,
      toRef,
      toRefs,
      unref,
      proxyRefs,
      customRef,
      triggerRef,
      reactive,
      isReactive,
      isReadonly,
      isShallow,
      isProxy,
      shallowReactive,
      markRaw,
      toRaw,
      readonly,
      shallowReadonly,
      computed,
      watch,
      watchEffect,
      watchPostEffect,
      watchSyncEffect,
      EffectScope,
      effectScope,
      onScopeDispose,
      getCurrentScope,
      provide,
      inject,
      h,
      getCurrentInstance,
      useSlots,
      useAttrs,
      useListeners,
      mergeDefaults,
      nextTick,
      set,
      del,
      useCssModule,
      useCssVars,
      defineAsyncComponent,
      onBeforeMount,
      onMounted,
      onBeforeUpdate,
      onUpdated,
      onBeforeUnmount,
      onUnmounted,
      onActivated,
      onDeactivated,
      onServerPrefetch,
      onRenderTracked,
      onRenderTriggered,
      onErrorCaptured
    });
    var seenObjects = new _Set();
    function traverse(val) {
      _traverse(val, seenObjects);
      seenObjects.clear();
      return val;
    }
    function _traverse(val, seen) {
      let i, keys;
      const isA = isArray(val);
      if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
        return;
      }
      if (val.__ob__) {
        const depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
          return;
        }
        seen.add(depId);
      }
      if (isA) {
        i = val.length;
        while (i--)
          _traverse(val[i], seen);
      } else if (isRef(val)) {
        _traverse(val.value, seen);
      } else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
          _traverse(val[keys[i]], seen);
      }
    }
    var uid$1 = 0;
    var Watcher = class {
      constructor(vm, expOrFn, cb, options, isRenderWatcher) {
        recordEffectScope(this, activeEffectScope && !activeEffectScope._vm ? activeEffectScope : vm ? vm._scope : void 0);
        if ((this.vm = vm) && isRenderWatcher) {
          vm._watcher = this;
        }
        if (options) {
          this.deep = !!options.deep;
          this.user = !!options.user;
          this.lazy = !!options.lazy;
          this.sync = !!options.sync;
          this.before = options.before;
          {
            this.onTrack = options.onTrack;
            this.onTrigger = options.onTrigger;
          }
        } else {
          this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$1;
        this.active = true;
        this.post = false;
        this.dirty = this.lazy;
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression = expOrFn.toString();
        if (isFunction(expOrFn)) {
          this.getter = expOrFn;
        } else {
          this.getter = parsePath(expOrFn);
          if (!this.getter) {
            this.getter = noop;
            warn(`Failed watching path: "${expOrFn}" Watcher only accepts simple dot-delimited paths. For full control, use a function instead.`, vm);
          }
        }
        this.value = this.lazy ? void 0 : this.get();
      }
      get() {
        pushTarget(this);
        let value;
        const vm = this.vm;
        try {
          value = this.getter.call(vm, vm);
        } catch (e) {
          if (this.user) {
            handleError(e, vm, `getter for watcher "${this.expression}"`);
          } else {
            throw e;
          }
        } finally {
          if (this.deep) {
            traverse(value);
          }
          popTarget();
          this.cleanupDeps();
        }
        return value;
      }
      addDep(dep) {
        const id = dep.id;
        if (!this.newDepIds.has(id)) {
          this.newDepIds.add(id);
          this.newDeps.push(dep);
          if (!this.depIds.has(id)) {
            dep.addSub(this);
          }
        }
      }
      cleanupDeps() {
        let i = this.deps.length;
        while (i--) {
          const dep = this.deps[i];
          if (!this.newDepIds.has(dep.id)) {
            dep.removeSub(this);
          }
        }
        let tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
      }
      update() {
        if (this.lazy) {
          this.dirty = true;
        } else if (this.sync) {
          this.run();
        } else {
          queueWatcher(this);
        }
      }
      run() {
        if (this.active) {
          const value = this.get();
          if (value !== this.value || isObject(value) || this.deep) {
            const oldValue = this.value;
            this.value = value;
            if (this.user) {
              const info = `callback for watcher "${this.expression}"`;
              invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
            } else {
              this.cb.call(this.vm, value, oldValue);
            }
          }
        }
      }
      evaluate() {
        this.value = this.get();
        this.dirty = false;
      }
      depend() {
        let i = this.deps.length;
        while (i--) {
          this.deps[i].depend();
        }
      }
      teardown() {
        if (this.vm && !this.vm._isBeingDestroyed) {
          remove$2(this.vm._scope.effects, this);
        }
        if (this.active) {
          let i = this.deps.length;
          while (i--) {
            this.deps[i].removeSub(this);
          }
          this.active = false;
          if (this.onStop) {
            this.onStop();
          }
        }
      }
    };
    var mark;
    var measure;
    {
      const perf = inBrowser && window.performance;
      if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
        mark = (tag) => perf.mark(tag);
        measure = (name, startTag, endTag) => {
          perf.measure(name, startTag, endTag);
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
        };
      }
    }
    function initEvents(vm) {
      vm._events = /* @__PURE__ */ Object.create(null);
      vm._hasHookEvent = false;
      const listeners = vm.$options._parentListeners;
      if (listeners) {
        updateComponentListeners(vm, listeners);
      }
    }
    var target$1;
    function add$1(event, fn) {
      target$1.$on(event, fn);
    }
    function remove$1(event, fn) {
      target$1.$off(event, fn);
    }
    function createOnceHandler$1(event, fn) {
      const _target = target$1;
      return function onceHandler() {
        const res = fn.apply(null, arguments);
        if (res !== null) {
          _target.$off(event, onceHandler);
        }
      };
    }
    function updateComponentListeners(vm, listeners, oldListeners) {
      target$1 = vm;
      updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
      target$1 = void 0;
    }
    function eventsMixin(Vue2) {
      const hookRE = /^hook:/;
      Vue2.prototype.$on = function(event, fn) {
        const vm = this;
        if (isArray(event)) {
          for (let i = 0, l = event.length; i < l; i++) {
            vm.$on(event[i], fn);
          }
        } else {
          (vm._events[event] || (vm._events[event] = [])).push(fn);
          if (hookRE.test(event)) {
            vm._hasHookEvent = true;
          }
        }
        return vm;
      };
      Vue2.prototype.$once = function(event, fn) {
        const vm = this;
        function on() {
          vm.$off(event, on);
          fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm;
      };
      Vue2.prototype.$off = function(event, fn) {
        const vm = this;
        if (!arguments.length) {
          vm._events = /* @__PURE__ */ Object.create(null);
          return vm;
        }
        if (isArray(event)) {
          for (let i2 = 0, l = event.length; i2 < l; i2++) {
            vm.$off(event[i2], fn);
          }
          return vm;
        }
        const cbs = vm._events[event];
        if (!cbs) {
          return vm;
        }
        if (!fn) {
          vm._events[event] = null;
          return vm;
        }
        let cb;
        let i = cbs.length;
        while (i--) {
          cb = cbs[i];
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i, 1);
            break;
          }
        }
        return vm;
      };
      Vue2.prototype.$emit = function(event) {
        const vm = this;
        {
          const lowerCaseEvent = event.toLowerCase();
          if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
            tip(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(vm)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
          }
        }
        let cbs = vm._events[event];
        if (cbs) {
          cbs = cbs.length > 1 ? toArray(cbs) : cbs;
          const args = toArray(arguments, 1);
          const info = `event handler for "${event}"`;
          for (let i = 0, l = cbs.length; i < l; i++) {
            invokeWithErrorHandling(cbs[i], vm, args, vm, info);
          }
        }
        return vm;
      };
    }
    var activeInstance = null;
    var isUpdatingChildComponent = false;
    function setActiveInstance(vm) {
      const prevActiveInstance = activeInstance;
      activeInstance = vm;
      return () => {
        activeInstance = prevActiveInstance;
      };
    }
    function initLifecycle(vm) {
      const options = vm.$options;
      let parent = options.parent;
      if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
          parent = parent.$parent;
        }
        parent.$children.push(vm);
      }
      vm.$parent = parent;
      vm.$root = parent ? parent.$root : vm;
      vm.$children = [];
      vm.$refs = {};
      vm._provided = parent ? parent._provided : /* @__PURE__ */ Object.create(null);
      vm._watcher = null;
      vm._inactive = null;
      vm._directInactive = false;
      vm._isMounted = false;
      vm._isDestroyed = false;
      vm._isBeingDestroyed = false;
    }
    function lifecycleMixin(Vue2) {
      Vue2.prototype._update = function(vnode, hydrating) {
        const vm = this;
        const prevEl = vm.$el;
        const prevVnode = vm._vnode;
        const restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        if (!prevVnode) {
          vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
        } else {
          vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        if (prevEl) {
          prevEl.__vue__ = null;
        }
        if (vm.$el) {
          vm.$el.__vue__ = vm;
        }
        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
          vm.$parent.$el = vm.$el;
        }
      };
      Vue2.prototype.$forceUpdate = function() {
        const vm = this;
        if (vm._watcher) {
          vm._watcher.update();
        }
      };
      Vue2.prototype.$destroy = function() {
        const vm = this;
        if (vm._isBeingDestroyed) {
          return;
        }
        callHook$1(vm, "beforeDestroy");
        vm._isBeingDestroyed = true;
        const parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
          remove$2(parent.$children, vm);
        }
        vm._scope.stop();
        if (vm._data.__ob__) {
          vm._data.__ob__.vmCount--;
        }
        vm._isDestroyed = true;
        vm.__patch__(vm._vnode, null);
        callHook$1(vm, "destroyed");
        vm.$off();
        if (vm.$el) {
          vm.$el.__vue__ = null;
        }
        if (vm.$vnode) {
          vm.$vnode.parent = null;
        }
      };
    }
    function mountComponent(vm, el, hydrating) {
      vm.$el = el;
      if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode;
        {
          if (vm.$options.template && vm.$options.template.charAt(0) !== "#" || vm.$options.el || el) {
            warn("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm);
          } else {
            warn("Failed to mount component: template or render function not defined.", vm);
          }
        }
      }
      callHook$1(vm, "beforeMount");
      let updateComponent;
      if (config.performance && mark) {
        updateComponent = () => {
          const name = vm._name;
          const id = vm._uid;
          const startTag = `vue-perf-start:${id}`;
          const endTag = `vue-perf-end:${id}`;
          mark(startTag);
          const vnode = vm._render();
          mark(endTag);
          measure(`vue ${name} render`, startTag, endTag);
          mark(startTag);
          vm._update(vnode, hydrating);
          mark(endTag);
          measure(`vue ${name} patch`, startTag, endTag);
        };
      } else {
        updateComponent = () => {
          vm._update(vm._render(), hydrating);
        };
      }
      const watcherOptions = {
        before() {
          if (vm._isMounted && !vm._isDestroyed) {
            callHook$1(vm, "beforeUpdate");
          }
        }
      };
      {
        watcherOptions.onTrack = (e) => callHook$1(vm, "renderTracked", [e]);
        watcherOptions.onTrigger = (e) => callHook$1(vm, "renderTriggered", [e]);
      }
      new Watcher(vm, updateComponent, noop, watcherOptions, true);
      hydrating = false;
      const preWatchers = vm._preWatchers;
      if (preWatchers) {
        for (let i = 0; i < preWatchers.length; i++) {
          preWatchers[i].run();
        }
      }
      if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook$1(vm, "mounted");
      }
      return vm;
    }
    function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
      {
        isUpdatingChildComponent = true;
      }
      const newScopedSlots = parentVnode.data.scopedSlots;
      const oldScopedSlots = vm.$scopedSlots;
      const hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
      let needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
      const prevVNode = vm.$vnode;
      vm.$options._parentVnode = parentVnode;
      vm.$vnode = parentVnode;
      if (vm._vnode) {
        vm._vnode.parent = parentVnode;
      }
      vm.$options._renderChildren = renderChildren;
      const attrs2 = parentVnode.data.attrs || emptyObject;
      if (vm._attrsProxy) {
        if (syncSetupProxy(vm._attrsProxy, attrs2, prevVNode.data && prevVNode.data.attrs || emptyObject, vm, "$attrs")) {
          needsForceUpdate = true;
        }
      }
      vm.$attrs = attrs2;
      listeners = listeners || emptyObject;
      const prevListeners = vm.$options._parentListeners;
      if (vm._listenersProxy) {
        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, "$listeners");
      }
      vm.$listeners = vm.$options._parentListeners = listeners;
      updateComponentListeners(vm, listeners, prevListeners);
      if (propsData && vm.$options.props) {
        toggleObserving(false);
        const props2 = vm._props;
        const propKeys = vm.$options._propKeys || [];
        for (let i = 0; i < propKeys.length; i++) {
          const key = propKeys[i];
          const propOptions = vm.$options.props;
          props2[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        vm.$options.propsData = propsData;
      }
      if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
      }
      {
        isUpdatingChildComponent = false;
      }
    }
    function isInInactiveTree(vm) {
      while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
          return true;
      }
      return false;
    }
    function activateChildComponent(vm, direct) {
      if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
          return;
        }
      } else if (vm._directInactive) {
        return;
      }
      if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (let i = 0; i < vm.$children.length; i++) {
          activateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, "activated");
      }
    }
    function deactivateChildComponent(vm, direct) {
      if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
          return;
        }
      }
      if (!vm._inactive) {
        vm._inactive = true;
        for (let i = 0; i < vm.$children.length; i++) {
          deactivateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, "deactivated");
      }
    }
    function callHook$1(vm, hook, args, setContext = true) {
      pushTarget();
      const prev = currentInstance;
      setContext && setCurrentInstance(vm);
      const handlers = vm.$options[hook];
      const info = `${hook} hook`;
      if (handlers) {
        for (let i = 0, j = handlers.length; i < j; i++) {
          invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
        }
      }
      if (vm._hasHookEvent) {
        vm.$emit("hook:" + hook);
      }
      setContext && setCurrentInstance(prev);
      popTarget();
    }
    var MAX_UPDATE_COUNT = 100;
    var queue = [];
    var activatedChildren = [];
    var has = {};
    var circular = {};
    var waiting = false;
    var flushing = false;
    var index = 0;
    function resetSchedulerState() {
      index = queue.length = activatedChildren.length = 0;
      has = {};
      {
        circular = {};
      }
      waiting = flushing = false;
    }
    var currentFlushTimestamp = 0;
    var getNow = Date.now;
    if (inBrowser && !isIE) {
      const performance = window.performance;
      if (performance && typeof performance.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
        getNow = () => performance.now();
      }
    }
    var sortCompareFn = (a, b) => {
      if (a.post) {
        if (!b.post)
          return 1;
      } else if (b.post) {
        return -1;
      }
      return a.id - b.id;
    };
    function flushSchedulerQueue() {
      currentFlushTimestamp = getNow();
      flushing = true;
      let watcher, id;
      queue.sort(sortCompareFn);
      for (index = 0; index < queue.length; index++) {
        watcher = queue[index];
        if (watcher.before) {
          watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        if (has[id] != null) {
          circular[id] = (circular[id] || 0) + 1;
          if (circular[id] > MAX_UPDATE_COUNT) {
            warn("You may have an infinite update loop " + (watcher.user ? `in watcher with expression "${watcher.expression}"` : `in a component render function.`), watcher.vm);
            break;
          }
        }
      }
      const activatedQueue = activatedChildren.slice();
      const updatedQueue = queue.slice();
      resetSchedulerState();
      callActivatedHooks(activatedQueue);
      callUpdatedHooks(updatedQueue);
      if (devtools && config.devtools) {
        devtools.emit("flush");
      }
    }
    function callUpdatedHooks(queue2) {
      let i = queue2.length;
      while (i--) {
        const watcher = queue2[i];
        const vm = watcher.vm;
        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
          callHook$1(vm, "updated");
        }
      }
    }
    function queueActivatedComponent(vm) {
      vm._inactive = false;
      activatedChildren.push(vm);
    }
    function callActivatedHooks(queue2) {
      for (let i = 0; i < queue2.length; i++) {
        queue2[i]._inactive = true;
        activateChildComponent(queue2[i], true);
      }
    }
    function queueWatcher(watcher) {
      const id = watcher.id;
      if (has[id] != null) {
        return;
      }
      if (watcher === Dep.target && watcher.noRecurse) {
        return;
      }
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        let i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      if (!waiting) {
        waiting = true;
        if (!config.async) {
          flushSchedulerQueue();
          return;
        }
        nextTick(flushSchedulerQueue);
      }
    }
    function initProvide(vm) {
      const provideOption = vm.$options.provide;
      if (provideOption) {
        const provided = isFunction(provideOption) ? provideOption.call(vm) : provideOption;
        if (!isObject(provided)) {
          return;
        }
        const source = resolveProvided(vm);
        const keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
        }
      }
    }
    function initInjections(vm) {
      const result = resolveInject(vm.$options.inject, vm);
      if (result) {
        toggleObserving(false);
        Object.keys(result).forEach((key) => {
          {
            defineReactive(vm, key, result[key], () => {
              warn(`Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. injection being mutated: "${key}"`, vm);
            });
          }
        });
        toggleObserving(true);
      }
    }
    function resolveInject(inject2, vm) {
      if (inject2) {
        const result = /* @__PURE__ */ Object.create(null);
        const keys = hasSymbol ? Reflect.ownKeys(inject2) : Object.keys(inject2);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key === "__ob__")
            continue;
          const provideKey = inject2[key].from;
          if (provideKey in vm._provided) {
            result[key] = vm._provided[provideKey];
          } else if ("default" in inject2[key]) {
            const provideDefault = inject2[key].default;
            result[key] = isFunction(provideDefault) ? provideDefault.call(vm) : provideDefault;
          } else {
            warn(`Injection "${key}" not found`, vm);
          }
        }
        return result;
      }
    }
    function FunctionalRenderContext(data, props2, children, parent, Ctor) {
      const options = Ctor.options;
      let contextVm;
      if (hasOwn(parent, "_uid")) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
      } else {
        contextVm = parent;
        parent = parent._original;
      }
      const isCompiled = isTrue(options._compiled);
      const needNormalization = !isCompiled;
      this.data = data;
      this.props = props2;
      this.children = children;
      this.parent = parent;
      this.listeners = data.on || emptyObject;
      this.injections = resolveInject(options.inject, parent);
      this.slots = () => {
        if (!this.$slots) {
          normalizeScopedSlots(parent, data.scopedSlots, this.$slots = resolveSlots(children, parent));
        }
        return this.$slots;
      };
      Object.defineProperty(this, "scopedSlots", {
        enumerable: true,
        get() {
          return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
        }
      });
      if (isCompiled) {
        this.$options = options;
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
      }
      if (options._scopeId) {
        this._c = (a, b, c, d) => {
          const vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
          if (vnode && !isArray(vnode)) {
            vnode.fnScopeId = options._scopeId;
            vnode.fnContext = parent;
          }
          return vnode;
        };
      } else {
        this._c = (a, b, c, d) => createElement$1(contextVm, a, b, c, d, needNormalization);
      }
    }
    installRenderHelpers(FunctionalRenderContext.prototype);
    function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
      const options = Ctor.options;
      const props2 = {};
      const propOptions = options.props;
      if (isDef(propOptions)) {
        for (const key in propOptions) {
          props2[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
      } else {
        if (isDef(data.attrs))
          mergeProps(props2, data.attrs);
        if (isDef(data.props))
          mergeProps(props2, data.props);
      }
      const renderContext = new FunctionalRenderContext(data, props2, children, contextVm, Ctor);
      const vnode = options.render.call(null, renderContext._c, renderContext);
      if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
      } else if (isArray(vnode)) {
        const vnodes = normalizeChildren(vnode) || [];
        const res = new Array(vnodes.length);
        for (let i = 0; i < vnodes.length; i++) {
          res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
      }
    }
    function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
      const clone = cloneVNode(vnode);
      clone.fnContext = contextVm;
      clone.fnOptions = options;
      {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
      }
      if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
      }
      return clone;
    }
    function mergeProps(to, from) {
      for (const key in from) {
        to[camelize(key)] = from[key];
      }
    }
    function getComponentName(options) {
      return options.name || options.__name || options._componentTag;
    }
    var componentVNodeHooks = {
      init(vnode, hydrating) {
        if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
          const mountedNode = vnode;
          componentVNodeHooks.prepatch(mountedNode, mountedNode);
        } else {
          const child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
          child.$mount(hydrating ? vnode.elm : void 0, hydrating);
        }
      },
      prepatch(oldVnode, vnode) {
        const options = vnode.componentOptions;
        const child = vnode.componentInstance = oldVnode.componentInstance;
        updateChildComponent(child, options.propsData, options.listeners, vnode, options.children);
      },
      insert(vnode) {
        const { context, componentInstance } = vnode;
        if (!componentInstance._isMounted) {
          componentInstance._isMounted = true;
          callHook$1(componentInstance, "mounted");
        }
        if (vnode.data.keepAlive) {
          if (context._isMounted) {
            queueActivatedComponent(componentInstance);
          } else {
            activateChildComponent(componentInstance, true);
          }
        }
      },
      destroy(vnode) {
        const { componentInstance } = vnode;
        if (!componentInstance._isDestroyed) {
          if (!vnode.data.keepAlive) {
            componentInstance.$destroy();
          } else {
            deactivateChildComponent(componentInstance, true);
          }
        }
      }
    };
    var hooksToMerge = Object.keys(componentVNodeHooks);
    function createComponent(Ctor, data, context, children, tag) {
      if (isUndef(Ctor)) {
        return;
      }
      const baseCtor = context.$options._base;
      if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
      }
      if (typeof Ctor !== "function") {
        {
          warn(`Invalid Component definition: ${String(Ctor)}`, context);
        }
        return;
      }
      let asyncFactory;
      if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === void 0) {
          return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
        }
      }
      data = data || {};
      resolveConstructorOptions(Ctor);
      if (isDef(data.model)) {
        transformModel(Ctor.options, data);
      }
      const propsData = extractPropsFromVNodeData(data, Ctor, tag);
      if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children);
      }
      const listeners = data.on;
      data.on = data.nativeOn;
      if (isTrue(Ctor.options.abstract)) {
        const slot = data.slot;
        data = {};
        if (slot) {
          data.slot = slot;
        }
      }
      installComponentHooks(data);
      const name = getComponentName(Ctor.options) || tag;
      const vnode = new VNode(`vue-component-${Ctor.cid}${name ? `-${name}` : ""}`, data, void 0, void 0, void 0, context, { Ctor, propsData, listeners, tag, children }, asyncFactory);
      return vnode;
    }
    function createComponentInstanceForVnode(vnode, parent) {
      const options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent
      };
      const inlineTemplate = vnode.data.inlineTemplate;
      if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
      }
      return new vnode.componentOptions.Ctor(options);
    }
    function installComponentHooks(data) {
      const hooks2 = data.hook || (data.hook = {});
      for (let i = 0; i < hooksToMerge.length; i++) {
        const key = hooksToMerge[i];
        const existing = hooks2[key];
        const toMerge = componentVNodeHooks[key];
        if (existing !== toMerge && !(existing && existing._merged)) {
          hooks2[key] = existing ? mergeHook(toMerge, existing) : toMerge;
        }
      }
    }
    function mergeHook(f1, f2) {
      const merged = (a, b) => {
        f1(a, b);
        f2(a, b);
      };
      merged._merged = true;
      return merged;
    }
    function transformModel(options, data) {
      const prop = options.model && options.model.prop || "value";
      const event = options.model && options.model.event || "input";
      (data.attrs || (data.attrs = {}))[prop] = data.model.value;
      const on = data.on || (data.on = {});
      const existing = on[event];
      const callback = data.model.callback;
      if (isDef(existing)) {
        if (isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
          on[event] = [callback].concat(existing);
        }
      } else {
        on[event] = callback;
      }
    }
    var warn = noop;
    var tip = noop;
    var generateComponentTrace;
    var formatComponentName;
    {
      const hasConsole = typeof console !== "undefined";
      const classifyRE = /(?:^|[-_])(\w)/g;
      const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
      warn = (msg, vm = currentInstance) => {
        const trace = vm ? generateComponentTrace(vm) : "";
        if (config.warnHandler) {
          config.warnHandler.call(null, msg, vm, trace);
        } else if (hasConsole && !config.silent) {
          console.error(`[Vue warn]: ${msg}${trace}`);
        }
      };
      tip = (msg, vm) => {
        if (hasConsole && !config.silent) {
          console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ""));
        }
      };
      formatComponentName = (vm, includeFile) => {
        if (vm.$root === vm) {
          return "<Root>";
        }
        const options = isFunction(vm) && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
        let name = getComponentName(options);
        const file = options.__file;
        if (!name && file) {
          const match = file.match(/([^/\\]+)\.vue$/);
          name = match && match[1];
        }
        return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : "");
      };
      const repeat = (str, n) => {
        let res = "";
        while (n) {
          if (n % 2 === 1)
            res += str;
          if (n > 1)
            str += str;
          n >>= 1;
        }
        return res;
      };
      generateComponentTrace = (vm) => {
        if (vm._isVue && vm.$parent) {
          const tree = [];
          let currentRecursiveSequence = 0;
          while (vm) {
            if (tree.length > 0) {
              const last = tree[tree.length - 1];
              if (last.constructor === vm.constructor) {
                currentRecursiveSequence++;
                vm = vm.$parent;
                continue;
              } else if (currentRecursiveSequence > 0) {
                tree[tree.length - 1] = [last, currentRecursiveSequence];
                currentRecursiveSequence = 0;
              }
            }
            tree.push(vm);
            vm = vm.$parent;
          }
          return "\n\nfound in\n\n" + tree.map((vm2, i) => `${i === 0 ? "---> " : repeat(" ", 5 + i * 2)}${isArray(vm2) ? `${formatComponentName(vm2[0])}... (${vm2[1]} recursive calls)` : formatComponentName(vm2)}`).join("\n");
        } else {
          return `

(found in ${formatComponentName(vm)})`;
        }
      };
    }
    var strats = config.optionMergeStrategies;
    {
      strats.el = strats.propsData = function(parent, child, vm, key) {
        if (!vm) {
          warn(`option "${key}" can only be used during instance creation with the \`new\` keyword.`);
        }
        return defaultStrat(parent, child);
      };
    }
    function mergeData(to, from) {
      if (!from)
        return to;
      let key, toVal, fromVal;
      const keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
      for (let i = 0; i < keys.length; i++) {
        key = keys[i];
        if (key === "__ob__")
          continue;
        toVal = to[key];
        fromVal = from[key];
        if (!hasOwn(to, key)) {
          set(to, key, fromVal);
        } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
          mergeData(toVal, fromVal);
        }
      }
      return to;
    }
    function mergeDataOrFn(parentVal, childVal, vm) {
      if (!vm) {
        if (!childVal) {
          return parentVal;
        }
        if (!parentVal) {
          return childVal;
        }
        return function mergedDataFn() {
          return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
        };
      } else {
        return function mergedInstanceDataFn() {
          const instanceData = isFunction(childVal) ? childVal.call(vm, vm) : childVal;
          const defaultData = isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal;
          if (instanceData) {
            return mergeData(instanceData, defaultData);
          } else {
            return defaultData;
          }
        };
      }
    }
    strats.data = function(parentVal, childVal, vm) {
      if (!vm) {
        if (childVal && typeof childVal !== "function") {
          warn('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
          return parentVal;
        }
        return mergeDataOrFn(parentVal, childVal);
      }
      return mergeDataOrFn(parentVal, childVal, vm);
    };
    function mergeLifecycleHook(parentVal, childVal) {
      const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
      return res ? dedupeHooks(res) : res;
    }
    function dedupeHooks(hooks2) {
      const res = [];
      for (let i = 0; i < hooks2.length; i++) {
        if (res.indexOf(hooks2[i]) === -1) {
          res.push(hooks2[i]);
        }
      }
      return res;
    }
    LIFECYCLE_HOOKS.forEach((hook) => {
      strats[hook] = mergeLifecycleHook;
    });
    function mergeAssets(parentVal, childVal, vm, key) {
      const res = Object.create(parentVal || null);
      if (childVal) {
        assertObjectType(key, childVal, vm);
        return extend(res, childVal);
      } else {
        return res;
      }
    }
    ASSET_TYPES.forEach(function(type) {
      strats[type + "s"] = mergeAssets;
    });
    strats.watch = function(parentVal, childVal, vm, key) {
      if (parentVal === nativeWatch)
        parentVal = void 0;
      if (childVal === nativeWatch)
        childVal = void 0;
      if (!childVal)
        return Object.create(parentVal || null);
      {
        assertObjectType(key, childVal, vm);
      }
      if (!parentVal)
        return childVal;
      const ret = {};
      extend(ret, parentVal);
      for (const key2 in childVal) {
        let parent = ret[key2];
        const child = childVal[key2];
        if (parent && !isArray(parent)) {
          parent = [parent];
        }
        ret[key2] = parent ? parent.concat(child) : isArray(child) ? child : [child];
      }
      return ret;
    };
    strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
      if (childVal && true) {
        assertObjectType(key, childVal, vm);
      }
      if (!parentVal)
        return childVal;
      const ret = /* @__PURE__ */ Object.create(null);
      extend(ret, parentVal);
      if (childVal)
        extend(ret, childVal);
      return ret;
    };
    strats.provide = mergeDataOrFn;
    var defaultStrat = function(parentVal, childVal) {
      return childVal === void 0 ? parentVal : childVal;
    };
    function checkComponents(options) {
      for (const key in options.components) {
        validateComponentName(key);
      }
    }
    function validateComponentName(name) {
      if (!new RegExp(`^[a-zA-Z][\\-\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {
        warn('Invalid component name: "' + name + '". Component names should conform to valid custom element name in html5 specification.');
      }
      if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn("Do not use built-in or reserved HTML elements as component id: " + name);
      }
    }
    function normalizeProps(options, vm) {
      const props2 = options.props;
      if (!props2)
        return;
      const res = {};
      let i, val, name;
      if (isArray(props2)) {
        i = props2.length;
        while (i--) {
          val = props2[i];
          if (typeof val === "string") {
            name = camelize(val);
            res[name] = { type: null };
          } else {
            warn("props must be strings when using array syntax.");
          }
        }
      } else if (isPlainObject(props2)) {
        for (const key in props2) {
          val = props2[key];
          name = camelize(key);
          res[name] = isPlainObject(val) ? val : { type: val };
        }
      } else {
        warn(`Invalid value for option "props": expected an Array or an Object, but got ${toRawType(props2)}.`, vm);
      }
      options.props = res;
    }
    function normalizeInject(options, vm) {
      const inject2 = options.inject;
      if (!inject2)
        return;
      const normalized = options.inject = {};
      if (isArray(inject2)) {
        for (let i = 0; i < inject2.length; i++) {
          normalized[inject2[i]] = { from: inject2[i] };
        }
      } else if (isPlainObject(inject2)) {
        for (const key in inject2) {
          const val = inject2[key];
          normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
        }
      } else {
        warn(`Invalid value for option "inject": expected an Array or an Object, but got ${toRawType(inject2)}.`, vm);
      }
    }
    function normalizeDirectives$1(options) {
      const dirs = options.directives;
      if (dirs) {
        for (const key in dirs) {
          const def2 = dirs[key];
          if (isFunction(def2)) {
            dirs[key] = { bind: def2, update: def2 };
          }
        }
      }
    }
    function assertObjectType(name, value, vm) {
      if (!isPlainObject(value)) {
        warn(`Invalid value for option "${name}": expected an Object, but got ${toRawType(value)}.`, vm);
      }
    }
    function mergeOptions(parent, child, vm) {
      {
        checkComponents(child);
      }
      if (isFunction(child)) {
        child = child.options;
      }
      normalizeProps(child, vm);
      normalizeInject(child, vm);
      normalizeDirectives$1(child);
      if (!child._base) {
        if (child.extends) {
          parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
          for (let i = 0, l = child.mixins.length; i < l; i++) {
            parent = mergeOptions(parent, child.mixins[i], vm);
          }
        }
      }
      const options = {};
      let key;
      for (key in parent) {
        mergeField(key);
      }
      for (key in child) {
        if (!hasOwn(parent, key)) {
          mergeField(key);
        }
      }
      function mergeField(key2) {
        const strat = strats[key2] || defaultStrat;
        options[key2] = strat(parent[key2], child[key2], vm, key2);
      }
      return options;
    }
    function resolveAsset(options, type, id, warnMissing) {
      if (typeof id !== "string") {
        return;
      }
      const assets = options[type];
      if (hasOwn(assets, id))
        return assets[id];
      const camelizedId = camelize(id);
      if (hasOwn(assets, camelizedId))
        return assets[camelizedId];
      const PascalCaseId = capitalize(camelizedId);
      if (hasOwn(assets, PascalCaseId))
        return assets[PascalCaseId];
      const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
      if (warnMissing && !res) {
        warn("Failed to resolve " + type.slice(0, -1) + ": " + id);
      }
      return res;
    }
    function validateProp(key, propOptions, propsData, vm) {
      const prop = propOptions[key];
      const absent = !hasOwn(propsData, key);
      let value = propsData[key];
      const booleanIndex = getTypeIndex(Boolean, prop.type);
      if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, "default")) {
          value = false;
        } else if (value === "" || value === hyphenate(key)) {
          const stringIndex = getTypeIndex(String, prop.type);
          if (stringIndex < 0 || booleanIndex < stringIndex) {
            value = true;
          }
        }
      }
      if (value === void 0) {
        value = getPropDefaultValue(vm, prop, key);
        const prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
      }
      {
        assertProp(prop, key, value, vm, absent);
      }
      return value;
    }
    function getPropDefaultValue(vm, prop, key) {
      if (!hasOwn(prop, "default")) {
        return void 0;
      }
      const def2 = prop.default;
      if (isObject(def2)) {
        warn('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
      }
      if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
        return vm._props[key];
      }
      return isFunction(def2) && getType(prop.type) !== "Function" ? def2.call(vm) : def2;
    }
    function assertProp(prop, name, value, vm, absent) {
      if (prop.required && absent) {
        warn('Missing required prop: "' + name + '"', vm);
        return;
      }
      if (value == null && !prop.required) {
        return;
      }
      let type = prop.type;
      let valid = !type || type === true;
      const expectedTypes = [];
      if (type) {
        if (!isArray(type)) {
          type = [type];
        }
        for (let i = 0; i < type.length && !valid; i++) {
          const assertedType = assertType(value, type[i], vm);
          expectedTypes.push(assertedType.expectedType || "");
          valid = assertedType.valid;
        }
      }
      const haveExpectedTypes = expectedTypes.some((t) => t);
      if (!valid && haveExpectedTypes) {
        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
        return;
      }
      const validator = prop.validator;
      if (validator) {
        if (!validator(value)) {
          warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
      }
    }
    var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
    function assertType(value, type, vm) {
      let valid;
      const expectedType = getType(type);
      if (simpleCheckRE.test(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") {
          valid = value instanceof type;
        }
      } else if (expectedType === "Object") {
        valid = isPlainObject(value);
      } else if (expectedType === "Array") {
        valid = isArray(value);
      } else {
        try {
          valid = value instanceof type;
        } catch (e) {
          warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
          valid = false;
        }
      }
      return {
        valid,
        expectedType
      };
    }
    var functionTypeCheckRE = /^\s*function (\w+)/;
    function getType(fn) {
      const match = fn && fn.toString().match(functionTypeCheckRE);
      return match ? match[1] : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (!isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      for (let i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
          return i;
        }
      }
      return -1;
    }
    function getInvalidTypeMessage(name, value, expectedTypes) {
      let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(", ")}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType(value);
      if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
        message += ` with value ${styleValue(value, expectedType)}`;
      }
      message += `, got ${receivedType} `;
      if (isExplicable(receivedType)) {
        message += `with value ${styleValue(value, receivedType)}.`;
      }
      return message;
    }
    function styleValue(value, type) {
      if (type === "String") {
        return `"${value}"`;
      } else if (type === "Number") {
        return `${Number(value)}`;
      } else {
        return `${value}`;
      }
    }
    var EXPLICABLE_TYPES = ["string", "number", "boolean"];
    function isExplicable(value) {
      return EXPLICABLE_TYPES.some((elem) => value.toLowerCase() === elem);
    }
    function isBoolean(...args) {
      return args.some((elem) => elem.toLowerCase() === "boolean");
    }
    var initProxy;
    {
      const allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,require");
      const warnNonPresent = (target2, key) => {
        warn(`Property or method "${key}" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.`, target2);
      };
      const warnReservedPrefix = (target2, key) => {
        warn(`Property "${key}" must be accessed with "$data.${key}" because properties starting with "$" or "_" are not proxied in the Vue instance to prevent conflicts with Vue internals. See: https://v2.vuejs.org/v2/api/#data`, target2);
      };
      const hasProxy = typeof Proxy !== "undefined" && isNative(Proxy);
      if (hasProxy) {
        const isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
        config.keyCodes = new Proxy(config.keyCodes, {
          set(target2, key, value) {
            if (isBuiltInModifier(key)) {
              warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);
              return false;
            } else {
              target2[key] = value;
              return true;
            }
          }
        });
      }
      const hasHandler = {
        has(target2, key) {
          const has2 = key in target2;
          const isAllowed = allowedGlobals(key) || typeof key === "string" && key.charAt(0) === "_" && !(key in target2.$data);
          if (!has2 && !isAllowed) {
            if (key in target2.$data)
              warnReservedPrefix(target2, key);
            else
              warnNonPresent(target2, key);
          }
          return has2 || !isAllowed;
        }
      };
      const getHandler = {
        get(target2, key) {
          if (typeof key === "string" && !(key in target2)) {
            if (key in target2.$data)
              warnReservedPrefix(target2, key);
            else
              warnNonPresent(target2, key);
          }
          return target2[key];
        }
      };
      initProxy = function initProxy2(vm) {
        if (hasProxy) {
          const options = vm.$options;
          const handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
          vm._renderProxy = new Proxy(vm, handlers);
        } else {
          vm._renderProxy = vm;
        }
      };
    }
    var sharedPropertyDefinition = {
      enumerable: true,
      configurable: true,
      get: noop,
      set: noop
    };
    function proxy(target2, sourceKey, key) {
      sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key];
      };
      sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val;
      };
      Object.defineProperty(target2, key, sharedPropertyDefinition);
    }
    function initState(vm) {
      const opts = vm.$options;
      if (opts.props)
        initProps$1(vm, opts.props);
      initSetup(vm);
      if (opts.methods)
        initMethods(vm, opts.methods);
      if (opts.data) {
        initData(vm);
      } else {
        const ob = observe(vm._data = {});
        ob && ob.vmCount++;
      }
      if (opts.computed)
        initComputed$1(vm, opts.computed);
      if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
      }
    }
    function initProps$1(vm, propsOptions) {
      const propsData = vm.$options.propsData || {};
      const props2 = vm._props = shallowReactive({});
      const keys = vm.$options._propKeys = [];
      const isRoot = !vm.$parent;
      if (!isRoot) {
        toggleObserving(false);
      }
      for (const key in propsOptions) {
        keys.push(key);
        const value = validateProp(key, propsOptions, propsData, vm);
        {
          const hyphenatedKey = hyphenate(key);
          if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
            warn(`"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`, vm);
          }
          defineReactive(props2, key, value, () => {
            if (!isRoot && !isUpdatingChildComponent) {
              warn(`Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "${key}"`, vm);
            }
          });
        }
        if (!(key in vm)) {
          proxy(vm, `_props`, key);
        }
      }
      toggleObserving(true);
    }
    function initData(vm) {
      let data = vm.$options.data;
      data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
      if (!isPlainObject(data)) {
        data = {};
        warn("data functions should return an object:\nhttps://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
      }
      const keys = Object.keys(data);
      const props2 = vm.$options.props;
      const methods = vm.$options.methods;
      let i = keys.length;
      while (i--) {
        const key = keys[i];
        {
          if (methods && hasOwn(methods, key)) {
            warn(`Method "${key}" has already been defined as a data property.`, vm);
          }
        }
        if (props2 && hasOwn(props2, key)) {
          warn(`The data property "${key}" is already declared as a prop. Use prop default value instead.`, vm);
        } else if (!isReserved(key)) {
          proxy(vm, `_data`, key);
        }
      }
      const ob = observe(data);
      ob && ob.vmCount++;
    }
    function getData(data, vm) {
      pushTarget();
      try {
        return data.call(vm, vm);
      } catch (e) {
        handleError(e, vm, `data()`);
        return {};
      } finally {
        popTarget();
      }
    }
    var computedWatcherOptions = { lazy: true };
    function initComputed$1(vm, computed2) {
      const watchers = vm._computedWatchers = /* @__PURE__ */ Object.create(null);
      const isSSR = isServerRendering();
      for (const key in computed2) {
        const userDef = computed2[key];
        const getter = isFunction(userDef) ? userDef : userDef.get;
        if (getter == null) {
          warn(`Getter is missing for computed property "${key}".`, vm);
        }
        if (!isSSR) {
          watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
        }
        if (!(key in vm)) {
          defineComputed(vm, key, userDef);
        } else {
          if (key in vm.$data) {
            warn(`The computed property "${key}" is already defined in data.`, vm);
          } else if (vm.$options.props && key in vm.$options.props) {
            warn(`The computed property "${key}" is already defined as a prop.`, vm);
          } else if (vm.$options.methods && key in vm.$options.methods) {
            warn(`The computed property "${key}" is already defined as a method.`, vm);
          }
        }
      }
    }
    function defineComputed(target2, key, userDef) {
      const shouldCache = !isServerRendering();
      if (isFunction(userDef)) {
        sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop;
      } else {
        sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
        sharedPropertyDefinition.set = userDef.set || noop;
      }
      if (sharedPropertyDefinition.set === noop) {
        sharedPropertyDefinition.set = function() {
          warn(`Computed property "${key}" was assigned to but it has no setter.`, this);
        };
      }
      Object.defineProperty(target2, key, sharedPropertyDefinition);
    }
    function createComputedGetter(key) {
      return function computedGetter() {
        const watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
          if (watcher.dirty) {
            watcher.evaluate();
          }
          if (Dep.target) {
            if (Dep.target.onTrack) {
              Dep.target.onTrack({
                effect: Dep.target,
                target: this,
                type: "get",
                key
              });
            }
            watcher.depend();
          }
          return watcher.value;
        }
      };
    }
    function createGetterInvoker(fn) {
      return function computedGetter() {
        return fn.call(this, this);
      };
    }
    function initMethods(vm, methods) {
      const props2 = vm.$options.props;
      for (const key in methods) {
        {
          if (typeof methods[key] !== "function") {
            warn(`Method "${key}" has type "${typeof methods[key]}" in the component definition. Did you reference the function correctly?`, vm);
          }
          if (props2 && hasOwn(props2, key)) {
            warn(`Method "${key}" has already been defined as a prop.`, vm);
          }
          if (key in vm && isReserved(key)) {
            warn(`Method "${key}" conflicts with an existing Vue instance method. Avoid defining component methods that start with _ or $.`);
          }
        }
        vm[key] = typeof methods[key] !== "function" ? noop : bind(methods[key], vm);
      }
    }
    function initWatch(vm, watch2) {
      for (const key in watch2) {
        const handler = watch2[key];
        if (isArray(handler)) {
          for (let i = 0; i < handler.length; i++) {
            createWatcher(vm, key, handler[i]);
          }
        } else {
          createWatcher(vm, key, handler);
        }
      }
    }
    function createWatcher(vm, expOrFn, handler, options) {
      if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
      }
      if (typeof handler === "string") {
        handler = vm[handler];
      }
      return vm.$watch(expOrFn, handler, options);
    }
    function stateMixin(Vue2) {
      const dataDef = {};
      dataDef.get = function() {
        return this._data;
      };
      const propsDef = {};
      propsDef.get = function() {
        return this._props;
      };
      {
        dataDef.set = function() {
          warn("Avoid replacing instance root $data. Use nested data properties instead.", this);
        };
        propsDef.set = function() {
          warn(`$props is readonly.`, this);
        };
      }
      Object.defineProperty(Vue2.prototype, "$data", dataDef);
      Object.defineProperty(Vue2.prototype, "$props", propsDef);
      Vue2.prototype.$set = set;
      Vue2.prototype.$delete = del;
      Vue2.prototype.$watch = function(expOrFn, cb, options) {
        const vm = this;
        if (isPlainObject(cb)) {
          return createWatcher(vm, expOrFn, cb, options);
        }
        options = options || {};
        options.user = true;
        const watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
          const info = `callback for immediate watcher "${watcher.expression}"`;
          pushTarget();
          invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
          popTarget();
        }
        return function unwatchFn() {
          watcher.teardown();
        };
      };
    }
    var uid = 0;
    function initMixin$1(Vue2) {
      Vue2.prototype._init = function(options) {
        const vm = this;
        vm._uid = uid++;
        let startTag, endTag;
        if (config.performance && mark) {
          startTag = `vue-perf-start:${vm._uid}`;
          endTag = `vue-perf-end:${vm._uid}`;
          mark(startTag);
        }
        vm._isVue = true;
        vm.__v_skip = true;
        vm._scope = new EffectScope(true);
        vm._scope._vm = true;
        if (options && options._isComponent) {
          initInternalComponent(vm, options);
        } else {
          vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
        }
        {
          initProxy(vm);
        }
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook$1(vm, "beforeCreate", void 0, false);
        initInjections(vm);
        initState(vm);
        initProvide(vm);
        callHook$1(vm, "created");
        if (config.performance && mark) {
          vm._name = formatComponentName(vm, false);
          mark(endTag);
          measure(`vue ${vm._name} init`, startTag, endTag);
        }
        if (vm.$options.el) {
          vm.$mount(vm.$options.el);
        }
      };
    }
    function initInternalComponent(vm, options) {
      const opts = vm.$options = Object.create(vm.constructor.options);
      const parentVnode = options._parentVnode;
      opts.parent = options.parent;
      opts._parentVnode = parentVnode;
      const vnodeComponentOptions = parentVnode.componentOptions;
      opts.propsData = vnodeComponentOptions.propsData;
      opts._parentListeners = vnodeComponentOptions.listeners;
      opts._renderChildren = vnodeComponentOptions.children;
      opts._componentTag = vnodeComponentOptions.tag;
      if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
      }
    }
    function resolveConstructorOptions(Ctor) {
      let options = Ctor.options;
      if (Ctor.super) {
        const superOptions = resolveConstructorOptions(Ctor.super);
        const cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
          Ctor.superOptions = superOptions;
          const modifiedOptions = resolveModifiedOptions(Ctor);
          if (modifiedOptions) {
            extend(Ctor.extendOptions, modifiedOptions);
          }
          options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
          if (options.name) {
            options.components[options.name] = Ctor;
          }
        }
      }
      return options;
    }
    function resolveModifiedOptions(Ctor) {
      let modified;
      const latest = Ctor.options;
      const sealed = Ctor.sealedOptions;
      for (const key in latest) {
        if (latest[key] !== sealed[key]) {
          if (!modified)
            modified = {};
          modified[key] = latest[key];
        }
      }
      return modified;
    }
    function Vue(options) {
      if (!(this instanceof Vue)) {
        warn("Vue is a constructor and should be called with the `new` keyword");
      }
      this._init(options);
    }
    initMixin$1(Vue);
    stateMixin(Vue);
    eventsMixin(Vue);
    lifecycleMixin(Vue);
    renderMixin(Vue);
    function initUse(Vue2) {
      Vue2.use = function(plugin) {
        const installedPlugins = this._installedPlugins || (this._installedPlugins = []);
        if (installedPlugins.indexOf(plugin) > -1) {
          return this;
        }
        const args = toArray(arguments, 1);
        args.unshift(this);
        if (isFunction(plugin.install)) {
          plugin.install.apply(plugin, args);
        } else if (isFunction(plugin)) {
          plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this;
      };
    }
    function initMixin(Vue2) {
      Vue2.mixin = function(mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this;
      };
    }
    function initExtend(Vue2) {
      Vue2.cid = 0;
      let cid = 1;
      Vue2.extend = function(extendOptions) {
        extendOptions = extendOptions || {};
        const Super = this;
        const SuperId = Super.cid;
        const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
          return cachedCtors[SuperId];
        }
        const name = getComponentName(extendOptions) || getComponentName(Super.options);
        if (name) {
          validateComponentName(name);
        }
        const Sub = function VueComponent(options) {
          this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub["super"] = Super;
        if (Sub.options.props) {
          initProps(Sub);
        }
        if (Sub.options.computed) {
          initComputed(Sub);
        }
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;
        ASSET_TYPES.forEach(function(type) {
          Sub[type] = Super[type];
        });
        if (name) {
          Sub.options.components[name] = Sub;
        }
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend({}, Sub.options);
        cachedCtors[SuperId] = Sub;
        return Sub;
      };
    }
    function initProps(Comp) {
      const props2 = Comp.options.props;
      for (const key in props2) {
        proxy(Comp.prototype, `_props`, key);
      }
    }
    function initComputed(Comp) {
      const computed2 = Comp.options.computed;
      for (const key in computed2) {
        defineComputed(Comp.prototype, key, computed2[key]);
      }
    }
    function initAssetRegisters(Vue2) {
      ASSET_TYPES.forEach((type) => {
        Vue2[type] = function(id, definition) {
          if (!definition) {
            return this.options[type + "s"][id];
          } else {
            if (type === "component") {
              validateComponentName(id);
            }
            if (type === "component" && isPlainObject(definition)) {
              definition.name = definition.name || id;
              definition = this.options._base.extend(definition);
            }
            if (type === "directive" && isFunction(definition)) {
              definition = { bind: definition, update: definition };
            }
            this.options[type + "s"][id] = definition;
            return definition;
          }
        };
      });
    }
    function _getComponentName(opts) {
      return opts && (getComponentName(opts.Ctor.options) || opts.tag);
    }
    function matches(pattern, name) {
      if (isArray(pattern)) {
        return pattern.indexOf(name) > -1;
      } else if (typeof pattern === "string") {
        return pattern.split(",").indexOf(name) > -1;
      } else if (isRegExp(pattern)) {
        return pattern.test(name);
      }
      return false;
    }
    function pruneCache(keepAliveInstance, filter) {
      const { cache, keys, _vnode } = keepAliveInstance;
      for (const key in cache) {
        const entry = cache[key];
        if (entry) {
          const name = entry.name;
          if (name && !filter(name)) {
            pruneCacheEntry(cache, key, keys, _vnode);
          }
        }
      }
    }
    function pruneCacheEntry(cache, key, keys, current) {
      const entry = cache[key];
      if (entry && (!current || entry.tag !== current.tag)) {
        entry.componentInstance.$destroy();
      }
      cache[key] = null;
      remove$2(keys, key);
    }
    var patternTypes = [String, RegExp, Array];
    var KeepAlive = {
      name: "keep-alive",
      abstract: true,
      props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
      },
      methods: {
        cacheVNode() {
          const { cache, keys, vnodeToCache, keyToCache } = this;
          if (vnodeToCache) {
            const { tag, componentInstance, componentOptions } = vnodeToCache;
            cache[keyToCache] = {
              name: _getComponentName(componentOptions),
              tag,
              componentInstance
            };
            keys.push(keyToCache);
            if (this.max && keys.length > parseInt(this.max)) {
              pruneCacheEntry(cache, keys[0], keys, this._vnode);
            }
            this.vnodeToCache = null;
          }
        }
      },
      created() {
        this.cache = /* @__PURE__ */ Object.create(null);
        this.keys = [];
      },
      destroyed() {
        for (const key in this.cache) {
          pruneCacheEntry(this.cache, key, this.keys);
        }
      },
      mounted() {
        this.cacheVNode();
        this.$watch("include", (val) => {
          pruneCache(this, (name) => matches(val, name));
        });
        this.$watch("exclude", (val) => {
          pruneCache(this, (name) => !matches(val, name));
        });
      },
      updated() {
        this.cacheVNode();
      },
      render() {
        const slot = this.$slots.default;
        const vnode = getFirstComponentChild(slot);
        const componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
          const name = _getComponentName(componentOptions);
          const { include, exclude } = this;
          if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
            return vnode;
          }
          const { cache, keys } = this;
          const key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : "") : vnode.key;
          if (cache[key]) {
            vnode.componentInstance = cache[key].componentInstance;
            remove$2(keys, key);
            keys.push(key);
          } else {
            this.vnodeToCache = vnode;
            this.keyToCache = key;
          }
          vnode.data.keepAlive = true;
        }
        return vnode || slot && slot[0];
      }
    };
    var builtInComponents = {
      KeepAlive
    };
    function initGlobalAPI(Vue2) {
      const configDef = {};
      configDef.get = () => config;
      {
        configDef.set = () => {
          warn("Do not replace the Vue.config object, set individual fields instead.");
        };
      }
      Object.defineProperty(Vue2, "config", configDef);
      Vue2.util = {
        warn,
        extend,
        mergeOptions,
        defineReactive
      };
      Vue2.set = set;
      Vue2.delete = del;
      Vue2.nextTick = nextTick;
      Vue2.observable = (obj) => {
        observe(obj);
        return obj;
      };
      Vue2.options = /* @__PURE__ */ Object.create(null);
      ASSET_TYPES.forEach((type) => {
        Vue2.options[type + "s"] = /* @__PURE__ */ Object.create(null);
      });
      Vue2.options._base = Vue2;
      extend(Vue2.options.components, builtInComponents);
      initUse(Vue2);
      initMixin(Vue2);
      initExtend(Vue2);
      initAssetRegisters(Vue2);
    }
    initGlobalAPI(Vue);
    Object.defineProperty(Vue.prototype, "$isServer", {
      get: isServerRendering
    });
    Object.defineProperty(Vue.prototype, "$ssrContext", {
      get() {
        return this.$vnode && this.$vnode.ssrContext;
      }
    });
    Object.defineProperty(Vue, "FunctionalRenderContext", {
      value: FunctionalRenderContext
    });
    Vue.version = version;
    var isReservedAttr = makeMap("style,class");
    var acceptValue = makeMap("input,textarea,option,select,progress");
    var mustUseProp = (tag, type, attr) => {
      return attr === "value" && acceptValue(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
    };
    var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
    var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
    var convertEnumeratedValue = (key, value) => {
      return isFalsyAttrValue(value) || value === "false" ? "false" : key === "contenteditable" && isValidContentEditableValue(value) ? value : "true";
    };
    var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
    var xlinkNS = "http://www.w3.org/1999/xlink";
    var isXlink = (name) => {
      return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
    };
    var getXlinkProp = (name) => {
      return isXlink(name) ? name.slice(6, name.length) : "";
    };
    var isFalsyAttrValue = (val) => {
      return val == null || val === false;
    };
    function genClassForVnode(vnode) {
      let data = vnode.data;
      let parentNode2 = vnode;
      let childNode = vnode;
      while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
          data = mergeClassData(childNode.data, data);
        }
      }
      while (isDef(parentNode2 = parentNode2.parent)) {
        if (parentNode2 && parentNode2.data) {
          data = mergeClassData(data, parentNode2.data);
        }
      }
      return renderClass(data.staticClass, data.class);
    }
    function mergeClassData(child, parent) {
      return {
        staticClass: concat(child.staticClass, parent.staticClass),
        class: isDef(child.class) ? [child.class, parent.class] : parent.class
      };
    }
    function renderClass(staticClass, dynamicClass) {
      if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat(staticClass, stringifyClass(dynamicClass));
      }
      return "";
    }
    function concat(a, b) {
      return a ? b ? a + " " + b : a : b || "";
    }
    function stringifyClass(value) {
      if (Array.isArray(value)) {
        return stringifyArray(value);
      }
      if (isObject(value)) {
        return stringifyObject(value);
      }
      if (typeof value === "string") {
        return value;
      }
      return "";
    }
    function stringifyArray(value) {
      let res = "";
      let stringified;
      for (let i = 0, l = value.length; i < l; i++) {
        if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
          if (res)
            res += " ";
          res += stringified;
        }
      }
      return res;
    }
    function stringifyObject(value) {
      let res = "";
      for (const key in value) {
        if (value[key]) {
          if (res)
            res += " ";
          res += key;
        }
      }
      return res;
    }
    var namespaceMap = {
      svg: "http://www.w3.org/2000/svg",
      math: "http://www.w3.org/1998/Math/MathML"
    };
    var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
    var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
    var isReservedTag = (tag) => {
      return isHTMLTag(tag) || isSVG(tag);
    };
    function getTagNamespace(tag) {
      if (isSVG(tag)) {
        return "svg";
      }
      if (tag === "math") {
        return "math";
      }
    }
    var unknownElementCache = /* @__PURE__ */ Object.create(null);
    function isUnknownElement(tag) {
      if (!inBrowser) {
        return true;
      }
      if (isReservedTag(tag)) {
        return false;
      }
      tag = tag.toLowerCase();
      if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag];
      }
      const el = document.createElement(tag);
      if (tag.indexOf("-") > -1) {
        return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
      } else {
        return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
      }
    }
    var isTextInputType = makeMap("text,number,password,search,email,tel,url");
    function query(el) {
      if (typeof el === "string") {
        const selected = document.querySelector(el);
        if (!selected) {
          warn("Cannot find element: " + el);
          return document.createElement("div");
        }
        return selected;
      } else {
        return el;
      }
    }
    function createElement(tagName2, vnode) {
      const elm = document.createElement(tagName2);
      if (tagName2 !== "select") {
        return elm;
      }
      if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
        elm.setAttribute("multiple", "multiple");
      }
      return elm;
    }
    function createElementNS(namespace, tagName2) {
      return document.createElementNS(namespaceMap[namespace], tagName2);
    }
    function createTextNode(text) {
      return document.createTextNode(text);
    }
    function createComment(text) {
      return document.createComment(text);
    }
    function insertBefore(parentNode2, newNode, referenceNode) {
      parentNode2.insertBefore(newNode, referenceNode);
    }
    function removeChild(node, child) {
      node.removeChild(child);
    }
    function appendChild(node, child) {
      node.appendChild(child);
    }
    function parentNode(node) {
      return node.parentNode;
    }
    function nextSibling(node) {
      return node.nextSibling;
    }
    function tagName(node) {
      return node.tagName;
    }
    function setTextContent(node, text) {
      node.textContent = text;
    }
    function setStyleScope(node, scopeId) {
      node.setAttribute(scopeId, "");
    }
    var nodeOps = Object.freeze({
      __proto__: null,
      createElement,
      createElementNS,
      createTextNode,
      createComment,
      insertBefore,
      removeChild,
      appendChild,
      parentNode,
      nextSibling,
      tagName,
      setTextContent,
      setStyleScope
    });
    var ref = {
      create(_, vnode) {
        registerRef(vnode);
      },
      update(oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
          registerRef(oldVnode, true);
          registerRef(vnode);
        }
      },
      destroy(vnode) {
        registerRef(vnode, true);
      }
    };
    function registerRef(vnode, isRemoval) {
      const ref2 = vnode.data.ref;
      if (!isDef(ref2))
        return;
      const vm = vnode.context;
      const refValue = vnode.componentInstance || vnode.elm;
      const value = isRemoval ? null : refValue;
      const $refsValue = isRemoval ? void 0 : refValue;
      if (isFunction(ref2)) {
        invokeWithErrorHandling(ref2, vm, [value], vm, `template ref function`);
        return;
      }
      const isFor = vnode.data.refInFor;
      const _isString = typeof ref2 === "string" || typeof ref2 === "number";
      const _isRef = isRef(ref2);
      const refs = vm.$refs;
      if (_isString || _isRef) {
        if (isFor) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isRemoval) {
            isArray(existing) && remove$2(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                setSetupRef(vm, ref2, refs[ref2]);
              } else {
                ref2.value = [refValue];
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          if (isRemoval && refs[ref2] !== refValue) {
            return;
          }
          refs[ref2] = $refsValue;
          setSetupRef(vm, ref2, value);
        } else if (_isRef) {
          if (isRemoval && ref2.value !== refValue) {
            return;
          }
          ref2.value = value;
        } else {
          warn(`Invalid template ref type: ${typeof ref2}`);
        }
      }
    }
    function setSetupRef({ _setupState }, key, val) {
      if (_setupState && hasOwn(_setupState, key)) {
        if (isRef(_setupState[key])) {
          _setupState[key].value = val;
        } else {
          _setupState[key] = val;
        }
      }
    }
    var emptyNode = new VNode("", {}, []);
    var hooks = ["create", "activate", "update", "remove", "destroy"];
    function sameVnode(a, b) {
      return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));
    }
    function sameInputType(a, b) {
      if (a.tag !== "input")
        return true;
      let i;
      const typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
      const typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
      return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
      let i, key;
      const map = {};
      for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key))
          map[key] = i;
      }
      return map;
    }
    function createPatchFunction(backend) {
      let i, j;
      const cbs = {};
      const { modules: modules2, nodeOps: nodeOps2 } = backend;
      for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules2.length; ++j) {
          if (isDef(modules2[j][hooks[i]])) {
            cbs[hooks[i]].push(modules2[j][hooks[i]]);
          }
        }
      }
      function emptyNodeAt(elm) {
        return new VNode(nodeOps2.tagName(elm).toLowerCase(), {}, [], void 0, elm);
      }
      function createRmCb(childElm, listeners) {
        function remove2() {
          if (--remove2.listeners === 0) {
            removeNode(childElm);
          }
        }
        remove2.listeners = listeners;
        return remove2;
      }
      function removeNode(el) {
        const parent = nodeOps2.parentNode(el);
        if (isDef(parent)) {
          nodeOps2.removeChild(parent, el);
        }
      }
      function isUnknownElement2(vnode, inVPre) {
        return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some((ignore) => {
          return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
        })) && config.isUnknownElement(vnode.tag);
      }
      let creatingElmInVPre = 0;
      function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index2) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
          vnode = ownerArray[index2] = cloneVNode(vnode);
        }
        vnode.isRootInsert = !nested;
        if (createComponent2(vnode, insertedVnodeQueue, parentElm, refElm)) {
          return;
        }
        const data = vnode.data;
        const children = vnode.children;
        const tag = vnode.tag;
        if (isDef(tag)) {
          {
            if (data && data.pre) {
              creatingElmInVPre++;
            }
            if (isUnknownElement2(vnode, creatingElmInVPre)) {
              warn("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context);
            }
          }
          vnode.elm = vnode.ns ? nodeOps2.createElementNS(vnode.ns, tag) : nodeOps2.createElement(tag, vnode);
          setScope(vnode);
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
          if (data && data.pre) {
            creatingElmInVPre--;
          }
        } else if (isTrue(vnode.isComment)) {
          vnode.elm = nodeOps2.createComment(vnode.text);
          insert(parentElm, vnode.elm, refElm);
        } else {
          vnode.elm = nodeOps2.createTextNode(vnode.text);
          insert(parentElm, vnode.elm, refElm);
        }
      }
      function createComponent2(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i2 = vnode.data;
        if (isDef(i2)) {
          const isReactivated = isDef(vnode.componentInstance) && i2.keepAlive;
          if (isDef(i2 = i2.hook) && isDef(i2 = i2.init)) {
            i2(vnode, false);
          }
          if (isDef(vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue);
            insert(parentElm, vnode.elm, refElm);
            if (isTrue(isReactivated)) {
              reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
            }
            return true;
          }
        }
      }
      function initComponent(vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
          insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
          vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
          setScope(vnode);
        } else {
          registerRef(vnode);
          insertedVnodeQueue.push(vnode);
        }
      }
      function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i2;
        let innerNode = vnode;
        while (innerNode.componentInstance) {
          innerNode = innerNode.componentInstance._vnode;
          if (isDef(i2 = innerNode.data) && isDef(i2 = i2.transition)) {
            for (i2 = 0; i2 < cbs.activate.length; ++i2) {
              cbs.activate[i2](emptyNode, innerNode);
            }
            insertedVnodeQueue.push(innerNode);
            break;
          }
        }
        insert(parentElm, vnode.elm, refElm);
      }
      function insert(parent, elm, ref2) {
        if (isDef(parent)) {
          if (isDef(ref2)) {
            if (nodeOps2.parentNode(ref2) === parent) {
              nodeOps2.insertBefore(parent, elm, ref2);
            }
          } else {
            nodeOps2.appendChild(parent, elm);
          }
        }
      }
      function createChildren(vnode, children, insertedVnodeQueue) {
        if (isArray(children)) {
          {
            checkDuplicateKeys(children);
          }
          for (let i2 = 0; i2 < children.length; ++i2) {
            createElm(children[i2], insertedVnodeQueue, vnode.elm, null, true, children, i2);
          }
        } else if (isPrimitive(vnode.text)) {
          nodeOps2.appendChild(vnode.elm, nodeOps2.createTextNode(String(vnode.text)));
        }
      }
      function isPatchable(vnode) {
        while (vnode.componentInstance) {
          vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag);
      }
      function invokeCreateHooks(vnode, insertedVnodeQueue) {
        for (let i2 = 0; i2 < cbs.create.length; ++i2) {
          cbs.create[i2](emptyNode, vnode);
        }
        i = vnode.data.hook;
        if (isDef(i)) {
          if (isDef(i.create))
            i.create(emptyNode, vnode);
          if (isDef(i.insert))
            insertedVnodeQueue.push(vnode);
        }
      }
      function setScope(vnode) {
        let i2;
        if (isDef(i2 = vnode.fnScopeId)) {
          nodeOps2.setStyleScope(vnode.elm, i2);
        } else {
          let ancestor = vnode;
          while (ancestor) {
            if (isDef(i2 = ancestor.context) && isDef(i2 = i2.$options._scopeId)) {
              nodeOps2.setStyleScope(vnode.elm, i2);
            }
            ancestor = ancestor.parent;
          }
        }
        if (isDef(i2 = activeInstance) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef(i2 = i2.$options._scopeId)) {
          nodeOps2.setStyleScope(vnode.elm, i2);
        }
      }
      function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
          createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
      }
      function invokeDestroyHook(vnode) {
        let i2, j2;
        const data = vnode.data;
        if (isDef(data)) {
          if (isDef(i2 = data.hook) && isDef(i2 = i2.destroy))
            i2(vnode);
          for (i2 = 0; i2 < cbs.destroy.length; ++i2)
            cbs.destroy[i2](vnode);
        }
        if (isDef(i2 = vnode.children)) {
          for (j2 = 0; j2 < vnode.children.length; ++j2) {
            invokeDestroyHook(vnode.children[j2]);
          }
        }
      }
      function removeVnodes(vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
          const ch = vnodes[startIdx];
          if (isDef(ch)) {
            if (isDef(ch.tag)) {
              removeAndInvokeRemoveHook(ch);
              invokeDestroyHook(ch);
            } else {
              removeNode(ch.elm);
            }
          }
        }
      }
      function removeAndInvokeRemoveHook(vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
          let i2;
          const listeners = cbs.remove.length + 1;
          if (isDef(rm)) {
            rm.listeners += listeners;
          } else {
            rm = createRmCb(vnode.elm, listeners);
          }
          if (isDef(i2 = vnode.componentInstance) && isDef(i2 = i2._vnode) && isDef(i2.data)) {
            removeAndInvokeRemoveHook(i2, rm);
          }
          for (i2 = 0; i2 < cbs.remove.length; ++i2) {
            cbs.remove[i2](vnode, rm);
          }
          if (isDef(i2 = vnode.data.hook) && isDef(i2 = i2.remove)) {
            i2(vnode, rm);
          } else {
            rm();
          }
        } else {
          removeNode(vnode.elm);
        }
      }
      function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx, idxInOld, vnodeToMove, refElm;
        const canMove = !removeOnly;
        {
          checkDuplicateKeys(newCh);
        }
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
          if (isUndef(oldStartVnode)) {
            oldStartVnode = oldCh[++oldStartIdx];
          } else if (isUndef(oldEndVnode)) {
            oldEndVnode = oldCh[--oldEndIdx];
          } else if (sameVnode(oldStartVnode, newStartVnode)) {
            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
          } else if (sameVnode(oldEndVnode, newEndVnode)) {
            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldStartVnode, newEndVnode)) {
            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
            canMove && nodeOps2.insertBefore(parentElm, oldStartVnode.elm, nodeOps2.nextSibling(oldEndVnode.elm));
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
          } else if (sameVnode(oldEndVnode, newStartVnode)) {
            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            canMove && nodeOps2.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
          } else {
            if (isUndef(oldKeyToIdx))
              oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
            idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
            if (isUndef(idxInOld)) {
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            } else {
              vnodeToMove = oldCh[idxInOld];
              if (sameVnode(vnodeToMove, newStartVnode)) {
                patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldCh[idxInOld] = void 0;
                canMove && nodeOps2.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
              } else {
                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
              }
            }
            newStartVnode = newCh[++newStartIdx];
          }
        }
        if (oldStartIdx > oldEndIdx) {
          refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
          addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        } else if (newStartIdx > newEndIdx) {
          removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
      }
      function checkDuplicateKeys(children) {
        const seenKeys = {};
        for (let i2 = 0; i2 < children.length; i2++) {
          const vnode = children[i2];
          const key = vnode.key;
          if (isDef(key)) {
            if (seenKeys[key]) {
              warn(`Duplicate keys detected: '${key}'. This may cause an update error.`, vnode.context);
            } else {
              seenKeys[key] = true;
            }
          }
        }
      }
      function findIdxInOld(node, oldCh, start, end) {
        for (let i2 = start; i2 < end; i2++) {
          const c = oldCh[i2];
          if (isDef(c) && sameVnode(node, c))
            return i2;
        }
      }
      function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index2, removeOnly) {
        if (oldVnode === vnode) {
          return;
        }
        if (isDef(vnode.elm) && isDef(ownerArray)) {
          vnode = ownerArray[index2] = cloneVNode(vnode);
        }
        const elm = vnode.elm = oldVnode.elm;
        if (isTrue(oldVnode.isAsyncPlaceholder)) {
          if (isDef(vnode.asyncFactory.resolved)) {
            hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
          } else {
            vnode.isAsyncPlaceholder = true;
          }
          return;
        }
        if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
          vnode.componentInstance = oldVnode.componentInstance;
          return;
        }
        let i2;
        const data = vnode.data;
        if (isDef(data) && isDef(i2 = data.hook) && isDef(i2 = i2.prepatch)) {
          i2(oldVnode, vnode);
        }
        const oldCh = oldVnode.children;
        const ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
          for (i2 = 0; i2 < cbs.update.length; ++i2)
            cbs.update[i2](oldVnode, vnode);
          if (isDef(i2 = data.hook) && isDef(i2 = i2.update))
            i2(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
          if (isDef(oldCh) && isDef(ch)) {
            if (oldCh !== ch)
              updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          } else if (isDef(ch)) {
            {
              checkDuplicateKeys(ch);
            }
            if (isDef(oldVnode.text))
              nodeOps2.setTextContent(elm, "");
            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
          } else if (isDef(oldCh)) {
            removeVnodes(oldCh, 0, oldCh.length - 1);
          } else if (isDef(oldVnode.text)) {
            nodeOps2.setTextContent(elm, "");
          }
        } else if (oldVnode.text !== vnode.text) {
          nodeOps2.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
          if (isDef(i2 = data.hook) && isDef(i2 = i2.postpatch))
            i2(oldVnode, vnode);
        }
      }
      function invokeInsertHook(vnode, queue2, initial) {
        if (isTrue(initial) && isDef(vnode.parent)) {
          vnode.parent.data.pendingInsert = queue2;
        } else {
          for (let i2 = 0; i2 < queue2.length; ++i2) {
            queue2[i2].data.hook.insert(queue2[i2]);
          }
        }
      }
      let hydrationBailed = false;
      const isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
      function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
        let i2;
        const { tag, data, children } = vnode;
        inVPre = inVPre || data && data.pre;
        vnode.elm = elm;
        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
          vnode.isAsyncPlaceholder = true;
          return true;
        }
        {
          if (!assertNodeMatch(elm, vnode, inVPre)) {
            return false;
          }
        }
        if (isDef(data)) {
          if (isDef(i2 = data.hook) && isDef(i2 = i2.init))
            i2(vnode, true);
          if (isDef(i2 = vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue);
            return true;
          }
        }
        if (isDef(tag)) {
          if (isDef(children)) {
            if (!elm.hasChildNodes()) {
              createChildren(vnode, children, insertedVnodeQueue);
            } else {
              if (isDef(i2 = data) && isDef(i2 = i2.domProps) && isDef(i2 = i2.innerHTML)) {
                if (i2 !== elm.innerHTML) {
                  if (typeof console !== "undefined" && !hydrationBailed) {
                    hydrationBailed = true;
                    console.warn("Parent: ", elm);
                    console.warn("server innerHTML: ", i2);
                    console.warn("client innerHTML: ", elm.innerHTML);
                  }
                  return false;
                }
              } else {
                let childrenMatch = true;
                let childNode = elm.firstChild;
                for (let i3 = 0; i3 < children.length; i3++) {
                  if (!childNode || !hydrate(childNode, children[i3], insertedVnodeQueue, inVPre)) {
                    childrenMatch = false;
                    break;
                  }
                  childNode = childNode.nextSibling;
                }
                if (!childrenMatch || childNode) {
                  if (typeof console !== "undefined" && !hydrationBailed) {
                    hydrationBailed = true;
                    console.warn("Parent: ", elm);
                    console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
                  }
                  return false;
                }
              }
            }
          }
          if (isDef(data)) {
            let fullInvoke = false;
            for (const key in data) {
              if (!isRenderedModule(key)) {
                fullInvoke = true;
                invokeCreateHooks(vnode, insertedVnodeQueue);
                break;
              }
            }
            if (!fullInvoke && data["class"]) {
              traverse(data["class"]);
            }
          }
        } else if (elm.data !== vnode.text) {
          elm.data = vnode.text;
        }
        return true;
      }
      function assertNodeMatch(node, vnode, inVPre) {
        if (isDef(vnode.tag)) {
          return vnode.tag.indexOf("vue-component") === 0 || !isUnknownElement2(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
        } else {
          return node.nodeType === (vnode.isComment ? 8 : 3);
        }
      }
      return function patch2(oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
          if (isDef(oldVnode))
            invokeDestroyHook(oldVnode);
          return;
        }
        let isInitialPatch = false;
        const insertedVnodeQueue = [];
        if (isUndef(oldVnode)) {
          isInitialPatch = true;
          createElm(vnode, insertedVnodeQueue);
        } else {
          const isRealElement = isDef(oldVnode.nodeType);
          if (!isRealElement && sameVnode(oldVnode, vnode)) {
            patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
          } else {
            if (isRealElement) {
              if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                oldVnode.removeAttribute(SSR_ATTR);
                hydrating = true;
              }
              if (isTrue(hydrating)) {
                if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                  invokeInsertHook(vnode, insertedVnodeQueue, true);
                  return oldVnode;
                } else {
                  warn("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
                }
              }
              oldVnode = emptyNodeAt(oldVnode);
            }
            const oldElm = oldVnode.elm;
            const parentElm = nodeOps2.parentNode(oldElm);
            createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps2.nextSibling(oldElm));
            if (isDef(vnode.parent)) {
              let ancestor = vnode.parent;
              const patchable = isPatchable(vnode);
              while (ancestor) {
                for (let i2 = 0; i2 < cbs.destroy.length; ++i2) {
                  cbs.destroy[i2](ancestor);
                }
                ancestor.elm = vnode.elm;
                if (patchable) {
                  for (let i2 = 0; i2 < cbs.create.length; ++i2) {
                    cbs.create[i2](emptyNode, ancestor);
                  }
                  const insert2 = ancestor.data.hook.insert;
                  if (insert2.merged) {
                    for (let i2 = 1; i2 < insert2.fns.length; i2++) {
                      insert2.fns[i2]();
                    }
                  }
                } else {
                  registerRef(ancestor);
                }
                ancestor = ancestor.parent;
              }
            }
            if (isDef(parentElm)) {
              removeVnodes([oldVnode], 0, 0);
            } else if (isDef(oldVnode.tag)) {
              invokeDestroyHook(oldVnode);
            }
          }
        }
        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm;
      };
    }
    var directives = {
      create: updateDirectives,
      update: updateDirectives,
      destroy: function unbindDirectives(vnode) {
        updateDirectives(vnode, emptyNode);
      }
    };
    function updateDirectives(oldVnode, vnode) {
      if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
      }
    }
    function _update(oldVnode, vnode) {
      const isCreate = oldVnode === emptyNode;
      const isDestroy = vnode === emptyNode;
      const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
      const newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
      const dirsWithInsert = [];
      const dirsWithPostpatch = [];
      let key, oldDir, dir;
      for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
          callHook(dir, "bind", vnode, oldVnode);
          if (dir.def && dir.def.inserted) {
            dirsWithInsert.push(dir);
          }
        } else {
          dir.oldValue = oldDir.value;
          dir.oldArg = oldDir.arg;
          callHook(dir, "update", vnode, oldVnode);
          if (dir.def && dir.def.componentUpdated) {
            dirsWithPostpatch.push(dir);
          }
        }
      }
      if (dirsWithInsert.length) {
        const callInsert = () => {
          for (let i = 0; i < dirsWithInsert.length; i++) {
            callHook(dirsWithInsert[i], "inserted", vnode, oldVnode);
          }
        };
        if (isCreate) {
          mergeVNodeHook(vnode, "insert", callInsert);
        } else {
          callInsert();
        }
      }
      if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, "postpatch", () => {
          for (let i = 0; i < dirsWithPostpatch.length; i++) {
            callHook(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
          }
        });
      }
      if (!isCreate) {
        for (key in oldDirs) {
          if (!newDirs[key]) {
            callHook(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
          }
        }
      }
    }
    var emptyModifiers = /* @__PURE__ */ Object.create(null);
    function normalizeDirectives(dirs, vm) {
      const res = /* @__PURE__ */ Object.create(null);
      if (!dirs) {
        return res;
      }
      let i, dir;
      for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
          dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        if (vm._setupState && vm._setupState.__sfc) {
          const setupDef = dir.def || resolveAsset(vm, "_setupState", "v-" + dir.name);
          if (typeof setupDef === "function") {
            dir.def = {
              bind: setupDef,
              update: setupDef
            };
          } else {
            dir.def = setupDef;
          }
        }
        dir.def = dir.def || resolveAsset(vm.$options, "directives", dir.name, true);
      }
      return res;
    }
    function getRawDirName(dir) {
      return dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join(".")}`;
    }
    function callHook(dir, hook, vnode, oldVnode, isDestroy) {
      const fn = dir.def && dir.def[hook];
      if (fn) {
        try {
          fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        } catch (e) {
          handleError(e, vnode.context, `directive ${dir.name} ${hook} hook`);
        }
      }
    }
    var baseModules = [ref, directives];
    function updateAttrs(oldVnode, vnode) {
      const opts = vnode.componentOptions;
      if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return;
      }
      if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return;
      }
      let key, cur, old;
      const elm = vnode.elm;
      const oldAttrs = oldVnode.data.attrs || {};
      let attrs2 = vnode.data.attrs || {};
      if (isDef(attrs2.__ob__) || isTrue(attrs2._v_attr_proxy)) {
        attrs2 = vnode.data.attrs = extend({}, attrs2);
      }
      for (key in attrs2) {
        cur = attrs2[key];
        old = oldAttrs[key];
        if (old !== cur) {
          setAttr(elm, key, cur, vnode.data.pre);
        }
      }
      if ((isIE || isEdge) && attrs2.value !== oldAttrs.value) {
        setAttr(elm, "value", attrs2.value);
      }
      for (key in oldAttrs) {
        if (isUndef(attrs2[key])) {
          if (isXlink(key)) {
            elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
          } else if (!isEnumeratedAttr(key)) {
            elm.removeAttribute(key);
          }
        }
      }
    }
    function setAttr(el, key, value, isInPre) {
      if (isInPre || el.tagName.indexOf("-") > -1) {
        baseSetAttr(el, key, value);
      } else if (isBooleanAttr(key)) {
        if (isFalsyAttrValue(value)) {
          el.removeAttribute(key);
        } else {
          value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
          el.setAttribute(key, value);
        }
      } else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
      } else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
          el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        baseSetAttr(el, key, value);
      }
    }
    function baseSetAttr(el, key, value) {
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        if (isIE && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
          const blocker = (e) => {
            e.stopImmediatePropagation();
            el.removeEventListener("input", blocker);
          };
          el.addEventListener("input", blocker);
          el.__ieph = true;
        }
        el.setAttribute(key, value);
      }
    }
    var attrs = {
      create: updateAttrs,
      update: updateAttrs
    };
    function updateClass(oldVnode, vnode) {
      const el = vnode.elm;
      const data = vnode.data;
      const oldData = oldVnode.data;
      if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
        return;
      }
      let cls = genClassForVnode(vnode);
      const transitionClass = el._transitionClasses;
      if (isDef(transitionClass)) {
        cls = concat(cls, stringifyClass(transitionClass));
      }
      if (cls !== el._prevClass) {
        el.setAttribute("class", cls);
        el._prevClass = cls;
      }
    }
    var klass = {
      create: updateClass,
      update: updateClass
    };
    var RANGE_TOKEN = "__r";
    var CHECKBOX_RADIO_TOKEN = "__c";
    function normalizeEvents(on) {
      if (isDef(on[RANGE_TOKEN])) {
        const event = isIE ? "change" : "input";
        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
        delete on[RANGE_TOKEN];
      }
      if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
      }
    }
    var target;
    function createOnceHandler(event, handler, capture) {
      const _target = target;
      return function onceHandler() {
        const res = handler.apply(null, arguments);
        if (res !== null) {
          remove(event, onceHandler, capture, _target);
        }
      };
    }
    var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
    function add(name, handler, capture, passive) {
      if (useMicrotaskFix) {
        const attachedTimestamp = currentFlushTimestamp;
        const original = handler;
        handler = original._wrapper = function(e) {
          if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp || e.timeStamp <= 0 || e.target.ownerDocument !== document) {
            return original.apply(this, arguments);
          }
        };
      }
      target.addEventListener(name, handler, supportsPassive ? { capture, passive } : capture);
    }
    function remove(name, handler, capture, _target) {
      (_target || target).removeEventListener(name, handler._wrapper || handler, capture);
    }
    function updateDOMListeners(oldVnode, vnode) {
      if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return;
      }
      const on = vnode.data.on || {};
      const oldOn = oldVnode.data.on || {};
      target = vnode.elm || oldVnode.elm;
      normalizeEvents(on);
      updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
      target = void 0;
    }
    var events = {
      create: updateDOMListeners,
      update: updateDOMListeners,
      destroy: (vnode) => updateDOMListeners(vnode, emptyNode)
    };
    var svgContainer;
    function updateDOMProps(oldVnode, vnode) {
      if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return;
      }
      let key, cur;
      const elm = vnode.elm;
      const oldProps = oldVnode.data.domProps || {};
      let props2 = vnode.data.domProps || {};
      if (isDef(props2.__ob__) || isTrue(props2._v_attr_proxy)) {
        props2 = vnode.data.domProps = extend({}, props2);
      }
      for (key in oldProps) {
        if (!(key in props2)) {
          elm[key] = "";
        }
      }
      for (key in props2) {
        cur = props2[key];
        if (key === "textContent" || key === "innerHTML") {
          if (vnode.children)
            vnode.children.length = 0;
          if (cur === oldProps[key])
            continue;
          if (elm.childNodes.length === 1) {
            elm.removeChild(elm.childNodes[0]);
          }
        }
        if (key === "value" && elm.tagName !== "PROGRESS") {
          elm._value = cur;
          const strCur = isUndef(cur) ? "" : String(cur);
          if (shouldUpdateValue(elm, strCur)) {
            elm.value = strCur;
          }
        } else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
          svgContainer = svgContainer || document.createElement("div");
          svgContainer.innerHTML = `<svg>${cur}</svg>`;
          const svg = svgContainer.firstChild;
          while (elm.firstChild) {
            elm.removeChild(elm.firstChild);
          }
          while (svg.firstChild) {
            elm.appendChild(svg.firstChild);
          }
        } else if (cur !== oldProps[key]) {
          try {
            elm[key] = cur;
          } catch (e) {
          }
        }
      }
    }
    function shouldUpdateValue(elm, checkVal) {
      return !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
    }
    function isNotInFocusAndDirty(elm, checkVal) {
      let notInFocus = true;
      try {
        notInFocus = document.activeElement !== elm;
      } catch (e) {
      }
      return notInFocus && elm.value !== checkVal;
    }
    function isDirtyWithModifiers(elm, newVal) {
      const value = elm.value;
      const modifiers = elm._vModifiers;
      if (isDef(modifiers)) {
        if (modifiers.number) {
          return toNumber(value) !== toNumber(newVal);
        }
        if (modifiers.trim) {
          return value.trim() !== newVal.trim();
        }
      }
      return value !== newVal;
    }
    var domProps = {
      create: updateDOMProps,
      update: updateDOMProps
    };
    var parseStyleText = cached(function(cssText) {
      const res = {};
      const listDelimiter = /;(?![^(]*\))/g;
      const propertyDelimiter = /:(.+)/;
      cssText.split(listDelimiter).forEach(function(item) {
        if (item) {
          const tmp = item.split(propertyDelimiter);
          tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return res;
    });
    function normalizeStyleData(data) {
      const style2 = normalizeStyleBinding(data.style);
      return data.staticStyle ? extend(data.staticStyle, style2) : style2;
    }
    function normalizeStyleBinding(bindingStyle) {
      if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle);
      }
      if (typeof bindingStyle === "string") {
        return parseStyleText(bindingStyle);
      }
      return bindingStyle;
    }
    function getStyle(vnode, checkChild) {
      const res = {};
      let styleData;
      if (checkChild) {
        let childNode = vnode;
        while (childNode.componentInstance) {
          childNode = childNode.componentInstance._vnode;
          if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
            extend(res, styleData);
          }
        }
      }
      if (styleData = normalizeStyleData(vnode.data)) {
        extend(res, styleData);
      }
      let parentNode2 = vnode;
      while (parentNode2 = parentNode2.parent) {
        if (parentNode2.data && (styleData = normalizeStyleData(parentNode2.data))) {
          extend(res, styleData);
        }
      }
      return res;
    }
    var cssVarRE = /^--/;
    var importantRE = /\s*!important$/;
    var setProp = (el, name, val) => {
      if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
      } else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important");
      } else {
        const normalizedName = normalize(name);
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; i++) {
            el.style[normalizedName] = val[i];
          }
        } else {
          el.style[normalizedName] = val;
        }
      }
    };
    var vendorNames = ["Webkit", "Moz", "ms"];
    var emptyStyle;
    var normalize = cached(function(prop) {
      emptyStyle = emptyStyle || document.createElement("div").style;
      prop = camelize(prop);
      if (prop !== "filter" && prop in emptyStyle) {
        return prop;
      }
      const capName = prop.charAt(0).toUpperCase() + prop.slice(1);
      for (let i = 0; i < vendorNames.length; i++) {
        const name = vendorNames[i] + capName;
        if (name in emptyStyle) {
          return name;
        }
      }
    });
    function updateStyle(oldVnode, vnode) {
      const data = vnode.data;
      const oldData = oldVnode.data;
      if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
        return;
      }
      let cur, name;
      const el = vnode.elm;
      const oldStaticStyle = oldData.staticStyle;
      const oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
      const oldStyle = oldStaticStyle || oldStyleBinding;
      const style2 = normalizeStyleBinding(vnode.data.style) || {};
      vnode.data.normalizedStyle = isDef(style2.__ob__) ? extend({}, style2) : style2;
      const newStyle = getStyle(vnode, true);
      for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
          setProp(el, name, "");
        }
      }
      for (name in newStyle) {
        cur = newStyle[name];
        if (cur !== oldStyle[name]) {
          setProp(el, name, cur == null ? "" : cur);
        }
      }
    }
    var style = {
      create: updateStyle,
      update: updateStyle
    };
    var whitespaceRE = /\s+/;
    function addClass(el, cls) {
      if (!cls || !(cls = cls.trim())) {
        return;
      }
      if (el.classList) {
        if (cls.indexOf(" ") > -1) {
          cls.split(whitespaceRE).forEach((c) => el.classList.add(c));
        } else {
          el.classList.add(cls);
        }
      } else {
        const cur = ` ${el.getAttribute("class") || ""} `;
        if (cur.indexOf(" " + cls + " ") < 0) {
          el.setAttribute("class", (cur + cls).trim());
        }
      }
    }
    function removeClass(el, cls) {
      if (!cls || !(cls = cls.trim())) {
        return;
      }
      if (el.classList) {
        if (cls.indexOf(" ") > -1) {
          cls.split(whitespaceRE).forEach((c) => el.classList.remove(c));
        } else {
          el.classList.remove(cls);
        }
        if (!el.classList.length) {
          el.removeAttribute("class");
        }
      } else {
        let cur = ` ${el.getAttribute("class") || ""} `;
        const tar = " " + cls + " ";
        while (cur.indexOf(tar) >= 0) {
          cur = cur.replace(tar, " ");
        }
        cur = cur.trim();
        if (cur) {
          el.setAttribute("class", cur);
        } else {
          el.removeAttribute("class");
        }
      }
    }
    function resolveTransition(def2) {
      if (!def2) {
        return;
      }
      if (typeof def2 === "object") {
        const res = {};
        if (def2.css !== false) {
          extend(res, autoCssTransition(def2.name || "v"));
        }
        extend(res, def2);
        return res;
      } else if (typeof def2 === "string") {
        return autoCssTransition(def2);
      }
    }
    var autoCssTransition = cached((name) => {
      return {
        enterClass: `${name}-enter`,
        enterToClass: `${name}-enter-to`,
        enterActiveClass: `${name}-enter-active`,
        leaveClass: `${name}-leave`,
        leaveToClass: `${name}-leave-to`,
        leaveActiveClass: `${name}-leave-active`
      };
    });
    var hasTransition = inBrowser && !isIE9;
    var TRANSITION = "transition";
    var ANIMATION = "animation";
    var transitionProp = "transition";
    var transitionEndEvent = "transitionend";
    var animationProp = "animation";
    var animationEndEvent = "animationend";
    if (hasTransition) {
      if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
        transitionProp = "WebkitTransition";
        transitionEndEvent = "webkitTransitionEnd";
      }
      if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
        animationProp = "WebkitAnimation";
        animationEndEvent = "webkitAnimationEnd";
      }
    }
    var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (fn) => fn();
    function nextFrame(fn) {
      raf(() => {
        raf(fn);
      });
    }
    function addTransitionClass(el, cls) {
      const transitionClasses = el._transitionClasses || (el._transitionClasses = []);
      if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass(el, cls);
      }
    }
    function removeTransitionClass(el, cls) {
      if (el._transitionClasses) {
        remove$2(el._transitionClasses, cls);
      }
      removeClass(el, cls);
    }
    function whenTransitionEnds(el, expectedType, cb) {
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type)
        return cb();
      const event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
      let ended = 0;
      const end = () => {
        el.removeEventListener(event, onEnd);
        cb();
      };
      const onEnd = (e) => {
        if (e.target === el) {
          if (++ended >= propCount) {
            end();
          }
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(event, onEnd);
    }
    var transformRE = /\b(transform|all)(,|$)/;
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
      const transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
      const animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + "Property"]);
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max.apply(null, durations.map((d, i) => {
        return toMs(d) + toMs(delays[i]);
      }));
    }
    function toMs(s) {
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function enter(vnode, toggleDisplay) {
      const el = vnode.elm;
      if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
      }
      const data = resolveTransition(vnode.data.transition);
      if (isUndef(data)) {
        return;
      }
      if (isDef(el._enterCb) || el.nodeType !== 1) {
        return;
      }
      const { css, type, enterClass, enterToClass, enterActiveClass, appearClass, appearToClass, appearActiveClass, beforeEnter, enter: enter2, afterEnter, enterCancelled, beforeAppear, appear, afterAppear, appearCancelled, duration } = data;
      let context = activeInstance;
      let transitionNode = activeInstance.$vnode;
      while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
      }
      const isAppear = !context._isMounted || !vnode.isRootInsert;
      if (isAppear && !appear && appear !== "") {
        return;
      }
      const startClass = isAppear && appearClass ? appearClass : enterClass;
      const activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
      const toClass = isAppear && appearToClass ? appearToClass : enterToClass;
      const beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
      const enterHook = isAppear ? isFunction(appear) ? appear : enter2 : enter2;
      const afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
      const enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
      const explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
      if (explicitEnterDuration != null) {
        checkDuration(explicitEnterDuration, "enter", vnode);
      }
      const expectsCSS = css !== false && !isIE9;
      const userWantsControl = getHookArgumentsLength(enterHook);
      const cb = el._enterCb = once(() => {
        if (expectsCSS) {
          removeTransitionClass(el, toClass);
          removeTransitionClass(el, activeClass);
        }
        if (cb.cancelled) {
          if (expectsCSS) {
            removeTransitionClass(el, startClass);
          }
          enterCancelledHook && enterCancelledHook(el);
        } else {
          afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
      });
      if (!vnode.data.show) {
        mergeVNodeHook(vnode, "insert", () => {
          const parent = el.parentNode;
          const pendingNode = parent && parent._pending && parent._pending[vnode.key];
          if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
            pendingNode.elm._leaveCb();
          }
          enterHook && enterHook(el, cb);
        });
      }
      beforeEnterHook && beforeEnterHook(el);
      if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(() => {
          removeTransitionClass(el, startClass);
          if (!cb.cancelled) {
            addTransitionClass(el, toClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitEnterDuration)) {
                setTimeout(cb, explicitEnterDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
      }
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
    function leave(vnode, rm) {
      const el = vnode.elm;
      if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
      }
      const data = resolveTransition(vnode.data.transition);
      if (isUndef(data) || el.nodeType !== 1) {
        return rm();
      }
      if (isDef(el._leaveCb)) {
        return;
      }
      const { css, type, leaveClass, leaveToClass, leaveActiveClass, beforeLeave, leave: leave2, afterLeave, leaveCancelled, delayLeave, duration } = data;
      const expectsCSS = css !== false && !isIE9;
      const userWantsControl = getHookArgumentsLength(leave2);
      const explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
      if (isDef(explicitLeaveDuration)) {
        checkDuration(explicitLeaveDuration, "leave", vnode);
      }
      const cb = el._leaveCb = once(() => {
        if (el.parentNode && el.parentNode._pending) {
          el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
        }
        if (cb.cancelled) {
          if (expectsCSS) {
            removeTransitionClass(el, leaveClass);
          }
          leaveCancelled && leaveCancelled(el);
        } else {
          rm();
          afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
      });
      if (delayLeave) {
        delayLeave(performLeave);
      } else {
        performLeave();
      }
      function performLeave() {
        if (cb.cancelled) {
          return;
        }
        if (!vnode.data.show && el.parentNode) {
          (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
          addTransitionClass(el, leaveClass);
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            removeTransitionClass(el, leaveClass);
            if (!cb.cancelled) {
              addTransitionClass(el, leaveToClass);
              if (!userWantsControl) {
                if (isValidDuration(explicitLeaveDuration)) {
                  setTimeout(cb, explicitLeaveDuration);
                } else {
                  whenTransitionEnds(el, type, cb);
                }
              }
            }
          });
        }
        leave2 && leave2(el, cb);
        if (!expectsCSS && !userWantsControl) {
          cb();
        }
      }
    }
    function checkDuration(val, name, vnode) {
      if (typeof val !== "number") {
        warn(`<transition> explicit ${name} duration is not a valid number - got ${JSON.stringify(val)}.`, vnode.context);
      } else if (isNaN(val)) {
        warn(`<transition> explicit ${name} duration is NaN - the duration expression might be incorrect.`, vnode.context);
      }
    }
    function isValidDuration(val) {
      return typeof val === "number" && !isNaN(val);
    }
    function getHookArgumentsLength(fn) {
      if (isUndef(fn)) {
        return false;
      }
      const invokerFns = fn.fns;
      if (isDef(invokerFns)) {
        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
      } else {
        return (fn._length || fn.length) > 1;
      }
    }
    function _enter(_, vnode) {
      if (vnode.data.show !== true) {
        enter(vnode);
      }
    }
    var transition = inBrowser ? {
      create: _enter,
      activate: _enter,
      remove(vnode, rm) {
        if (vnode.data.show !== true) {
          leave(vnode, rm);
        } else {
          rm();
        }
      }
    } : {};
    var platformModules = [attrs, klass, events, domProps, style, transition];
    var modules = platformModules.concat(baseModules);
    var patch = createPatchFunction({ nodeOps, modules });
    if (isIE9) {
      document.addEventListener("selectionchange", () => {
        const el = document.activeElement;
        if (el && el.vmodel) {
          trigger(el, "input");
        }
      });
    }
    var directive = {
      inserted(el, binding, vnode, oldVnode) {
        if (vnode.tag === "select") {
          if (oldVnode.elm && !oldVnode.elm._vOptions) {
            mergeVNodeHook(vnode, "postpatch", () => {
              directive.componentUpdated(el, binding, vnode);
            });
          } else {
            setSelected(el, binding, vnode.context);
          }
          el._vOptions = [].map.call(el.options, getValue);
        } else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
          el._vModifiers = binding.modifiers;
          if (!binding.modifiers.lazy) {
            el.addEventListener("compositionstart", onCompositionStart);
            el.addEventListener("compositionend", onCompositionEnd);
            el.addEventListener("change", onCompositionEnd);
            if (isIE9) {
              el.vmodel = true;
            }
          }
        }
      },
      componentUpdated(el, binding, vnode) {
        if (vnode.tag === "select") {
          setSelected(el, binding, vnode.context);
          const prevOptions = el._vOptions;
          const curOptions = el._vOptions = [].map.call(el.options, getValue);
          if (curOptions.some((o, i) => !looseEqual(o, prevOptions[i]))) {
            const needReset = el.multiple ? binding.value.some((v) => hasNoMatchingOption(v, curOptions)) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
            if (needReset) {
              trigger(el, "change");
            }
          }
        }
      }
    };
    function setSelected(el, binding, vm) {
      actuallySetSelected(el, binding, vm);
      if (isIE || isEdge) {
        setTimeout(() => {
          actuallySetSelected(el, binding, vm);
        }, 0);
      }
    }
    function actuallySetSelected(el, binding, vm) {
      const value = binding.value;
      const isMultiple = el.multiple;
      if (isMultiple && !Array.isArray(value)) {
        warn(`<select multiple v-model="${binding.expression}"> expects an Array value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}`, vm);
        return;
      }
      let selected, option;
      for (let i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
          selected = looseIndexOf(value, getValue(option)) > -1;
          if (option.selected !== selected) {
            option.selected = selected;
          }
        } else {
          if (looseEqual(getValue(option), value)) {
            if (el.selectedIndex !== i) {
              el.selectedIndex = i;
            }
            return;
          }
        }
      }
      if (!isMultiple) {
        el.selectedIndex = -1;
      }
    }
    function hasNoMatchingOption(value, options) {
      return options.every((o) => !looseEqual(o, value));
    }
    function getValue(option) {
      return "_value" in option ? option._value : option.value;
    }
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      if (!e.target.composing)
        return;
      e.target.composing = false;
      trigger(e.target, "input");
    }
    function trigger(el, type) {
      const e = document.createEvent("HTMLEvents");
      e.initEvent(type, true, true);
      el.dispatchEvent(e);
    }
    function locateNode(vnode) {
      return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
    }
    var show = {
      bind(el, { value }, vnode) {
        vnode = locateNode(vnode);
        const transition2 = vnode.data && vnode.data.transition;
        const originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
        if (value && transition2) {
          vnode.data.show = true;
          enter(vnode, () => {
            el.style.display = originalDisplay;
          });
        } else {
          el.style.display = value ? originalDisplay : "none";
        }
      },
      update(el, { value, oldValue }, vnode) {
        if (!value === !oldValue)
          return;
        vnode = locateNode(vnode);
        const transition2 = vnode.data && vnode.data.transition;
        if (transition2) {
          vnode.data.show = true;
          if (value) {
            enter(vnode, () => {
              el.style.display = el.__vOriginalDisplay;
            });
          } else {
            leave(vnode, () => {
              el.style.display = "none";
            });
          }
        } else {
          el.style.display = value ? el.__vOriginalDisplay : "none";
        }
      },
      unbind(el, binding, vnode, oldVnode, isDestroy) {
        if (!isDestroy) {
          el.style.display = el.__vOriginalDisplay;
        }
      }
    };
    var platformDirectives = {
      model: directive,
      show
    };
    var transitionProps = {
      name: String,
      appear: Boolean,
      css: Boolean,
      mode: String,
      type: String,
      enterClass: String,
      leaveClass: String,
      enterToClass: String,
      leaveToClass: String,
      enterActiveClass: String,
      leaveActiveClass: String,
      appearClass: String,
      appearActiveClass: String,
      appearToClass: String,
      duration: [Number, String, Object]
    };
    function getRealChild(vnode) {
      const compOptions = vnode && vnode.componentOptions;
      if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children));
      } else {
        return vnode;
      }
    }
    function extractTransitionData(comp) {
      const data = {};
      const options = comp.$options;
      for (const key in options.propsData) {
        data[key] = comp[key];
      }
      const listeners = options._parentListeners;
      for (const key in listeners) {
        data[camelize(key)] = listeners[key];
      }
      return data;
    }
    function placeholder(h2, rawChild) {
      if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h2("keep-alive", {
          props: rawChild.componentOptions.propsData
        });
      }
    }
    function hasParentTransition(vnode) {
      while (vnode = vnode.parent) {
        if (vnode.data.transition) {
          return true;
        }
      }
    }
    function isSameChild(child, oldChild) {
      return oldChild.key === child.key && oldChild.tag === child.tag;
    }
    var isNotTextNode = (c) => c.tag || isAsyncPlaceholder(c);
    var isVShowDirective = (d) => d.name === "show";
    var Transition = {
      name: "transition",
      props: transitionProps,
      abstract: true,
      render(h2) {
        let children = this.$slots.default;
        if (!children) {
          return;
        }
        children = children.filter(isNotTextNode);
        if (!children.length) {
          return;
        }
        if (children.length > 1) {
          warn("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
        }
        const mode = this.mode;
        if (mode && mode !== "in-out" && mode !== "out-in") {
          warn("invalid <transition> mode: " + mode, this.$parent);
        }
        const rawChild = children[0];
        if (hasParentTransition(this.$vnode)) {
          return rawChild;
        }
        const child = getRealChild(rawChild);
        if (!child) {
          return rawChild;
        }
        if (this._leaving) {
          return placeholder(h2, rawChild);
        }
        const id = `__transition-${this._uid}-`;
        child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
        const data = (child.data || (child.data = {})).transition = extractTransitionData(this);
        const oldRawChild = this._vnode;
        const oldChild = getRealChild(oldRawChild);
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
          child.data.show = true;
        }
        if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
          const oldData = oldChild.data.transition = extend({}, data);
          if (mode === "out-in") {
            this._leaving = true;
            mergeVNodeHook(oldData, "afterLeave", () => {
              this._leaving = false;
              this.$forceUpdate();
            });
            return placeholder(h2, rawChild);
          } else if (mode === "in-out") {
            if (isAsyncPlaceholder(child)) {
              return oldRawChild;
            }
            let delayedLeave;
            const performLeave = () => {
              delayedLeave();
            };
            mergeVNodeHook(data, "afterEnter", performLeave);
            mergeVNodeHook(data, "enterCancelled", performLeave);
            mergeVNodeHook(oldData, "delayLeave", (leave2) => {
              delayedLeave = leave2;
            });
          }
        }
        return rawChild;
      }
    };
    var props = extend({
      tag: String,
      moveClass: String
    }, transitionProps);
    delete props.mode;
    var TransitionGroup = {
      props,
      beforeMount() {
        const update = this._update;
        this._update = (vnode, hydrating) => {
          const restoreActiveInstance = setActiveInstance(this);
          this.__patch__(this._vnode, this.kept, false, true);
          this._vnode = this.kept;
          restoreActiveInstance();
          update.call(this, vnode, hydrating);
        };
      },
      render(h2) {
        const tag = this.tag || this.$vnode.data.tag || "span";
        const map = /* @__PURE__ */ Object.create(null);
        const prevChildren = this.prevChildren = this.children;
        const rawChildren = this.$slots.default || [];
        const children = this.children = [];
        const transitionData = extractTransitionData(this);
        for (let i = 0; i < rawChildren.length; i++) {
          const c = rawChildren[i];
          if (c.tag) {
            if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
              children.push(c);
              map[c.key] = c;
              (c.data || (c.data = {})).transition = transitionData;
            } else {
              const opts = c.componentOptions;
              const name = opts ? getComponentName(opts.Ctor.options) || opts.tag || "" : c.tag;
              warn(`<transition-group> children must be keyed: <${name}>`);
            }
          }
        }
        if (prevChildren) {
          const kept = [];
          const removed = [];
          for (let i = 0; i < prevChildren.length; i++) {
            const c = prevChildren[i];
            c.data.transition = transitionData;
            c.data.pos = c.elm.getBoundingClientRect();
            if (map[c.key]) {
              kept.push(c);
            } else {
              removed.push(c);
            }
          }
          this.kept = h2(tag, null, kept);
          this.removed = removed;
        }
        return h2(tag, null, children);
      },
      updated() {
        const children = this.prevChildren;
        const moveClass = this.moveClass || (this.name || "v") + "-move";
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
          return;
        }
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);
        this._reflow = document.body.offsetHeight;
        children.forEach((c) => {
          if (c.data.moved) {
            const el = c.elm;
            const s = el.style;
            addTransitionClass(el, moveClass);
            s.transform = s.WebkitTransform = s.transitionDuration = "";
            el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener(transitionEndEvent, cb);
                el._moveCb = null;
                removeTransitionClass(el, moveClass);
              }
            });
          }
        });
      },
      methods: {
        hasMove(el, moveClass) {
          if (!hasTransition) {
            return false;
          }
          if (this._hasMove) {
            return this._hasMove;
          }
          const clone = el.cloneNode();
          if (el._transitionClasses) {
            el._transitionClasses.forEach((cls) => {
              removeClass(clone, cls);
            });
          }
          addClass(clone, moveClass);
          clone.style.display = "none";
          this.$el.appendChild(clone);
          const info = getTransitionInfo(clone);
          this.$el.removeChild(clone);
          return this._hasMove = info.hasTransform;
        }
      }
    };
    function callPendingCbs(c) {
      if (c.elm._moveCb) {
        c.elm._moveCb();
      }
      if (c.elm._enterCb) {
        c.elm._enterCb();
      }
    }
    function recordPosition(c) {
      c.data.newPos = c.elm.getBoundingClientRect();
    }
    function applyTranslation(c) {
      const oldPos = c.data.pos;
      const newPos = c.data.newPos;
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        c.data.moved = true;
        const s = c.elm.style;
        s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
      }
    }
    var platformComponents = {
      Transition,
      TransitionGroup
    };
    Vue.config.mustUseProp = mustUseProp;
    Vue.config.isReservedTag = isReservedTag;
    Vue.config.isReservedAttr = isReservedAttr;
    Vue.config.getTagNamespace = getTagNamespace;
    Vue.config.isUnknownElement = isUnknownElement;
    extend(Vue.options.directives, platformDirectives);
    extend(Vue.options.components, platformComponents);
    Vue.prototype.__patch__ = inBrowser ? patch : noop;
    Vue.prototype.$mount = function(el, hydrating) {
      el = el && inBrowser ? query(el) : void 0;
      return mountComponent(this, el, hydrating);
    };
    if (inBrowser) {
      setTimeout(() => {
        if (config.devtools) {
          if (devtools) {
            devtools.emit("init", Vue);
          } else {
            console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools");
          }
        }
        if (config.productionTip !== false && typeof console !== "undefined") {
          console[console.info ? "info" : "log"](`You are running Vue in development mode.
Make sure to turn on production mode when deploying for production.
See more tips at https://vuejs.org/guide/deployment.html`);
        }
      }, 0);
    }
    extend(Vue, vca);
    module.exports = Vue;
  }
});

// node_modules/vue-cryptocurrency-icons/node_modules/vue/dist/vue.runtime.common.js
var require_vue_runtime_common = __commonJS({
  "node_modules/vue-cryptocurrency-icons/node_modules/vue/dist/vue.runtime.common.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_runtime_common_dev();
    }
  }
});

// node_modules/vue-cryptocurrency-icons/dist/vue-cryptocurrency-icons.common.js
var require_vue_cryptocurrency_icons_common = __commonJS({
  "node_modules/vue-cryptocurrency-icons/dist/vue-cryptocurrency-icons.common.js"(exports, module) {
    module.exports = function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = "fb15");
    }({
      "01f9": function(module2, exports2, __webpack_require__) {
        "use strict";
        var LIBRARY = __webpack_require__("2d00");
        var $export = __webpack_require__("5ca1");
        var redefine = __webpack_require__("2aba");
        var hide = __webpack_require__("32e9");
        var Iterators = __webpack_require__("84f2");
        var $iterCreate = __webpack_require__("41a0");
        var setToStringTag = __webpack_require__("7f20");
        var getPrototypeOf = __webpack_require__("38fd");
        var ITERATOR = __webpack_require__("2b4c")("iterator");
        var BUGGY = !([].keys && "next" in [].keys());
        var FF_ITERATOR = "@@iterator";
        var KEYS = "keys";
        var VALUES = "values";
        var returnThis = function() {
          return this;
        };
        module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
          $iterCreate(Constructor, NAME, next);
          var getMethod = function(kind) {
            if (!BUGGY && kind in proto)
              return proto[kind];
            switch (kind) {
              case KEYS:
                return function keys() {
                  return new Constructor(this, kind);
                };
              case VALUES:
                return function values() {
                  return new Constructor(this, kind);
                };
            }
            return function entries() {
              return new Constructor(this, kind);
            };
          };
          var TAG = NAME + " Iterator";
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto = Base.prototype;
          var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
          var $default = $native || getMethod(DEFAULT);
          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
          var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
          var methods, key, IteratorPrototype;
          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
              setToStringTag(IteratorPrototype, TAG, true);
              if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
                hide(IteratorPrototype, ITERATOR, returnThis);
            }
          }
          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;
            $default = function values() {
              return $native.call(this);
            };
          }
          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
            hide(proto, ITERATOR, $default);
          }
          Iterators[NAME] = $default;
          Iterators[TAG] = returnThis;
          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries
            };
            if (FORCED)
              for (key in methods) {
                if (!(key in proto))
                  redefine(proto, key, methods[key]);
              }
            else
              $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
          }
          return methods;
        };
      },
      "0d58": function(module2, exports2, __webpack_require__) {
        var $keys = __webpack_require__("ce10");
        var enumBugKeys = __webpack_require__("e11e");
        module2.exports = Object.keys || function keys(O) {
          return $keys(O, enumBugKeys);
        };
      },
      "1495": function(module2, exports2, __webpack_require__) {
        var dP = __webpack_require__("86cc");
        var anObject = __webpack_require__("cb7c");
        var getKeys = __webpack_require__("0d58");
        module2.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys = getKeys(Properties);
          var length = keys.length;
          var i = 0;
          var P;
          while (length > i)
            dP.f(O, P = keys[i++], Properties[P]);
          return O;
        };
      },
      "230e": function(module2, exports2, __webpack_require__) {
        var isObject = __webpack_require__("d3f4");
        var document2 = __webpack_require__("7726").document;
        var is = isObject(document2) && isObject(document2.createElement);
        module2.exports = function(it) {
          return is ? document2.createElement(it) : {};
        };
      },
      "2aba": function(module2, exports2, __webpack_require__) {
        var global2 = __webpack_require__("7726");
        var hide = __webpack_require__("32e9");
        var has = __webpack_require__("69a8");
        var SRC = __webpack_require__("ca5a")("src");
        var $toString = __webpack_require__("fa5b");
        var TO_STRING = "toString";
        var TPL = ("" + $toString).split(TO_STRING);
        __webpack_require__("8378").inspectSource = function(it) {
          return $toString.call(it);
        };
        (module2.exports = function(O, key, val, safe) {
          var isFunction = typeof val == "function";
          if (isFunction)
            has(val, "name") || hide(val, "name", key);
          if (O[key] === val)
            return;
          if (isFunction)
            has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
          if (O === global2) {
            O[key] = val;
          } else if (!safe) {
            delete O[key];
            hide(O, key, val);
          } else if (O[key]) {
            O[key] = val;
          } else {
            hide(O, key, val);
          }
        })(Function.prototype, TO_STRING, function toString() {
          return typeof this == "function" && this[SRC] || $toString.call(this);
        });
      },
      "2aeb": function(module2, exports2, __webpack_require__) {
        var anObject = __webpack_require__("cb7c");
        var dPs = __webpack_require__("1495");
        var enumBugKeys = __webpack_require__("e11e");
        var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
        var Empty = function() {
        };
        var PROTOTYPE = "prototype";
        var createDict = function() {
          var iframe = __webpack_require__("230e")("iframe");
          var i = enumBugKeys.length;
          var lt = "<";
          var gt = ">";
          var iframeDocument;
          iframe.style.display = "none";
          __webpack_require__("fab2").appendChild(iframe);
          iframe.src = "javascript:";
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
          iframeDocument.close();
          createDict = iframeDocument.F;
          while (i--)
            delete createDict[PROTOTYPE][enumBugKeys[i]];
          return createDict();
        };
        module2.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else
            result = createDict();
          return Properties === void 0 ? result : dPs(result, Properties);
        };
      },
      "2b4c": function(module2, exports2, __webpack_require__) {
        var store = __webpack_require__("5537")("wks");
        var uid = __webpack_require__("ca5a");
        var Symbol2 = __webpack_require__("7726").Symbol;
        var USE_SYMBOL = typeof Symbol2 == "function";
        var $exports = module2.exports = function(name) {
          return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
        };
        $exports.store = store;
      },
      "2d00": function(module2, exports2) {
        module2.exports = false;
      },
      "2d95": function(module2, exports2) {
        var toString = {}.toString;
        module2.exports = function(it) {
          return toString.call(it).slice(8, -1);
        };
      },
      "32e9": function(module2, exports2, __webpack_require__) {
        var dP = __webpack_require__("86cc");
        var createDesc = __webpack_require__("4630");
        module2.exports = __webpack_require__("9e1e") ? function(object, key, value) {
          return dP.f(object, key, createDesc(1, value));
        } : function(object, key, value) {
          object[key] = value;
          return object;
        };
      },
      "38fd": function(module2, exports2, __webpack_require__) {
        var has = __webpack_require__("69a8");
        var toObject = __webpack_require__("4bf8");
        var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
        var ObjectProto = Object.prototype;
        module2.exports = Object.getPrototypeOf || function(O) {
          O = toObject(O);
          if (has(O, IE_PROTO))
            return O[IE_PROTO];
          if (typeof O.constructor == "function" && O instanceof O.constructor) {
            return O.constructor.prototype;
          }
          return O instanceof Object ? ObjectProto : null;
        };
      },
      "41a0": function(module2, exports2, __webpack_require__) {
        "use strict";
        var create = __webpack_require__("2aeb");
        var descriptor = __webpack_require__("4630");
        var setToStringTag = __webpack_require__("7f20");
        var IteratorPrototype = {};
        __webpack_require__("32e9")(IteratorPrototype, __webpack_require__("2b4c")("iterator"), function() {
          return this;
        });
        module2.exports = function(Constructor, NAME, next) {
          Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
          setToStringTag(Constructor, NAME + " Iterator");
        };
      },
      "456d": function(module2, exports2, __webpack_require__) {
        var toObject = __webpack_require__("4bf8");
        var $keys = __webpack_require__("0d58");
        __webpack_require__("5eda")("keys", function() {
          return function keys(it) {
            return $keys(toObject(it));
          };
        });
      },
      "4588": function(module2, exports2) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module2.exports = function(it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
      },
      "4630": function(module2, exports2) {
        module2.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        };
      },
      "4bf8": function(module2, exports2, __webpack_require__) {
        var defined = __webpack_require__("be13");
        module2.exports = function(it) {
          return Object(defined(it));
        };
      },
      "5537": function(module2, exports2, __webpack_require__) {
        var core = __webpack_require__("8378");
        var global2 = __webpack_require__("7726");
        var SHARED = "__core-js_shared__";
        var store = global2[SHARED] || (global2[SHARED] = {});
        (module2.exports = function(key, value) {
          return store[key] || (store[key] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: core.version,
          mode: __webpack_require__("2d00") ? "pure" : "global",
          copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
        });
      },
      "5ca1": function(module2, exports2, __webpack_require__) {
        var global2 = __webpack_require__("7726");
        var core = __webpack_require__("8378");
        var hide = __webpack_require__("32e9");
        var redefine = __webpack_require__("2aba");
        var ctx = __webpack_require__("9b43");
        var PROTOTYPE = "prototype";
        var $export = function(type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
          var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports3[PROTOTYPE] || (exports3[PROTOTYPE] = {});
          var key, own, out, exp;
          if (IS_GLOBAL)
            source = name;
          for (key in source) {
            own = !IS_FORCED && target && target[key] !== void 0;
            out = (own ? target : source)[key];
            exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
            if (target)
              redefine(target, key, out, type & $export.U);
            if (exports3[key] != out)
              hide(exports3, key, exp);
            if (IS_PROTO && expProto[key] != out)
              expProto[key] = out;
          }
        };
        global2.core = core;
        $export.F = 1;
        $export.G = 2;
        $export.S = 4;
        $export.P = 8;
        $export.B = 16;
        $export.W = 32;
        $export.U = 64;
        $export.R = 128;
        module2.exports = $export;
      },
      "5eda": function(module2, exports2, __webpack_require__) {
        var $export = __webpack_require__("5ca1");
        var core = __webpack_require__("8378");
        var fails = __webpack_require__("79e5");
        module2.exports = function(KEY, exec) {
          var fn = (core.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export($export.S + $export.F * fails(function() {
            fn(1);
          }), "Object", exp);
        };
      },
      "613b": function(module2, exports2, __webpack_require__) {
        var shared = __webpack_require__("5537")("keys");
        var uid = __webpack_require__("ca5a");
        module2.exports = function(key) {
          return shared[key] || (shared[key] = uid(key));
        };
      },
      "626a": function(module2, exports2, __webpack_require__) {
        var cof = __webpack_require__("2d95");
        module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
          return cof(it) == "String" ? it.split("") : Object(it);
        };
      },
      "6821": function(module2, exports2, __webpack_require__) {
        var IObject = __webpack_require__("626a");
        var defined = __webpack_require__("be13");
        module2.exports = function(it) {
          return IObject(defined(it));
        };
      },
      "69a8": function(module2, exports2) {
        var hasOwnProperty = {}.hasOwnProperty;
        module2.exports = function(it, key) {
          return hasOwnProperty.call(it, key);
        };
      },
      "6a99": function(module2, exports2, __webpack_require__) {
        var isObject = __webpack_require__("d3f4");
        module2.exports = function(it, S) {
          if (!isObject(it))
            return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
            return val;
          if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it)))
            return val;
          if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      "7726": function(module2, exports2) {
        var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
        if (typeof __g == "number")
          __g = global2;
      },
      "77f1": function(module2, exports2, __webpack_require__) {
        var toInteger = __webpack_require__("4588");
        var max = Math.max;
        var min = Math.min;
        module2.exports = function(index, length) {
          index = toInteger(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };
      },
      "79e5": function(module2, exports2) {
        module2.exports = function(exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
      },
      "7f20": function(module2, exports2, __webpack_require__) {
        var def = __webpack_require__("86cc").f;
        var has = __webpack_require__("69a8");
        var TAG = __webpack_require__("2b4c")("toStringTag");
        module2.exports = function(it, tag, stat) {
          if (it && !has(it = stat ? it : it.prototype, TAG))
            def(it, TAG, { configurable: true, value: tag });
        };
      },
      "7f7f": function(module2, exports2, __webpack_require__) {
        var dP = __webpack_require__("86cc").f;
        var FProto = Function.prototype;
        var nameRE = /^\s*function ([^ (]*)/;
        var NAME = "name";
        NAME in FProto || __webpack_require__("9e1e") && dP(FProto, NAME, {
          configurable: true,
          get: function() {
            try {
              return ("" + this).match(nameRE)[1];
            } catch (e) {
              return "";
            }
          }
        });
      },
      "8378": function(module2, exports2) {
        var core = module2.exports = { version: "2.6.11" };
        if (typeof __e == "number")
          __e = core;
      },
      "84f2": function(module2, exports2) {
        module2.exports = {};
      },
      "86cc": function(module2, exports2, __webpack_require__) {
        var anObject = __webpack_require__("cb7c");
        var IE8_DOM_DEFINE = __webpack_require__("c69a");
        var toPrimitive = __webpack_require__("6a99");
        var dP = Object.defineProperty;
        exports2.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return dP(O, P, Attributes);
            } catch (e) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError("Accessors not supported!");
          if ("value" in Attributes)
            O[P] = Attributes.value;
          return O;
        };
      },
      "8bbf": function(module2, exports2) {
        module2.exports = require_vue_runtime_common();
      },
      "9b43": function(module2, exports2, __webpack_require__) {
        var aFunction = __webpack_require__("d8e8");
        module2.exports = function(fn, that, length) {
          aFunction(fn);
          if (that === void 0)
            return fn;
          switch (length) {
            case 1:
              return function(a) {
                return fn.call(that, a);
              };
            case 2:
              return function(a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function(a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function() {
            return fn.apply(that, arguments);
          };
        };
      },
      "9c6c": function(module2, exports2, __webpack_require__) {
        var UNSCOPABLES = __webpack_require__("2b4c")("unscopables");
        var ArrayProto = Array.prototype;
        if (ArrayProto[UNSCOPABLES] == void 0)
          __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});
        module2.exports = function(key) {
          ArrayProto[UNSCOPABLES][key] = true;
        };
      },
      "9def": function(module2, exports2, __webpack_require__) {
        var toInteger = __webpack_require__("4588");
        var min = Math.min;
        module2.exports = function(it) {
          return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
        };
      },
      "9e1e": function(module2, exports2, __webpack_require__) {
        module2.exports = !__webpack_require__("79e5")(function() {
          return Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      },
      "ac6a": function(module2, exports2, __webpack_require__) {
        var $iterators = __webpack_require__("cadf");
        var getKeys = __webpack_require__("0d58");
        var redefine = __webpack_require__("2aba");
        var global2 = __webpack_require__("7726");
        var hide = __webpack_require__("32e9");
        var Iterators = __webpack_require__("84f2");
        var wks = __webpack_require__("2b4c");
        var ITERATOR = wks("iterator");
        var TO_STRING_TAG = wks("toStringTag");
        var ArrayValues = Iterators.Array;
        var DOMIterables = {
          CSSRuleList: true,
          CSSStyleDeclaration: false,
          CSSValueList: false,
          ClientRectList: false,
          DOMRectList: false,
          DOMStringList: false,
          DOMTokenList: true,
          DataTransferItemList: false,
          FileList: false,
          HTMLAllCollection: false,
          HTMLCollection: false,
          HTMLFormElement: false,
          HTMLSelectElement: false,
          MediaList: true,
          MimeTypeArray: false,
          NamedNodeMap: false,
          NodeList: true,
          PaintRequestList: false,
          Plugin: false,
          PluginArray: false,
          SVGLengthList: false,
          SVGNumberList: false,
          SVGPathSegList: false,
          SVGPointList: false,
          SVGStringList: false,
          SVGTransformList: false,
          SourceBufferList: false,
          StyleSheetList: true,
          TextTrackCueList: false,
          TextTrackList: false,
          TouchList: false
        };
        for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
          var NAME = collections[i];
          var explicit = DOMIterables[NAME];
          var Collection = global2[NAME];
          var proto = Collection && Collection.prototype;
          var key;
          if (proto) {
            if (!proto[ITERATOR])
              hide(proto, ITERATOR, ArrayValues);
            if (!proto[TO_STRING_TAG])
              hide(proto, TO_STRING_TAG, NAME);
            Iterators[NAME] = ArrayValues;
            if (explicit) {
              for (key in $iterators)
                if (!proto[key])
                  redefine(proto, key, $iterators[key], true);
            }
          }
        }
      },
      "be13": function(module2, exports2) {
        module2.exports = function(it) {
          if (it == void 0)
            throw TypeError("Can't call method on  " + it);
          return it;
        };
      },
      "c366": function(module2, exports2, __webpack_require__) {
        var toIObject = __webpack_require__("6821");
        var toLength = __webpack_require__("9def");
        var toAbsoluteIndex = __webpack_require__("77f1");
        module2.exports = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            if (IS_INCLUDES && el != el)
              while (length > index) {
                value = O[index++];
                if (value != value)
                  return true;
              }
            else
              for (; length > index; index++)
                if (IS_INCLUDES || index in O) {
                  if (O[index] === el)
                    return IS_INCLUDES || index || 0;
                }
            return !IS_INCLUDES && -1;
          };
        };
      },
      "c69a": function(module2, exports2, __webpack_require__) {
        module2.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function() {
          return Object.defineProperty(__webpack_require__("230e")("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      },
      "ca5a": function(module2, exports2) {
        var id = 0;
        var px = Math.random();
        module2.exports = function(key) {
          return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
        };
      },
      "cadf": function(module2, exports2, __webpack_require__) {
        "use strict";
        var addToUnscopables = __webpack_require__("9c6c");
        var step = __webpack_require__("d53b");
        var Iterators = __webpack_require__("84f2");
        var toIObject = __webpack_require__("6821");
        module2.exports = __webpack_require__("01f9")(Array, "Array", function(iterated, kind) {
          this._t = toIObject(iterated);
          this._i = 0;
          this._k = kind;
        }, function() {
          var O = this._t;
          var kind = this._k;
          var index = this._i++;
          if (!O || index >= O.length) {
            this._t = void 0;
            return step(1);
          }
          if (kind == "keys")
            return step(0, index);
          if (kind == "values")
            return step(0, O[index]);
          return step(0, [index, O[index]]);
        }, "values");
        Iterators.Arguments = Iterators.Array;
        addToUnscopables("keys");
        addToUnscopables("values");
        addToUnscopables("entries");
      },
      "cb7c": function(module2, exports2, __webpack_require__) {
        var isObject = __webpack_require__("d3f4");
        module2.exports = function(it) {
          if (!isObject(it))
            throw TypeError(it + " is not an object!");
          return it;
        };
      },
      "ce10": function(module2, exports2, __webpack_require__) {
        var has = __webpack_require__("69a8");
        var toIObject = __webpack_require__("6821");
        var arrayIndexOf = __webpack_require__("c366")(false);
        var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
        module2.exports = function(object, names) {
          var O = toIObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O)
            if (key != IE_PROTO)
              has(O, key) && result.push(key);
          while (names.length > i)
            if (has(O, key = names[i++])) {
              ~arrayIndexOf(result, key) || result.push(key);
            }
          return result;
        };
      },
      "d3f4": function(module2, exports2) {
        module2.exports = function(it) {
          return typeof it === "object" ? it !== null : typeof it === "function";
        };
      },
      "d53b": function(module2, exports2) {
        module2.exports = function(done, value) {
          return { value, done: !!done };
        };
      },
      "d8e8": function(module2, exports2) {
        module2.exports = function(it) {
          if (typeof it != "function")
            throw TypeError(it + " is not a function!");
          return it;
        };
      },
      "e11e": function(module2, exports2) {
        module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      },
      "f6fd": function(module2, exports2) {
        (function(document2) {
          var currentScript = "currentScript", scripts = document2.getElementsByTagName("script");
          if (!(currentScript in document2)) {
            Object.defineProperty(document2, currentScript, {
              get: function() {
                try {
                  throw new Error();
                } catch (err) {
                  var i, res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1];
                  for (i in scripts) {
                    if (scripts[i].src == res || scripts[i].readyState == "interactive") {
                      return scripts[i];
                    }
                  }
                  return null;
                }
              }
            });
          }
        })(document);
      },
      "fa5b": function(module2, exports2, __webpack_require__) {
        module2.exports = __webpack_require__("5537")("native-function-to-string", Function.toString);
      },
      "fab2": function(module2, exports2, __webpack_require__) {
        var document2 = __webpack_require__("7726").document;
        module2.exports = document2 && document2.documentElement;
      },
      "fb15": function(module2, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        if (typeof window !== "undefined") {
          if (true) {
            __webpack_require__("f6fd");
          }
          var i;
          if ((i = window.document.currentScript) && (i = i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
            __webpack_require__.p = i[1];
          }
        }
        var setPublicPath = null;
        var es6_function_name = __webpack_require__("7f7f");
        var es6_array_iterator = __webpack_require__("cadf");
        var es6_object_keys = __webpack_require__("456d");
        var web_dom_iterable = __webpack_require__("ac6a");
        var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
        var external_commonjs_vue_commonjs2_vue_root_Vue_default = __webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);
        var render = function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("img", { attrs: { "src": _vm.mediapath, "alt": _vm.coinname + "-logo" }, on: { "error": _vm.imageLoadError } });
        };
        var staticRenderFns = [];
        var IconCryptovue_type_script_lang_js_ = {
          name: "IconCrypto",
          props: {
            coinname: {
              required: true
            },
            color: {
              type: String,
              default: "color",
              validator: function validator(value) {
                return ["color", "black", "white"].indexOf(value) !== -1;
              }
            },
            format: {
              type: String,
              default: "svg",
              validator: function validator(value) {
                return ["32", "128", "svg"].indexOf(value) !== -1;
              }
            }
          },
          data: function data() {
            return {
              ext: ".png"
            };
          },
          created: function created() {
            if (this.format === "svg") {
              this.ext = ".svg";
            }
          },
          methods: {
            imageLoadError: function imageLoadError(event) {
              event.target.src = "https://cdn.jsdelivr.net/npm/cryptocurrency-icons@0.16.1/svg/black/generic.svg";
            }
          },
          computed: {
            mediapath: function mediapath() {
              var coin = this.coinname !== void 0 && this.coinname !== "" ? this.coinname.toLowerCase() : "generic";
              return "https://cdn.jsdelivr.net/npm/cryptocurrency-icons@0.16.1/".concat(this.format, "/").concat(this.color, "/").concat(coin + this.ext);
            }
          }
        };
        var components_IconCryptovue_type_script_lang_js_ = IconCryptovue_type_script_lang_js_;
        function normalizeComponent(scriptExports, render2, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
          var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
          if (render2) {
            options.render = render2;
            options.staticRenderFns = staticRenderFns2;
            options._compiled = true;
          }
          if (functionalTemplate) {
            options.functional = true;
          }
          if (scopeId) {
            options._scopeId = "data-v-" + scopeId;
          }
          var hook;
          if (moduleIdentifier) {
            hook = function(context) {
              context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
              if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
                context = __VUE_SSR_CONTEXT__;
              }
              if (injectStyles) {
                injectStyles.call(this, context);
              }
              if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
              }
            };
            options._ssrRegister = hook;
          } else if (injectStyles) {
            hook = shadowMode ? function() {
              injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);
            } : injectStyles;
          }
          if (hook) {
            if (options.functional) {
              options._injectStyles = hook;
              var originalRender = options.render;
              options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
              };
            } else {
              var existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
            }
          }
          return {
            exports: scriptExports,
            options
          };
        }
        var component = normalizeComponent(components_IconCryptovue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);
        var IconCrypto = component.exports;
        var Components = {
          IconCrypto
        };
        Object.keys(Components).forEach(function(name) {
          external_commonjs_vue_commonjs2_vue_root_Vue_default.a.component(name, Components[name]);
        });
        var components = Components;
        var entry_lib = __webpack_exports__["default"] = components;
      }
    });
  }
});

// dep:vue-cryptocurrency-icons
var vue_cryptocurrency_icons_default = require_vue_cryptocurrency_icons_common();
export {
  vue_cryptocurrency_icons_default as default
};
/*!
 * Vue.js v2.7.9
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
//# sourceMappingURL=vue-cryptocurrency-icons.js.map
